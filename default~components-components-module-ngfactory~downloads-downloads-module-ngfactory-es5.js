var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~components-components-module-ngfactory~downloads-downloads-module-ngfactory"], {
        /***/ "./node_modules/@angular/cdk/esm2015/accordion.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/accordion.js ***!
          \********************************************************/
        /*! exports provided: CdkAccordionItem, CdkAccordion, CdkAccordionModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordionItem", function () { return CdkAccordionItem; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordion", function () { return CdkAccordion; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordionModule", function () { return CdkAccordionModule; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each accordion.
             * @type {?}
             */
            var nextId = 0;
            /**
             * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.
             */
            var CdkAccordion = /** @class */ (function () {
                function CdkAccordion() {
                    /**
                     * Emits when the state of the accordion changes
                     */
                    this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Stream that emits true/false when openAll/closeAll is triggered.
                     */
                    this._openCloseAllActions = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * A readonly id value to use for unique selection coordination.
                     */
                    this.id = "cdk-accordion-" + nextId++;
                    this._multi = false;
                }
                Object.defineProperty(CdkAccordion.prototype, "multi", {
                    /**
                     * Whether the accordion should allow multiple expanded accordion items simultaneously.
                     * @return {?}
                     */
                    get: function () { return this._multi; },
                    /**
                     * @param {?} multi
                     * @return {?}
                     */
                    set: function (multi) { this._multi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(multi); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens all enabled accordion items in an accordion where multi is enabled.
                 * @return {?}
                 */
                CdkAccordion.prototype.openAll = function () {
                    this._openCloseAll(true);
                };
                /**
                 * Closes all enabled accordion items in an accordion where multi is enabled.
                 * @return {?}
                 */
                CdkAccordion.prototype.closeAll = function () {
                    this._openCloseAll(false);
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkAccordion.prototype.ngOnChanges = function (changes) {
                    this._stateChanges.next(changes);
                };
                /**
                 * @return {?}
                 */
                CdkAccordion.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                /**
                 * @private
                 * @param {?} expanded
                 * @return {?}
                 */
                CdkAccordion.prototype._openCloseAll = function (expanded) {
                    if (this.multi) {
                        this._openCloseAllActions.next(expanded);
                    }
                };
                return CdkAccordion;
            }());
            CdkAccordion.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-accordion, [cdkAccordion]',
                            exportAs: 'cdkAccordion',
                        },] },
            ];
            CdkAccordion.propDecorators = {
                multi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each accordion item.
             * @type {?}
             */
            var nextId$1 = 0;
            var ɵ0 = undefined;
            /**
             * An basic directive expected to be extended and decorated as a component.  Sets up all
             * events and attributes needed to be managed by a CdkAccordion parent.
             */
            var CdkAccordionItem = /** @class */ (function () {
                /**
                 * @param {?} accordion
                 * @param {?} _changeDetectorRef
                 * @param {?} _expansionDispatcher
                 */
                function CdkAccordionItem(accordion, _changeDetectorRef, _expansionDispatcher) {
                    var _this = this;
                    this.accordion = accordion;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._expansionDispatcher = _expansionDispatcher;
                    /**
                     * Subscription to openAll/closeAll events.
                     */
                    this._openCloseAllSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
                    /**
                     * Event emitted every time the AccordionItem is closed.
                     */
                    this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Event emitted every time the AccordionItem is opened.
                     */
                    this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Event emitted when the AccordionItem is destroyed.
                     */
                    this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Emits whenever the expanded state of the accordion changes.
                     * Primarily used to facilitate two-way binding.
                     * \@docs-private
                     */
                    this.expandedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * The unique AccordionItem id.
                     */
                    this.id = "cdk-accordion-child-" + nextId$1++;
                    this._expanded = false;
                    this._disabled = false;
                    /**
                     * Unregister function for _expansionDispatcher.
                     */
                    this._removeUniqueSelectionListener = ( /**
                     * @return {?}
                     */function () { });
                    this._removeUniqueSelectionListener =
                        _expansionDispatcher.listen(( /**
                         * @param {?} id
                         * @param {?} accordionId
                         * @return {?}
                         */function (id, accordionId) {
                            if (_this.accordion && !_this.accordion.multi &&
                                _this.accordion.id === accordionId && _this.id !== id) {
                                _this.expanded = false;
                            }
                        }));
                    // When an accordion item is hosted in an accordion, subscribe to open/close events.
                    if (this.accordion) {
                        this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
                    }
                }
                Object.defineProperty(CdkAccordionItem.prototype, "expanded", {
                    /**
                     * Whether the AccordionItem is expanded.
                     * @return {?}
                     */
                    get: function () { return this._expanded; },
                    /**
                     * @param {?} expanded
                     * @return {?}
                     */
                    set: function (expanded) {
                        expanded = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(expanded);
                        // Only emit events and update the internal value if the value changes.
                        if (this._expanded !== expanded) {
                            this._expanded = expanded;
                            this.expandedChange.emit(expanded);
                            if (expanded) {
                                this.opened.emit();
                                /**
                                 * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,
                                 * the name value is the id of the accordion.
                                 * @type {?}
                                 */
                                var accordionId = this.accordion ? this.accordion.id : this.id;
                                this._expansionDispatcher.notify(this.id, accordionId);
                            }
                            else {
                                this.closed.emit();
                            }
                            // Ensures that the animation will run when the value is set outside of an `@Input`.
                            // This includes cases like the open, close and toggle methods.
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkAccordionItem.prototype, "disabled", {
                    /**
                     * Whether the AccordionItem is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} disabled
                     * @return {?}
                     */
                    set: function (disabled) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(disabled); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Emits an event for the accordion item being destroyed.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.ngOnDestroy = function () {
                    this.opened.complete();
                    this.closed.complete();
                    this.destroyed.emit();
                    this.destroyed.complete();
                    this._removeUniqueSelectionListener();
                    this._openCloseAllSubscription.unsubscribe();
                };
                /**
                 * Toggles the expanded state of the accordion item.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.toggle = function () {
                    if (!this.disabled) {
                        this.expanded = !this.expanded;
                    }
                };
                /**
                 * Sets the expanded state of the accordion item to false.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.close = function () {
                    if (!this.disabled) {
                        this.expanded = false;
                    }
                };
                /**
                 * Sets the expanded state of the accordion item to true.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.open = function () {
                    if (!this.disabled) {
                        this.expanded = true;
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                CdkAccordionItem.prototype._subscribeToOpenCloseAllActions = function () {
                    var _this = this;
                    return this.accordion._openCloseAllActions.subscribe(( /**
                     * @param {?} expanded
                     * @return {?}
                     */function (/**
                     * @param {?} expanded
                     * @return {?}
                     */ expanded) {
                        // Only change expanded state if item is enabled
                        if (!_this.disabled) {
                            _this.expanded = expanded;
                        }
                    }));
                };
                return CdkAccordionItem;
            }());
            CdkAccordionItem.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-accordion-item, [cdkAccordionItem]',
                            exportAs: 'cdkAccordionItem',
                            providers: [
                                // Provide CdkAccordion as undefined to prevent nested accordion items from registering
                                // to the same accordion.
                                { provide: CdkAccordion, useValue: ɵ0 },
                            ],
                        },] },
            ];
            /** @nocollapse */
            CdkAccordionItem.ctorParameters = function () { return [
                { type: CdkAccordion, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["UniqueSelectionDispatcher"] }
            ]; };
            CdkAccordionItem.propDecorators = {
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                expandedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkAccordionModule = /** @class */ (function () {
                function CdkAccordionModule() {
                }
                return CdkAccordionModule;
            }());
            CdkAccordionModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            exports: [CdkAccordion, CdkAccordionItem],
                            declarations: [CdkAccordion, CdkAccordionItem],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=accordion.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/layout.js": 
        /*!*****************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/layout.js ***!
          \*****************************************************/
        /*! exports provided: LayoutModule, BreakpointObserver, Breakpoints, MediaMatcher */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayoutModule", function () { return LayoutModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BreakpointObserver", function () { return BreakpointObserver; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Breakpoints", function () { return Breakpoints; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaMatcher", function () { return MediaMatcher; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var LayoutModule = /** @class */ (function () {
                function LayoutModule() {
                }
                return LayoutModule;
            }());
            LayoutModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{},] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Global registry for all dynamically-created, injected media queries.
             * @type {?}
             */
            var mediaQueriesForWebkitCompatibility = new Set();
            /**
             * Style tag that holds all of the dynamically-created media queries.
             * @type {?}
             */
            var mediaQueryStyleNode;
            /**
             * A utility for calling matchMedia queries.
             */
            var MediaMatcher = /** @class */ (function () {
                /**
                 * @param {?} _platform
                 */
                function MediaMatcher(_platform) {
                    this._platform = _platform;
                    this._matchMedia = this._platform.isBrowser && window.matchMedia ?
                        // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
                        // call it from a different scope.
                        window.matchMedia.bind(window) :
                        noopMatchMedia;
                }
                /**
                 * Evaluates the given media query and returns the native MediaQueryList from which results
                 * can be retrieved.
                 * Confirms the layout engine will trigger for the selector query provided and returns the
                 * MediaQueryList for the query provided.
                 * @param {?} query
                 * @return {?}
                 */
                MediaMatcher.prototype.matchMedia = function (query) {
                    if (this._platform.WEBKIT) {
                        createEmptyStyleRule(query);
                    }
                    return this._matchMedia(query);
                };
                return MediaMatcher;
            }());
            MediaMatcher.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            MediaMatcher.ctorParameters = function () { return [
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__["Platform"] }
            ]; };
            /** @nocollapse */ MediaMatcher.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MediaMatcher_Factory() { return new MediaMatcher(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__["Platform"])); }, token: MediaMatcher, providedIn: "root" });
            /**
             * For Webkit engines that only trigger the MediaQueryListListener when
             * there is at least one CSS selector for the respective media query.
             * @param {?} query
             * @return {?}
             */
            function createEmptyStyleRule(query) {
                if (mediaQueriesForWebkitCompatibility.has(query)) {
                    return;
                }
                try {
                    if (!mediaQueryStyleNode) {
                        mediaQueryStyleNode = document.createElement('style');
                        mediaQueryStyleNode.setAttribute('type', 'text/css');
                        ( /** @type {?} */(document.head)).appendChild(mediaQueryStyleNode);
                    }
                    if (mediaQueryStyleNode.sheet) {
                        (( /** @type {?} */(mediaQueryStyleNode.sheet)))
                            .insertRule("@media " + query + " {.fx-query-test{ }}", 0);
                        mediaQueriesForWebkitCompatibility.add(query);
                    }
                }
                catch (e) {
                    console.error(e);
                }
            }
            /**
             * No-op matchMedia replacement for non-browser platforms.
             * @param {?} query
             * @return {?}
             */
            function noopMatchMedia(query) {
                // Use `as any` here to avoid adding additional necessary properties for
                // the noop matcher.
                return ( /** @type {?} */({
                    matches: query === 'all' || query === '',
                    media: query,
                    addListener: ( /**
                     * @return {?}
                     */function () { }),
                    removeListener: ( /**
                     * @return {?}
                     */function () { })
                }));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Utility for checking the matching state of \@media queries.
             */
            var BreakpointObserver = /** @class */ (function () {
                /**
                 * @param {?} _mediaMatcher
                 * @param {?} _zone
                 */
                function BreakpointObserver(_mediaMatcher, _zone) {
                    this._mediaMatcher = _mediaMatcher;
                    this._zone = _zone;
                    /**
                     * A map of all media queries currently being listened for.
                     */
                    this._queries = new Map();
                    /**
                     * A subject for all other observables to takeUntil based on.
                     */
                    this._destroySubject = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                }
                /**
                 * Completes the active subject, signalling to all other observables to complete.
                 * @return {?}
                 */
                BreakpointObserver.prototype.ngOnDestroy = function () {
                    this._destroySubject.next();
                    this._destroySubject.complete();
                };
                /**
                 * Whether one or more media queries match the current viewport size.
                 * @param {?} value One or more media queries to check.
                 * @return {?} Whether any of the media queries match.
                 */
                BreakpointObserver.prototype.isMatched = function (value) {
                    var _this = this;
                    /** @type {?} */
                    var queries = splitQueries(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__["coerceArray"])(value));
                    return queries.some(( /**
                     * @param {?} mediaQuery
                     * @return {?}
                     */function (/**
                     * @param {?} mediaQuery
                     * @return {?}
                     */ mediaQuery) { return _this._registerQuery(mediaQuery).mql.matches; }));
                };
                /**
                 * Gets an observable of results for the given queries that will emit new results for any changes
                 * in matching of the given queries.
                 * @param {?} value One or more media queries to check.
                 * @return {?} A stream of matches for the given queries.
                 */
                BreakpointObserver.prototype.observe = function (value) {
                    var _this = this;
                    /** @type {?} */
                    var queries = splitQueries(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__["coerceArray"])(value));
                    /** @type {?} */
                    var observables = queries.map(( /**
                     * @param {?} query
                     * @return {?}
                     */function (/**
                     * @param {?} query
                     * @return {?}
                     */ query) { return _this._registerQuery(query).observable; }));
                    /** @type {?} */
                    var stateObservable = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["combineLatest"])(observables);
                    // Emit the first state immediately, and then debounce the subsequent emissions.
                    stateObservable = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["concat"])(stateObservable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["take"])(1)), stateObservable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["skip"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["debounceTime"])(0)));
                    return stateObservable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(( /**
                     * @param {?} breakpointStates
                     * @return {?}
                     */function (breakpointStates) {
                        /** @type {?} */
                        var response = {
                            matches: false,
                            breakpoints: {},
                        };
                        breakpointStates.forEach(( /**
                         * @param {?} state
                         * @return {?}
                         */function (state) {
                            response.matches = response.matches || state.matches;
                            response.breakpoints[state.query] = state.matches;
                        }));
                        return response;
                    })));
                };
                /**
                 * Registers a specific query to be listened for.
                 * @private
                 * @param {?} query
                 * @return {?}
                 */
                BreakpointObserver.prototype._registerQuery = function (query) {
                    var _this = this;
                    // Only set up a new MediaQueryList if it is not already being listened for.
                    if (this._queries.has(query)) {
                        return ( /** @type {?} */(this._queries.get(query)));
                    }
                    /** @type {?} */
                    var mql = this._mediaMatcher.matchMedia(query);
                    // Create callback for match changes and add it is as a listener.
                    /** @type {?} */
                    var queryObservable = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Observable"](( /**
                     * @param {?} observer
                     * @return {?}
                     */function (observer) {
                        // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed
                        // back into the zone because matchMedia is only included in Zone.js by loading the
                        // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not
                        // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js
                        // patches it.
                        /** @type {?} */
                        var handler = ( /**
                         * @param {?} e
                         * @return {?}
                         */function (e) { return _this._zone.run(( /**
                         * @return {?}
                         */function () { return observer.next(e); })); });
                        mql.addListener(handler);
                        return ( /**
                         * @return {?}
                         */function () {
                            mql.removeListener(handler);
                        });
                    })).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["startWith"])(mql), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(( /**
                     * @param {?} nextMql
                     * @return {?}
                     */function (nextMql) { return ({ query: query, matches: nextMql.matches }); })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroySubject));
                    // Add the MediaQueryList to the set of queries.
                    /** @type {?} */
                    var output = { observable: queryObservable, mql: mql };
                    this._queries.set(query, output);
                    return output;
                };
                return BreakpointObserver;
            }());
            BreakpointObserver.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            BreakpointObserver.ctorParameters = function () { return [
                { type: MediaMatcher },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] }
            ]; };
            /** @nocollapse */ BreakpointObserver.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function BreakpointObserver_Factory() { return new BreakpointObserver(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MediaMatcher), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"])); }, token: BreakpointObserver, providedIn: "root" });
            /**
             * Split each query string into separate query strings if two queries are provided as comma
             * separated.
             * @param {?} queries
             * @return {?}
             */
            function splitQueries(queries) {
                return queries.map(( /**
                 * @param {?} query
                 * @return {?}
                 */function (query) { return query.split(','); }))
                    .reduce(( /**
             * @param {?} a1
             * @param {?} a2
             * @return {?}
             */function (a1, a2) { return a1.concat(a2); }))
                    .map(( /**
             * @param {?} query
             * @return {?}
             */function (/**
             * @param {?} query
             * @return {?}
             */ query) { return query.trim(); }));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // PascalCase is being used as Breakpoints is used like an enum.
            // tslint:disable-next-line:variable-name
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             * @type {?}
             */
            var Breakpoints = {
                XSmall: '(max-width: 599.99px)',
                Small: '(min-width: 600px) and (max-width: 959.99px)',
                Medium: '(min-width: 960px) and (max-width: 1279.99px)',
                Large: '(min-width: 1280px) and (max-width: 1919.99px)',
                XLarge: '(min-width: 1920px)',
                Handset: '(max-width: 599.99px) and (orientation: portrait), ' +
                    '(max-width: 959.99px) and (orientation: landscape)',
                Tablet: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait), ' +
                    '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',
                Web: '(min-width: 840px) and (orientation: portrait), ' +
                    '(min-width: 1280px) and (orientation: landscape)',
                HandsetPortrait: '(max-width: 599.99px) and (orientation: portrait)',
                TabletPortrait: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait)',
                WebPortrait: '(min-width: 840px) and (orientation: portrait)',
                HandsetLandscape: '(max-width: 959.99px) and (orientation: landscape)',
                TabletLandscape: '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',
                WebLandscape: '(min-width: 1280px) and (orientation: landscape)',
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=layout.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/stepper.js": 
        /*!******************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/stepper.js ***!
          \******************************************************/
        /*! exports provided: StepperSelectionEvent, STEP_STATE, STEPPER_GLOBAL_OPTIONS, MAT_STEPPER_GLOBAL_OPTIONS, CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious, CdkStepperModule, CdkStepHeader */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StepperSelectionEvent", function () { return StepperSelectionEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEP_STATE", function () { return STEP_STATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEPPER_GLOBAL_OPTIONS", function () { return STEPPER_GLOBAL_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_GLOBAL_OPTIONS", function () { return MAT_STEPPER_GLOBAL_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStep", function () { return CdkStep; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepper", function () { return CdkStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepLabel", function () { return CdkStepLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperNext", function () { return CdkStepperNext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperPrevious", function () { return CdkStepperPrevious; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperModule", function () { return CdkStepperModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepHeader", function () { return CdkStepHeader; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepHeader = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function CdkStepHeader(_elementRef) {
                    this._elementRef = _elementRef;
                }
                /**
                 * Focuses the step header.
                 * @return {?}
                 */
                CdkStepHeader.prototype.focus = function () {
                    this._elementRef.nativeElement.focus();
                };
                return CdkStepHeader;
            }());
            CdkStepHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepHeader]',
                            host: {
                                'role': 'tab',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkStepHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepLabel = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkStepLabel(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkStepLabel;
            }());
            CdkStepLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepLabel]',
                        },] },
            ];
            /** @nocollapse */
            CdkStepLabel.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each stepper component.
             * @type {?}
             */
            var nextId = 0;
            /**
             * Change event emitted on selection changes.
             */
            var StepperSelectionEvent = /** @class */ (function () {
                function StepperSelectionEvent() {
                }
                return StepperSelectionEvent;
            }());
            /**
             * Enum to represent the different states of the steps.
             * @type {?}
             */
            var STEP_STATE = {
                NUMBER: 'number',
                EDIT: 'edit',
                DONE: 'done',
                ERROR: 'error'
            };
            /**
             * InjectionToken that can be used to specify the global stepper options.
             * @type {?}
             */
            var STEPPER_GLOBAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('STEPPER_GLOBAL_OPTIONS');
            /**
             * InjectionToken that can be used to specify the global stepper options.
             * @deprecated Use `STEPPER_GLOBAL_OPTIONS` instead.
             * \@breaking-change 8.0.0.
             * @type {?}
             */
            var MAT_STEPPER_GLOBAL_OPTIONS = STEPPER_GLOBAL_OPTIONS;
            var CdkStep = /** @class */ (function () {
                /**
                 * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
                 * @param {?} _stepper
                 * @param {?=} stepperOptions
                 */
                function CdkStep(_stepper, stepperOptions) {
                    this._stepper = _stepper;
                    /**
                     * Whether user has seen the expanded step content or not.
                     */
                    this.interacted = false;
                    this._editable = true;
                    this._optional = false;
                    this._completedOverride = null;
                    this._customError = null;
                    this._stepperOptions = stepperOptions ? stepperOptions : {};
                    this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
                    this._showError = !!this._stepperOptions.showError;
                }
                Object.defineProperty(CdkStep.prototype, "editable", {
                    /**
                     * Whether the user can return to this step once it has been marked as completed.
                     * @return {?}
                     */
                    get: function () {
                        return this._editable;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._editable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStep.prototype, "optional", {
                    /**
                     * Whether the completion of step is optional.
                     * @return {?}
                     */
                    get: function () {
                        return this._optional;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._optional = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStep.prototype, "completed", {
                    /**
                     * Whether step is marked as completed.
                     * @return {?}
                     */
                    get: function () {
                        return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._completedOverride = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                CdkStep.prototype._getDefaultCompleted = function () {
                    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
                };
                Object.defineProperty(CdkStep.prototype, "hasError", {
                    /**
                     * Whether step has an error.
                     * @return {?}
                     */
                    get: function () {
                        return this._customError == null ? this._getDefaultError() : this._customError;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._customError = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                CdkStep.prototype._getDefaultError = function () {
                    return this.stepControl && this.stepControl.invalid && this.interacted;
                };
                /**
                 * Selects this step component.
                 * @return {?}
                 */
                CdkStep.prototype.select = function () {
                    this._stepper.selected = this;
                };
                /**
                 * Resets the step to its initial state. Note that this includes resetting form data.
                 * @return {?}
                 */
                CdkStep.prototype.reset = function () {
                    this.interacted = false;
                    if (this._completedOverride != null) {
                        this._completedOverride = false;
                    }
                    if (this._customError != null) {
                        this._customError = false;
                    }
                    if (this.stepControl) {
                        this.stepControl.reset();
                    }
                };
                /**
                 * @return {?}
                 */
                CdkStep.prototype.ngOnChanges = function () {
                    // Since basically all inputs of the MatStep get proxied through the view down to the
                    // underlying MatStepHeader, we have to make sure that change detection runs correctly.
                    this._stepper._stateChanged();
                };
                return CdkStep;
            }());
            CdkStep.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'cdk-step',
                            exportAs: 'cdkStep',
                            template: '<ng-template><ng-content></ng-content></ng-template>',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            CdkStep.ctorParameters = function () { return [
                { type: CdkStepper, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return CdkStepper; })),] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [STEPPER_GLOBAL_OPTIONS,] }] }
            ]; };
            CdkStep.propDecorators = {
                stepLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [CdkStepLabel, { static: false },] }],
                content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], { static: true },] }],
                stepControl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                errorMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                state: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                editable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                optional: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                completed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                hasError: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var CdkStepper = /** @class */ (function () {
                /**
                 * @param {?} _dir
                 * @param {?} _changeDetectorRef
                 * @param {?=} _elementRef
                 * @param {?=} _document
                 */
                function CdkStepper(_dir, _changeDetectorRef, _elementRef, _document) {
                    this._dir = _dir;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._elementRef = _elementRef;
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._linear = false;
                    this._selectedIndex = 0;
                    /**
                     * Event emitted when the selected step has changed.
                     */
                    this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._orientation = 'horizontal';
                    this._groupId = nextId++;
                    this._document = _document;
                }
                Object.defineProperty(CdkStepper.prototype, "steps", {
                    /**
                     * The list of step components that the stepper is holding.
                     * @return {?}
                     */
                    get: function () {
                        return this._steps;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "linear", {
                    /**
                     * Whether the validity of previous steps should be checked or not.
                     * @return {?}
                     */
                    get: function () {
                        return this._linear;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._linear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "selectedIndex", {
                    /**
                     * The index of the selected step.
                     * @return {?}
                     */
                    get: function () {
                        return this._selectedIndex;
                    },
                    /**
                     * @param {?} index
                     * @return {?}
                     */
                    set: function (index) {
                        /** @type {?} */
                        var newIndex = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceNumberProperty"])(index);
                        if (this.steps) {
                            // Ensure that the index can't be out of bounds.
                            if (newIndex < 0 || newIndex > this.steps.length - 1) {
                                throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');
                            }
                            if (this._selectedIndex != newIndex && !this._anyControlsInvalidOrPending(newIndex) &&
                                (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {
                                this._updateSelectedItemIndex(index);
                            }
                        }
                        else {
                            this._selectedIndex = newIndex;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "selected", {
                    /**
                     * The step that is selected.
                     * @return {?}
                     */
                    get: function () {
                        // @breaking-change 8.0.0 Change return type to `CdkStep | undefined`.
                        return this.steps ? this.steps.toArray()[this.selectedIndex] : ( /** @type {?} */(undefined));
                    },
                    /**
                     * @param {?} step
                     * @return {?}
                     */
                    set: function (step) {
                        this.selectedIndex = this.steps ? this.steps.toArray().indexOf(step) : -1;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkStepper.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    // Note that while the step headers are content children by default, any components that
                    // extend this one might have them as view chidren. We initialize the keyboard handling in
                    // AfterViewInit so we're guaranteed for both view and content children to be defined.
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusKeyManager"](this._stepHeader)
                        .withWrap()
                        .withVerticalOrientation(this._orientation === 'vertical');
                    (this._dir ? (( /** @type {?} */(this._dir.change))) : Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])())
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(this._layoutDirection()), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @param {?} direction
                 * @return {?}
                 */function (/**
                 * @param {?} direction
                 * @return {?}
                 */ direction) { return _this._keyManager.withHorizontalOrientation(direction); }));
                    this._keyManager.updateActiveItemIndex(this._selectedIndex);
                    this.steps.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (!_this.selected) {
                            _this._selectedIndex = Math.max(_this._selectedIndex - 1, 0);
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                CdkStepper.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Selects and focuses the next step in list.
                 * @return {?}
                 */
                CdkStepper.prototype.next = function () {
                    this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
                };
                /**
                 * Selects and focuses the previous step in list.
                 * @return {?}
                 */
                CdkStepper.prototype.previous = function () {
                    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
                };
                /**
                 * Resets the stepper to its initial state. Note that this includes clearing form data.
                 * @return {?}
                 */
                CdkStepper.prototype.reset = function () {
                    this._updateSelectedItemIndex(0);
                    this.steps.forEach(( /**
                     * @param {?} step
                     * @return {?}
                     */function (/**
                     * @param {?} step
                     * @return {?}
                     */ step) { return step.reset(); }));
                    this._stateChanged();
                };
                /**
                 * Returns a unique id for each step label element.
                 * @param {?} i
                 * @return {?}
                 */
                CdkStepper.prototype._getStepLabelId = function (i) {
                    return "cdk-step-label-" + this._groupId + "-" + i;
                };
                /**
                 * Returns unique id for each step content element.
                 * @param {?} i
                 * @return {?}
                 */
                CdkStepper.prototype._getStepContentId = function (i) {
                    return "cdk-step-content-" + this._groupId + "-" + i;
                };
                /**
                 * Marks the component to be change detected.
                 * @return {?}
                 */
                CdkStepper.prototype._stateChanged = function () {
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Returns position state of the step with the given index.
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._getAnimationDirection = function (index) {
                    /** @type {?} */
                    var position = index - this._selectedIndex;
                    if (position < 0) {
                        return this._layoutDirection() === 'rtl' ? 'next' : 'previous';
                    }
                    else if (position > 0) {
                        return this._layoutDirection() === 'rtl' ? 'previous' : 'next';
                    }
                    return 'current';
                };
                /**
                 * Returns the type of icon to be displayed.
                 * @param {?} index
                 * @param {?=} state
                 * @return {?}
                 */
                CdkStepper.prototype._getIndicatorType = function (index, state) {
                    if (state === void 0) { state = STEP_STATE.NUMBER; }
                    /** @type {?} */
                    var step = this.steps.toArray()[index];
                    /** @type {?} */
                    var isCurrentStep = this._isCurrentStep(index);
                    return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) :
                        this._getGuidelineLogic(step, isCurrentStep, state);
                };
                /**
                 * @private
                 * @param {?} step
                 * @param {?} isCurrentStep
                 * @return {?}
                 */
                CdkStepper.prototype._getDefaultIndicatorLogic = function (step, isCurrentStep) {
                    if (step._showError && step.hasError && !isCurrentStep) {
                        return STEP_STATE.ERROR;
                    }
                    else if (!step.completed || isCurrentStep) {
                        return STEP_STATE.NUMBER;
                    }
                    else {
                        return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
                    }
                };
                /**
                 * @private
                 * @param {?} step
                 * @param {?} isCurrentStep
                 * @param {?=} state
                 * @return {?}
                 */
                CdkStepper.prototype._getGuidelineLogic = function (step, isCurrentStep, state) {
                    if (state === void 0) { state = STEP_STATE.NUMBER; }
                    if (step._showError && step.hasError && !isCurrentStep) {
                        return STEP_STATE.ERROR;
                    }
                    else if (step.completed && !isCurrentStep) {
                        return STEP_STATE.DONE;
                    }
                    else if (step.completed && isCurrentStep) {
                        return state;
                    }
                    else if (step.editable && isCurrentStep) {
                        return STEP_STATE.EDIT;
                    }
                    else {
                        return state;
                    }
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._isCurrentStep = function (index) {
                    return this._selectedIndex === index;
                };
                /**
                 * Returns the index of the currently-focused step header.
                 * @return {?}
                 */
                CdkStepper.prototype._getFocusIndex = function () {
                    return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
                };
                /**
                 * @private
                 * @param {?} newIndex
                 * @return {?}
                 */
                CdkStepper.prototype._updateSelectedItemIndex = function (newIndex) {
                    /** @type {?} */
                    var stepsArray = this.steps.toArray();
                    this.selectionChange.emit({
                        selectedIndex: newIndex,
                        previouslySelectedIndex: this._selectedIndex,
                        selectedStep: stepsArray[newIndex],
                        previouslySelectedStep: stepsArray[this._selectedIndex],
                    });
                    // If focus is inside the stepper, move it to the next header, otherwise it may become
                    // lost when the active step content is hidden. We can't be more granular with the check
                    // (e.g. checking whether focus is inside the active step), because we don't have a
                    // reference to the elements that are rendering out the content.
                    this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :
                        this._keyManager.updateActiveItemIndex(newIndex);
                    this._selectedIndex = newIndex;
                    this._stateChanged();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                CdkStepper.prototype._onKeydown = function (event) {
                    /** @type {?} */
                    var hasModifier = Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["hasModifierKey"])(event);
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (manager.activeItemIndex != null && !hasModifier &&
                        (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["SPACE"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ENTER"])) {
                        this.selectedIndex = manager.activeItemIndex;
                        event.preventDefault();
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["HOME"]) {
                        manager.setFirstItemActive();
                        event.preventDefault();
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["END"]) {
                        manager.setLastItemActive();
                        event.preventDefault();
                    }
                    else {
                        manager.onKeydown(event);
                    }
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._anyControlsInvalidOrPending = function (index) {
                    /** @type {?} */
                    var steps = this.steps.toArray();
                    steps[this._selectedIndex].interacted = true;
                    if (this._linear && index >= 0) {
                        return steps.slice(0, index).some(( /**
                         * @param {?} step
                         * @return {?}
                         */function (/**
                         * @param {?} step
                         * @return {?}
                         */ step) {
                            /** @type {?} */
                            var control = step.stepControl;
                            /** @type {?} */
                            var isIncomplete = control ? (control.invalid || control.pending || !step.interacted) : !step.completed;
                            return isIncomplete && !step.optional && !step._completedOverride;
                        }));
                    }
                    return false;
                };
                /**
                 * @private
                 * @return {?}
                 */
                CdkStepper.prototype._layoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Checks whether the stepper contains the focused element.
                 * @private
                 * @return {?}
                 */
                CdkStepper.prototype._containsFocus = function () {
                    if (!this._document || !this._elementRef) {
                        return false;
                    }
                    /** @type {?} */
                    var stepperElement = this._elementRef.nativeElement;
                    /** @type {?} */
                    var focusedElement = this._document.activeElement;
                    return stepperElement === focusedElement || stepperElement.contains(focusedElement);
                };
                return CdkStepper;
            }());
            CdkStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepper]',
                            exportAs: 'cdkStepper',
                        },] },
            ];
            /** @nocollapse */
            CdkStepper.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] }
            ]; };
            CdkStepper.propDecorators = {
                _steps: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [CdkStep,] }],
                _stepHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [CdkStepHeader,] }],
                linear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Button that moves to the next step in a stepper workflow.
             */
            var CdkStepperNext = /** @class */ (function () {
                /**
                 * @param {?} _stepper
                 */
                function CdkStepperNext(_stepper) {
                    this._stepper = _stepper;
                    /**
                     * Type of the next button. Defaults to "submit" if not specified.
                     */
                    this.type = 'submit';
                }
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @return {?}
                 */
                CdkStepperNext.prototype._handleClick = function () {
                    this._stepper.next();
                };
                return CdkStepperNext;
            }());
            CdkStepperNext.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[cdkStepperNext]',
                            host: {
                                '[type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            CdkStepperNext.ctorParameters = function () { return [
                { type: CdkStepper }
            ]; };
            CdkStepperNext.propDecorators = {
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _handleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"], args: ['click',] }]
            };
            /**
             * Button that moves to the previous step in a stepper workflow.
             */
            var CdkStepperPrevious = /** @class */ (function () {
                /**
                 * @param {?} _stepper
                 */
                function CdkStepperPrevious(_stepper) {
                    this._stepper = _stepper;
                    /**
                     * Type of the previous button. Defaults to "button" if not specified.
                     */
                    this.type = 'button';
                }
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @return {?}
                 */
                CdkStepperPrevious.prototype._handleClick = function () {
                    this._stepper.previous();
                };
                return CdkStepperPrevious;
            }());
            CdkStepperPrevious.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[cdkStepperPrevious]',
                            host: {
                                '[type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            CdkStepperPrevious.ctorParameters = function () { return [
                { type: CdkStepper }
            ]; };
            CdkStepperPrevious.propDecorators = {
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _handleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"], args: ['click',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepperModule = /** @class */ (function () {
                function CdkStepperModule() {
                }
                return CdkStepperModule;
            }());
            CdkStepperModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["BidiModule"], _angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: [
                                CdkStep,
                                CdkStepper,
                                CdkStepHeader,
                                CdkStepLabel,
                                CdkStepperNext,
                                CdkStepperPrevious,
                            ],
                            declarations: [
                                CdkStep,
                                CdkStepper,
                                CdkStepHeader,
                                CdkStepLabel,
                                CdkStepperNext,
                                CdkStepperPrevious,
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=stepper.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/table.js": 
        /*!****************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/table.js ***!
          \****************************************************/
        /*! exports provided: DataSource, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CDK_TABLE_TEMPLATE, CdkTable, CdkCellDef, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, BaseCdkCell, CdkHeaderCell, CdkFooterCell, CdkCell, CDK_ROW_TEMPLATE, BaseRowDef, CdkHeaderRowDef, CdkFooterRowDef, CdkRowDef, CdkCellOutlet, CdkHeaderRow, CdkFooterRow, CdkRow, CdkTableModule, STICKY_DIRECTIONS, StickyStyler, mixinHasStickyInput, TEXT_COLUMN_OPTIONS, CdkTextColumn */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataRowOutlet", function () { return DataRowOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeaderRowOutlet", function () { return HeaderRowOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FooterRowOutlet", function () { return FooterRowOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CDK_TABLE_TEMPLATE", function () { return CDK_TABLE_TEMPLATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTable", function () { return CdkTable; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkCellDef", function () { return CdkCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderCellDef", function () { return CdkHeaderCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterCellDef", function () { return CdkFooterCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkColumnDef", function () { return CdkColumnDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseCdkCell", function () { return BaseCdkCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderCell", function () { return CdkHeaderCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterCell", function () { return CdkFooterCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkCell", function () { return CdkCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CDK_ROW_TEMPLATE", function () { return CDK_ROW_TEMPLATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseRowDef", function () { return BaseRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderRowDef", function () { return CdkHeaderRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterRowDef", function () { return CdkFooterRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkRowDef", function () { return CdkRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkCellOutlet", function () { return CdkCellOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderRow", function () { return CdkHeaderRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterRow", function () { return CdkFooterRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkRow", function () { return CdkRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTableModule", function () { return CdkTableModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STICKY_DIRECTIONS", function () { return STICKY_DIRECTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StickyStyler", function () { return StickyStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mixinHasStickyInput", function () { return mixinHasStickyInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_COLUMN_OPTIONS", function () { return TEXT_COLUMN_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTextColumn", function () { return CdkTextColumn; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataSource", function () { return _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["DataSource"]; });
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Mixin to provide a directive with a function that checks if the sticky input has been
             * changed since the last time the function was called. Essentially adds a dirty-check to the
             * sticky value.
             * \@docs-private
             * @template T
             * @param {?} base
             * @return {?}
             */
            function mixinHasStickyInput(base) {
                return /** @class */ (function (_super) {
                    __extends(class_1, _super);
                    /**
                     * @param {...?} args
                     */
                    function class_1() {
                        var args = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            args[_a] = arguments[_a];
                        }
                        var _this = _super.apply(this, args) || this;
                        _this._sticky = false;
                        /**
                         * Whether the sticky input has changed since it was last checked.
                         */
                        _this._hasStickyChanged = false;
                        return _this;
                    }
                    Object.defineProperty(class_1.prototype, "sticky", {
                        /**
                         * Whether sticky positioning should be applied.
                         * @return {?}
                         */
                        get: function () { return this._sticky; },
                        /**
                         * @param {?} v
                         * @return {?}
                         */
                        set: function (v) {
                            /** @type {?} */
                            var prevValue = this._sticky;
                            this._sticky = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
                            this._hasStickyChanged = prevValue !== this._sticky;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Whether the sticky value has changed since this was last called.
                     * @return {?}
                     */
                    class_1.prototype.hasStickyChanged = function () {
                        /** @type {?} */
                        var hasStickyChanged = this._hasStickyChanged;
                        this._hasStickyChanged = false;
                        return hasStickyChanged;
                    };
                    /**
                     * Resets the dirty check for cases where the sticky state has been used without checking.
                     * @return {?}
                     */
                    class_1.prototype.resetStickyChanged = function () {
                        this._hasStickyChanged = false;
                    };
                    return class_1;
                }(base));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Cell definition for a CDK table.
             * Captures the template of a column's data row cell as well as cell-specific properties.
             */
            var CdkCellDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkCellDef(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkCellDef;
            }());
            CdkCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkCellDef]' },] },
            ];
            /** @nocollapse */
            CdkCellDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
            ]; };
            /**
             * Header cell definition for a CDK table.
             * Captures the template of a column's header cell and as well as cell-specific properties.
             */
            var CdkHeaderCellDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkHeaderCellDef(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkHeaderCellDef;
            }());
            CdkHeaderCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkHeaderCellDef]' },] },
            ];
            /** @nocollapse */
            CdkHeaderCellDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
            ]; };
            /**
             * Footer cell definition for a CDK table.
             * Captures the template of a column's footer cell and as well as cell-specific properties.
             */
            var CdkFooterCellDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkFooterCellDef(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkFooterCellDef;
            }());
            CdkFooterCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkFooterCellDef]' },] },
            ];
            /** @nocollapse */
            CdkFooterCellDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
            ]; };
            // Boilerplate for applying mixins to CdkColumnDef.
            /**
             * \@docs-private
             */
            var CdkColumnDefBase = /** @class */ (function () {
                function CdkColumnDefBase() {
                }
                return CdkColumnDefBase;
            }());
            /** @type {?} */
            var _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);
            /**
             * Column definition for the CDK table.
             * Defines a set of cells available for a table column.
             */
            var CdkColumnDef = /** @class */ (function (_super) {
                __extends(CdkColumnDef, _super);
                function CdkColumnDef() {
                    var _this = _super.apply(this, arguments) || this;
                    _this._stickyEnd = false;
                    return _this;
                }
                Object.defineProperty(CdkColumnDef.prototype, "name", {
                    /**
                     * Unique name for this column.
                     * @return {?}
                     */
                    get: function () {
                        return this._name;
                    },
                    /**
                     * @param {?} name
                     * @return {?}
                     */
                    set: function (name) {
                        // If the directive is set without a name (updated programatically), then this setter will
                        // trigger with an empty string and should not overwrite the programatically set value.
                        if (!name) {
                            return;
                        }
                        this._name = name;
                        this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkColumnDef.prototype, "stickyEnd", {
                    /**
                     * Whether this column should be sticky positioned on the end of the row. Should make sure
                     * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
                     * has been changed.
                     * @return {?}
                     */
                    get: function () {
                        return this._stickyEnd;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        /** @type {?} */
                        var prevValue = this._stickyEnd;
                        this._stickyEnd = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
                        this._hasStickyChanged = prevValue !== this._stickyEnd;
                    },
                    enumerable: true,
                    configurable: true
                });
                return CdkColumnDef;
            }(_CdkColumnDefBase));
            CdkColumnDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkColumnDef]',
                            inputs: ['sticky'],
                            providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }],
                        },] },
            ];
            CdkColumnDef.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkColumnDef',] }],
                stickyEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['stickyEnd',] }],
                cell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [CdkCellDef, { static: false },] }],
                headerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [CdkHeaderCellDef, { static: false },] }],
                footerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [CdkFooterCellDef, { static: false },] }]
            };
            /**
             * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
             */
            var BaseCdkCell = /** @class */ (function () {
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function BaseCdkCell(columnDef, elementRef) {
                    /** @type {?} */
                    var columnClassName = "cdk-column-" + columnDef.cssClassFriendlyName;
                    elementRef.nativeElement.classList.add(columnClassName);
                }
                return BaseCdkCell;
            }());
            /**
             * Header cell template container that adds the right classes and role.
             */
            var CdkHeaderCell = /** @class */ (function (_super) {
                __extends(CdkHeaderCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function CdkHeaderCell(columnDef, elementRef) {
                    return _super.call(this, columnDef, elementRef) || this;
                }
                return CdkHeaderCell;
            }(BaseCdkCell));
            CdkHeaderCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-header-cell, th[cdk-header-cell]',
                            host: {
                                'class': 'cdk-header-cell',
                                'role': 'columnheader',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkHeaderCell.ctorParameters = function () { return [
                { type: CdkColumnDef },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Footer cell template container that adds the right classes and role.
             */
            var CdkFooterCell = /** @class */ (function (_super) {
                __extends(CdkFooterCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function CdkFooterCell(columnDef, elementRef) {
                    return _super.call(this, columnDef, elementRef) || this;
                }
                return CdkFooterCell;
            }(BaseCdkCell));
            CdkFooterCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-footer-cell, td[cdk-footer-cell]',
                            host: {
                                'class': 'cdk-footer-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkFooterCell.ctorParameters = function () { return [
                { type: CdkColumnDef },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Cell template container that adds the right classes and role.
             */
            var CdkCell = /** @class */ (function (_super) {
                __extends(CdkCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function CdkCell(columnDef, elementRef) {
                    return _super.call(this, columnDef, elementRef) || this;
                }
                return CdkCell;
            }(BaseCdkCell));
            CdkCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-cell, td[cdk-cell]',
                            host: {
                                'class': 'cdk-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkCell.ctorParameters = function () { return [
                { type: CdkColumnDef },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The row template that can be used by the mat-table. Should not be used outside of the
             * material library.
             * @type {?}
             */
            var CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";
            /**
             * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
             * for changes and notifying the table.
             * @abstract
             */
            var BaseRowDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function BaseRowDef(template, _differs) {
                    this.template = template;
                    this._differs = _differs;
                }
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                BaseRowDef.prototype.ngOnChanges = function (changes) {
                    // Create a new columns differ if one does not yet exist. Initialize it based on initial value
                    // of the columns property or an empty array if none is provided.
                    if (!this._columnsDiffer) {
                        /** @type {?} */
                        var columns = (changes['columns'] && changes['columns'].currentValue) || [];
                        this._columnsDiffer = this._differs.find(columns).create();
                        this._columnsDiffer.diff(columns);
                    }
                };
                /**
                 * Returns the difference between the current columns and the columns from the last diff, or null
                 * if there is no difference.
                 * @return {?}
                 */
                BaseRowDef.prototype.getColumnsDiff = function () {
                    return this._columnsDiffer.diff(this.columns);
                };
                /**
                 * Gets this row def's relevant cell template from the provided column def.
                 * @param {?} column
                 * @return {?}
                 */
                BaseRowDef.prototype.extractCellTemplate = function (column) {
                    if (this instanceof CdkHeaderRowDef) {
                        return column.headerCell.template;
                    }
                    if (this instanceof CdkFooterRowDef) {
                        return column.footerCell.template;
                    }
                    else {
                        return column.cell.template;
                    }
                };
                return BaseRowDef;
            }());
            // Boilerplate for applying mixins to CdkHeaderRowDef.
            /**
             * \@docs-private
             */
            var CdkHeaderRowDefBase = /** @class */ (function (_super) {
                __extends(CdkHeaderRowDefBase, _super);
                function CdkHeaderRowDefBase() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return CdkHeaderRowDefBase;
            }(BaseRowDef));
            /** @type {?} */
            var _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);
            /**
             * Header row definition for the CDK table.
             * Captures the header row's template and other header properties such as the columns to display.
             */
            var CdkHeaderRowDef = /** @class */ (function (_super) {
                __extends(CdkHeaderRowDef, _super);
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function CdkHeaderRowDef(template, _differs) {
                    return _super.call(this, template, _differs) || this;
                }
                // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
                // Explicitly define it so that the method is called as part of the Angular lifecycle.
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkHeaderRowDef.prototype.ngOnChanges = function (changes) {
                    _super.prototype.ngOnChanges.call(this, changes);
                };
                return CdkHeaderRowDef;
            }(_CdkHeaderRowDefBase));
            CdkHeaderRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkHeaderRowDef]',
                            inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky'],
                        },] },
            ];
            /** @nocollapse */
            CdkHeaderRowDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
            ]; };
            // Boilerplate for applying mixins to CdkFooterRowDef.
            /**
             * \@docs-private
             */
            var CdkFooterRowDefBase = /** @class */ (function (_super) {
                __extends(CdkFooterRowDefBase, _super);
                function CdkFooterRowDefBase() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return CdkFooterRowDefBase;
            }(BaseRowDef));
            /** @type {?} */
            var _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);
            /**
             * Footer row definition for the CDK table.
             * Captures the footer row's template and other footer properties such as the columns to display.
             */
            var CdkFooterRowDef = /** @class */ (function (_super) {
                __extends(CdkFooterRowDef, _super);
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function CdkFooterRowDef(template, _differs) {
                    return _super.call(this, template, _differs) || this;
                }
                // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
                // Explicitly define it so that the method is called as part of the Angular lifecycle.
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkFooterRowDef.prototype.ngOnChanges = function (changes) {
                    _super.prototype.ngOnChanges.call(this, changes);
                };
                return CdkFooterRowDef;
            }(_CdkFooterRowDefBase));
            CdkFooterRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkFooterRowDef]',
                            inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky'],
                        },] },
            ];
            /** @nocollapse */
            CdkFooterRowDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
            ]; };
            /**
             * Data row definition for the CDK table.
             * Captures the header row's template and other row properties such as the columns to display and
             * a when predicate that describes when this row should be used.
             * @template T
             */
            var CdkRowDef = /** @class */ (function (_super) {
                __extends(CdkRowDef, _super);
                // TODO(andrewseguin): Add an input for providing a switch function to determine
                //   if this template should be used.
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function CdkRowDef(template, _differs) {
                    return _super.call(this, template, _differs) || this;
                }
                return CdkRowDef;
            }(BaseRowDef));
            CdkRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkRowDef]',
                            inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen'],
                        },] },
            ];
            /** @nocollapse */
            CdkRowDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
            ]; };
            /**
             * Outlet for rendering cells inside of a row or header row.
             * \@docs-private
             */
            var CdkCellOutlet = /** @class */ (function () {
                /**
                 * @param {?} _viewContainer
                 */
                function CdkCellOutlet(_viewContainer) {
                    this._viewContainer = _viewContainer;
                    CdkCellOutlet.mostRecentCellOutlet = this;
                }
                /**
                 * @return {?}
                 */
                CdkCellOutlet.prototype.ngOnDestroy = function () {
                    // If this was the last outlet being rendered in the view, remove the reference
                    // from the static property after it has been destroyed to avoid leaking memory.
                    if (CdkCellOutlet.mostRecentCellOutlet === this) {
                        CdkCellOutlet.mostRecentCellOutlet = null;
                    }
                };
                return CdkCellOutlet;
            }());
            /**
             * Static property containing the latest constructed instance of this class.
             * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
             * createEmbeddedView. After one of these components are created, this property will provide
             * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
             * construct the cells with the provided context.
             */
            CdkCellOutlet.mostRecentCellOutlet = null;
            CdkCellOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkCellOutlet]' },] },
            ];
            /** @nocollapse */
            CdkCellOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] }
            ]; };
            /**
             * Header template container that contains the cell outlet. Adds the right class and role.
             */
            var CdkHeaderRow = /** @class */ (function () {
                function CdkHeaderRow() {
                }
                return CdkHeaderRow;
            }());
            CdkHeaderRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-header-row, tr[cdk-header-row]',
                            template: CDK_ROW_TEMPLATE,
                            host: {
                                'class': 'cdk-header-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                        },] },
            ];
            /**
             * Footer template container that contains the cell outlet. Adds the right class and role.
             */
            var CdkFooterRow = /** @class */ (function () {
                function CdkFooterRow() {
                }
                return CdkFooterRow;
            }());
            CdkFooterRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-footer-row, tr[cdk-footer-row]',
                            template: CDK_ROW_TEMPLATE,
                            host: {
                                'class': 'cdk-footer-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                        },] },
            ];
            /**
             * Data row template container that contains the cell outlet. Adds the right class and role.
             */
            var CdkRow = /** @class */ (function () {
                function CdkRow() {
                }
                return CdkRow;
            }());
            CdkRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-row, tr[cdk-row]',
                            template: CDK_ROW_TEMPLATE,
                            host: {
                                'class': 'cdk-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * List of all possible directions that can be used for sticky positioning.
             * \@docs-private
             * @type {?}
             */
            var STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];
            /**
             * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
             * \@docs-private
             */
            var StickyStyler = /** @class */ (function () {
                /**
                 * @param {?} _isNativeHtmlTable Whether the sticky logic should be based on a table
                 *     that uses the native `<table>` element.
                 * @param {?} _stickCellCss The CSS class that will be applied to every row/cell that has
                 *     sticky positioning applied.
                 * @param {?} direction The directionality context of the table (ltr/rtl); affects column positioning
                 *     by reversing left/right positions.
                 * @param {?=} _isBrowser Whether the table is currently being rendered on the server or the client.
                 */
                function StickyStyler(_isNativeHtmlTable, _stickCellCss, direction, _isBrowser) {
                    if (_isBrowser === void 0) { _isBrowser = true; }
                    this._isNativeHtmlTable = _isNativeHtmlTable;
                    this._stickCellCss = _stickCellCss;
                    this.direction = direction;
                    this._isBrowser = _isBrowser;
                }
                /**
                 * Clears the sticky positioning styles from the row and its cells by resetting the `position`
                 * style, setting the zIndex to 0, and unsetting each provided sticky direction.
                 * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
                 * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
                 * @return {?}
                 */
                StickyStyler.prototype.clearStickyPositioning = function (rows, stickyDirections) {
                    for (var _a = 0, rows_1 = rows; _a < rows_1.length; _a++) {
                        var row = rows_1[_a];
                        // If the row isn't an element (e.g. if it's an `ng-container`),
                        // it won't have inline styles or `children` so we skip it.
                        if (row.nodeType !== row.ELEMENT_NODE) {
                            continue;
                        }
                        this._removeStickyStyle(row, stickyDirections);
                        for (var i = 0; i < row.children.length; i++) {
                            /** @type {?} */
                            var cell = ( /** @type {?} */(row.children[i]));
                            this._removeStickyStyle(cell, stickyDirections);
                        }
                    }
                };
                /**
                 * Applies sticky left and right positions to the cells of each row according to the sticky
                 * states of the rendered column definitions.
                 * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
                 * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
                 *     in this index position should be stuck to the start of the row.
                 * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
                 *     in this index position should be stuck to the end of the row.
                 * @return {?}
                 */
                StickyStyler.prototype.updateStickyColumns = function (rows, stickyStartStates, stickyEndStates) {
                    /** @type {?} */
                    var hasStickyColumns = stickyStartStates.some(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state) { return state; })) || stickyEndStates.some(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state) { return state; }));
                    if (!rows.length || !hasStickyColumns || !this._isBrowser) {
                        return;
                    }
                    /** @type {?} */
                    var firstRow = rows[0];
                    /** @type {?} */
                    var numCells = firstRow.children.length;
                    /** @type {?} */
                    var cellWidths = this._getCellWidths(firstRow);
                    /** @type {?} */
                    var startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
                    /** @type {?} */
                    var endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
                    /** @type {?} */
                    var isRtl = this.direction === 'rtl';
                    for (var _a = 0, rows_2 = rows; _a < rows_2.length; _a++) {
                        var row = rows_2[_a];
                        for (var i = 0; i < numCells; i++) {
                            /** @type {?} */
                            var cell = ( /** @type {?} */(row.children[i]));
                            if (stickyStartStates[i]) {
                                this._addStickyStyle(cell, isRtl ? 'right' : 'left', startPositions[i]);
                            }
                            if (stickyEndStates[i]) {
                                this._addStickyStyle(cell, isRtl ? 'left' : 'right', endPositions[i]);
                            }
                        }
                    }
                };
                /**
                 * Applies sticky positioning to the row's cells if using the native table layout, and to the
                 * row itself otherwise.
                 * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
                 *     sticky state and to the provided top or bottom position.
                 * @param {?} stickyStates A list of boolean states where each state represents whether the row
                 *     should be stuck in the particular top or bottom position.
                 * @param {?} position The position direction in which the row should be stuck if that row should be
                 *     sticky.
                 *
                 * @return {?}
                 */
                StickyStyler.prototype.stickRows = function (rowsToStick, stickyStates, position) {
                    // Since we can't measure the rows on the server, we can't stick the rows properly.
                    if (!this._isBrowser) {
                        return;
                    }
                    // If positioning the rows to the bottom, reverse their order when evaluating the sticky
                    // position such that the last row stuck will be "bottom: 0px" and so on.
                    /** @type {?} */
                    var rows = position === 'bottom' ? rowsToStick.reverse() : rowsToStick;
                    /** @type {?} */
                    var stickyHeight = 0;
                    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                        if (!stickyStates[rowIndex]) {
                            continue;
                        }
                        /** @type {?} */
                        var row = rows[rowIndex];
                        if (this._isNativeHtmlTable) {
                            for (var j = 0; j < row.children.length; j++) {
                                /** @type {?} */
                                var cell = ( /** @type {?} */(row.children[j]));
                                this._addStickyStyle(cell, position, stickyHeight);
                            }
                        }
                        else {
                            // Flex does not respect the stick positioning on the cells, needs to be applied to the row.
                            // If this is applied on a native table, Safari causes the header to fly in wrong direction.
                            this._addStickyStyle(row, position, stickyHeight);
                        }
                        if (rowIndex === rows.length - 1) {
                            // prevent unnecessary reflow from getBoundingClientRect()
                            return;
                        }
                        stickyHeight += row.getBoundingClientRect().height;
                    }
                };
                /**
                 * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
                 * footer rows is to apply sticky styling to the tfoot container. This should only be done if
                 * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
                 * the tfoot element.
                 * @param {?} tableElement
                 * @param {?} stickyStates
                 * @return {?}
                 */
                StickyStyler.prototype.updateStickyFooterContainer = function (tableElement, stickyStates) {
                    if (!this._isNativeHtmlTable) {
                        return;
                    }
                    /** @type {?} */
                    var tfoot = ( /** @type {?} */(tableElement.querySelector('tfoot')));
                    if (stickyStates.some(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state) { return !state; }))) {
                        this._removeStickyStyle(tfoot, ['bottom']);
                    }
                    else {
                        this._addStickyStyle(tfoot, 'bottom', 0);
                    }
                };
                /**
                 * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
                 * the zIndex, removing each of the provided sticky directions, and removing the
                 * sticky position if there are no more directions.
                 * @param {?} element
                 * @param {?} stickyDirections
                 * @return {?}
                 */
                StickyStyler.prototype._removeStickyStyle = function (element, stickyDirections) {
                    for (var _a = 0, stickyDirections_1 = stickyDirections; _a < stickyDirections_1.length; _a++) {
                        var dir = stickyDirections_1[_a];
                        element.style[dir] = '';
                    }
                    element.style.zIndex = this._getCalculatedZIndex(element);
                    // If the element no longer has any more sticky directions, remove sticky positioning and
                    // the sticky CSS class.
                    /** @type {?} */
                    var hasDirection = STICKY_DIRECTIONS.some(( /**
                     * @param {?} dir
                     * @return {?}
                     */function (/**
                     * @param {?} dir
                     * @return {?}
                     */ dir) { return !!element.style[dir]; }));
                    if (!hasDirection) {
                        element.style.position = '';
                        element.classList.remove(this._stickCellCss);
                    }
                };
                /**
                 * Adds the sticky styling to the element by adding the sticky style class, changing position
                 * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
                 * direction and value.
                 * @param {?} element
                 * @param {?} dir
                 * @param {?} dirValue
                 * @return {?}
                 */
                StickyStyler.prototype._addStickyStyle = function (element, dir, dirValue) {
                    element.classList.add(this._stickCellCss);
                    element.style[dir] = dirValue + "px";
                    element.style.cssText += 'position: -webkit-sticky; position: sticky; ';
                    element.style.zIndex = this._getCalculatedZIndex(element);
                };
                /**
                 * Calculate what the z-index should be for the element, depending on what directions (top,
                 * bottom, left, right) have been set. It should be true that elements with a top direction
                 * should have the highest index since these are elements like a table header. If any of those
                 * elements are also sticky in another direction, then they should appear above other elements
                 * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
                 * (e.g. footer rows) should then be next in the ordering such that they are below the header
                 * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
                 * should minimally increment so that they are above non-sticky elements but below top and bottom
                 * elements.
                 * @param {?} element
                 * @return {?}
                 */
                StickyStyler.prototype._getCalculatedZIndex = function (element) {
                    /** @type {?} */
                    var zIndexIncrements = {
                        top: 100,
                        bottom: 10,
                        left: 1,
                        right: 1,
                    };
                    /** @type {?} */
                    var zIndex = 0;
                    for (var _a = 0, STICKY_DIRECTIONS_1 = STICKY_DIRECTIONS; _a < STICKY_DIRECTIONS_1.length; _a++) {
                        var dir = STICKY_DIRECTIONS_1[_a];
                        if (element.style[dir]) {
                            zIndex += zIndexIncrements[dir];
                        }
                    }
                    return zIndex ? "" + zIndex : '';
                };
                /**
                 * Gets the widths for each cell in the provided row.
                 * @param {?} row
                 * @return {?}
                 */
                StickyStyler.prototype._getCellWidths = function (row) {
                    /** @type {?} */
                    var cellWidths = [];
                    /** @type {?} */
                    var firstRowCells = row.children;
                    for (var i = 0; i < firstRowCells.length; i++) {
                        /** @type {?} */
                        var cell = ( /** @type {?} */(firstRowCells[i]));
                        cellWidths.push(cell.getBoundingClientRect().width);
                    }
                    return cellWidths;
                };
                /**
                 * Determines the left and right positions of each sticky column cell, which will be the
                 * accumulation of all sticky column cell widths to the left and right, respectively.
                 * Non-sticky cells do not need to have a value set since their positions will not be applied.
                 * @param {?} widths
                 * @param {?} stickyStates
                 * @return {?}
                 */
                StickyStyler.prototype._getStickyStartColumnPositions = function (widths, stickyStates) {
                    /** @type {?} */
                    var positions = [];
                    /** @type {?} */
                    var nextPosition = 0;
                    for (var i = 0; i < widths.length; i++) {
                        if (stickyStates[i]) {
                            positions[i] = nextPosition;
                            nextPosition += widths[i];
                        }
                    }
                    return positions;
                };
                /**
                 * Determines the left and right positions of each sticky column cell, which will be the
                 * accumulation of all sticky column cell widths to the left and right, respectively.
                 * Non-sticky cells do not need to have a value set since their positions will not be applied.
                 * @param {?} widths
                 * @param {?} stickyStates
                 * @return {?}
                 */
                StickyStyler.prototype._getStickyEndColumnPositions = function (widths, stickyStates) {
                    /** @type {?} */
                    var positions = [];
                    /** @type {?} */
                    var nextPosition = 0;
                    for (var i = widths.length; i > 0; i--) {
                        if (stickyStates[i]) {
                            positions[i] = nextPosition;
                            nextPosition += widths[i];
                        }
                    }
                    return positions;
                };
                return StickyStyler;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Returns an error to be thrown when attempting to find an unexisting column.
             * \@docs-private
             * @param {?} id Id whose lookup failed.
             * @return {?}
             */
            function getTableUnknownColumnError(id) {
                return Error("Could not find column with id \"" + id + "\".");
            }
            /**
             * Returns an error to be thrown when two column definitions have the same name.
             * \@docs-private
             * @param {?} name
             * @return {?}
             */
            function getTableDuplicateColumnNameError(name) {
                return Error("Duplicate column definition name provided: \"" + name + "\".");
            }
            /**
             * Returns an error to be thrown when there are multiple rows that are missing a when function.
             * \@docs-private
             * @return {?}
             */
            function getTableMultipleDefaultRowDefsError() {
                return Error("There can only be one default row without a when predicate function.");
            }
            /**
             * Returns an error to be thrown when there are no matching row defs for a particular set of data.
             * \@docs-private
             * @param {?} data
             * @return {?}
             */
            function getTableMissingMatchingRowDefError(data) {
                return Error("Could not find a matching row definition for the" +
                    ("provided row data: " + JSON.stringify(data)));
            }
            /**
             * Returns an error to be thrown when there is no row definitions present in the content.
             * \@docs-private
             * @return {?}
             */
            function getTableMissingRowDefsError() {
                return Error('Missing definitions for header, footer, and row; ' +
                    'cannot determine which columns should be rendered.');
            }
            /**
             * Returns an error to be thrown when the data source does not match the compatible types.
             * \@docs-private
             * @return {?}
             */
            function getTableUnknownDataSourceError() {
                return Error("Provided data source did not match an array, Observable, or DataSource");
            }
            /**
             * Returns an error to be thrown when the text column cannot find a parent table to inject.
             * \@docs-private
             * @return {?}
             */
            function getTableTextColumnMissingParentTableError() {
                return Error("Text column could not find a parent table for registration.");
            }
            /**
             * Returns an error to be thrown when a table text column doesn't have a name.
             * \@docs-private
             * @return {?}
             */
            function getTableTextColumnMissingNameError() {
                return Error("Table text column must have a name.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Provides a handle for the table to grab the view container's ng-container to insert data rows.
             * \@docs-private
             */
            var DataRowOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?} elementRef
                 */
                function DataRowOutlet(viewContainer, elementRef) {
                    this.viewContainer = viewContainer;
                    this.elementRef = elementRef;
                }
                return DataRowOutlet;
            }());
            DataRowOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[rowOutlet]' },] },
            ];
            /** @nocollapse */
            DataRowOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Provides a handle for the table to grab the view container's ng-container to insert the header.
             * \@docs-private
             */
            var HeaderRowOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?} elementRef
                 */
                function HeaderRowOutlet(viewContainer, elementRef) {
                    this.viewContainer = viewContainer;
                    this.elementRef = elementRef;
                }
                return HeaderRowOutlet;
            }());
            HeaderRowOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[headerRowOutlet]' },] },
            ];
            /** @nocollapse */
            HeaderRowOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Provides a handle for the table to grab the view container's ng-container to insert the footer.
             * \@docs-private
             */
            var FooterRowOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?} elementRef
                 */
                function FooterRowOutlet(viewContainer, elementRef) {
                    this.viewContainer = viewContainer;
                    this.elementRef = elementRef;
                }
                return FooterRowOutlet;
            }());
            FooterRowOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[footerRowOutlet]' },] },
            ];
            /** @nocollapse */
            FooterRowOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * The table template that can be used by the mat-table. Should not be used outside of the
             * material library.
             * \@docs-private
             * @type {?}
             */
            var CDK_TABLE_TEMPLATE = 
            // Note that according to MDN, the `caption` element has to be projected as the **first**
            // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
            "\n  <ng-content select=\"caption\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n";
            /**
             * A data table that can render a header row, data rows, and a footer row.
             * Uses the dataSource input to determine the data to be rendered. The data can be provided either
             * as a data array, an Observable stream that emits the data array to render, or a DataSource with a
             * connect function that will return an Observable stream that emits the data array to render.
             * @template T
             */
            var CdkTable = /** @class */ (function () {
                /**
                 * @param {?} _differs
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} role
                 * @param {?} _dir
                 * @param {?} _document
                 * @param {?} _platform
                 */
                function CdkTable(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform) {
                    this._differs = _differs;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._elementRef = _elementRef;
                    this._dir = _dir;
                    this._platform = _platform;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    this._onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Map of all the user's defined columns (header, data, and footer cell template) identified by
                     * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
                     * any custom column definitions added to `_customColumnDefs`.
                     */
                    this._columnDefsByName = new Map();
                    /**
                     * Column definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has
                     * column definitions as *its* content child.
                     */
                    this._customColumnDefs = new Set();
                    /**
                     * Data row definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has
                     * built-in data rows as *its* content child.
                     */
                    this._customRowDefs = new Set();
                    /**
                     * Header row definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has
                     * built-in header rows as *its* content child.
                     */
                    this._customHeaderRowDefs = new Set();
                    /**
                     * Footer row definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
                     * built-in footer row as *its* content child.
                     */
                    this._customFooterRowDefs = new Set();
                    /**
                     * Whether the header row definition has been changed. Triggers an update to the header row after
                     * content is checked. Initialized as true so that the table renders the initial set of rows.
                     */
                    this._headerRowDefChanged = true;
                    /**
                     * Whether the footer row definition has been changed. Triggers an update to the footer row after
                     * content is checked. Initialized as true so that the table renders the initial set of rows.
                     */
                    this._footerRowDefChanged = true;
                    /**
                     * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
                     * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
                     * the cached `RenderRow` objects when possible, the row identity is preserved when the data
                     * and row template matches, which allows the `IterableDiffer` to check rows by reference
                     * and understand which rows are added/moved/removed.
                     *
                     * Implemented as a map of maps where the first key is the `data: T` object and the second is the
                     * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
                     * contains an array of created pairs. The array is necessary to handle cases where the data
                     * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
                     * stored.
                     */
                    this._cachedRenderRowsMap = new Map();
                    /**
                     * CSS class added to any row or cell that has sticky positioning applied. May be overriden by
                     * table subclasses.
                     */
                    this.stickyCssClass = 'cdk-table-sticky';
                    this._multiTemplateDataRows = false;
                    // TODO(andrewseguin): Remove max value as the end index
                    //   and instead calculate the view on init and scroll.
                    /**
                     * Stream containing the latest information on what rows are being displayed on screen.
                     * Can be used by the data source to as a heuristic of what data should be provided.
                     *
                     * \@docs-private
                     */
                    this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"]({ start: 0, end: Number.MAX_VALUE });
                    if (!role) {
                        this._elementRef.nativeElement.setAttribute('role', 'grid');
                    }
                    this._document = _document;
                    this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';
                }
                Object.defineProperty(CdkTable.prototype, "trackBy", {
                    /**
                     * Tracking function that will be used to check the differences in data changes. Used similarly
                     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
                     * relative to the function to know if a row should be added/removed/moved.
                     * Accepts a function that takes two parameters, `index` and `item`.
                     * @return {?}
                     */
                    get: function () {
                        return this._trackByFn;
                    },
                    /**
                     * @param {?} fn
                     * @return {?}
                     */
                    set: function (fn) {
                        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && fn != null && typeof fn !== 'function' && ( /** @type {?} */(console)) &&
                            ( /** @type {?} */(console.warn))) {
                            console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ".");
                        }
                        this._trackByFn = fn;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTable.prototype, "dataSource", {
                    /**
                     * The table's source of data, which can be provided in three ways (in order of complexity):
                     *   - Simple data array (each object represents one table row)
                     *   - Stream that emits a data array each time the array changes
                     *   - `DataSource` object that implements the connect/disconnect interface.
                     *
                     * If a data array is provided, the table must be notified when the array's objects are
                     * added, removed, or moved. This can be done by calling the `renderRows()` function which will
                     * render the diff since the last table render. If the data array reference is changed, the table
                     * will automatically trigger an update to the rows.
                     *
                     * When providing an Observable stream, the table will trigger an update automatically when the
                     * stream emits a new array of data.
                     *
                     * Finally, when providing a `DataSource` object, the table will use the Observable stream
                     * provided by the connect function and trigger updates when that stream emits new data array
                     * values. During the table's ngOnDestroy or when the data source is removed from the table, the
                     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
                     * subscriptions registered during the connect process).
                     * @return {?}
                     */
                    get: function () {
                        return this._dataSource;
                    },
                    /**
                     * @param {?} dataSource
                     * @return {?}
                     */
                    set: function (dataSource) {
                        if (this._dataSource !== dataSource) {
                            this._switchDataSource(dataSource);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTable.prototype, "multiTemplateDataRows", {
                    /**
                     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
                     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
                     * dataobject will render the first row that evaluates its when predicate to true, in the order
                     * defined in the table, or otherwise the default row which does not have a when predicate.
                     * @return {?}
                     */
                    get: function () {
                        return this._multiTemplateDataRows;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._multiTemplateDataRows = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
                        // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),
                        // this setter will be invoked before the row outlet has been defined hence the null check.
                        if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
                            this._forceRenderDataRows();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTable.prototype.ngOnInit = function () {
                    var _this = this;
                    this._setupStickyStyler();
                    if (this._isNativeHtmlTable) {
                        this._applyNativeTableSections();
                    }
                    // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If
                    // the user has provided a custom trackBy, return the result of that function as evaluated
                    // with the values of the `RenderRow`'s data and index.
                    this._dataDiffer = this._differs.find([]).create(( /**
                     * @param {?} _i
                     * @param {?} dataRow
                     * @return {?}
                     */function (_i, dataRow) {
                        return _this.trackBy ? _this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
                    }));
                };
                /**
                 * @return {?}
                 */
                CdkTable.prototype.ngAfterContentChecked = function () {
                    // Cache the row and column definitions gathered by ContentChildren and programmatic injection.
                    this._cacheRowDefs();
                    this._cacheColumnDefs();
                    // Make sure that the user has at least added header, footer, or data row def.
                    if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) {
                        throw getTableMissingRowDefsError();
                    }
                    // Render updates if the list of columns have been changed for the header, row, or footer defs.
                    this._renderUpdatedColumns();
                    // If the header row definition has been changed, trigger a render to the header row.
                    if (this._headerRowDefChanged) {
                        this._forceRenderHeaderRows();
                        this._headerRowDefChanged = false;
                    }
                    // If the footer row definition has been changed, trigger a render to the footer row.
                    if (this._footerRowDefChanged) {
                        this._forceRenderFooterRows();
                        this._footerRowDefChanged = false;
                    }
                    // If there is a data source and row definitions, connect to the data source unless a
                    // connection has already been made.
                    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
                        this._observeRenderChanges();
                    }
                    this._checkStickyStates();
                };
                /**
                 * @return {?}
                 */
                CdkTable.prototype.ngOnDestroy = function () {
                    this._rowOutlet.viewContainer.clear();
                    this._headerRowOutlet.viewContainer.clear();
                    this._footerRowOutlet.viewContainer.clear();
                    this._cachedRenderRowsMap.clear();
                    this._onDestroy.next();
                    this._onDestroy.complete();
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
                        this.dataSource.disconnect(this);
                    }
                };
                /**
                 * Renders rows based on the table's latest set of data, which was either provided directly as an
                 * input or retrieved through an Observable stream (directly or from a DataSource).
                 * Checks for differences in the data since the last diff to perform only the necessary
                 * changes (add/remove/move rows).
                 *
                 * If the table's data source is a DataSource or Observable, this will be invoked automatically
                 * each time the provided Observable stream emits a new data array. Otherwise if your data is
                 * an array, this function will need to be called to render any changes.
                 * @return {?}
                 */
                CdkTable.prototype.renderRows = function () {
                    var _this = this;
                    this._renderRows = this._getAllRenderRows();
                    /** @type {?} */
                    var changes = this._dataDiffer.diff(this._renderRows);
                    if (!changes) {
                        return;
                    }
                    /** @type {?} */
                    var viewContainer = this._rowOutlet.viewContainer;
                    changes.forEachOperation(( /**
                     * @param {?} record
                     * @param {?} prevIndex
                     * @param {?} currentIndex
                     * @return {?}
                     */function (record, prevIndex, currentIndex) {
                        if (record.previousIndex == null) {
                            _this._insertRow(record.item, ( /** @type {?} */(currentIndex)));
                        }
                        else if (currentIndex == null) {
                            viewContainer.remove(( /** @type {?} */(prevIndex)));
                        }
                        else {
                            /** @type {?} */
                            var view = ( /** @type {?} */(viewContainer.get(( /** @type {?} */(prevIndex)))));
                            viewContainer.move(( /** @type {?} */(view)), currentIndex);
                        }
                    }));
                    // Update the meta context of a row's context data (index, count, first, last, ...)
                    this._updateRowIndexContext();
                    // Update rows that did not get added/removed/moved but may have had their identity changed,
                    // e.g. if trackBy matched data on some property but the actual data reference changed.
                    changes.forEachIdentityChange(( /**
                     * @param {?} record
                     * @return {?}
                     */function (record) {
                        /** @type {?} */
                        var rowView = ( /** @type {?} */(viewContainer.get(( /** @type {?} */(record.currentIndex)))));
                        rowView.context.$implicit = record.item.data;
                    }));
                    this.updateStickyColumnStyles();
                };
                /**
                 * Sets the header row definition to be used. Overrides the header row definition gathered by
                 * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
                 * table's content is checked.
                 * \@docs-private
                 * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
                 * \@breaking-change 8.0.0
                 * @param {?} headerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.setHeaderRowDef = function (headerRowDef) {
                    this._customHeaderRowDefs = new Set([headerRowDef]);
                    this._headerRowDefChanged = true;
                };
                /**
                 * Sets the footer row definition to be used. Overrides the footer row definition gathered by
                 * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
                 * table's content is checked.
                 * \@docs-private
                 * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
                 * \@breaking-change 8.0.0
                 * @param {?} footerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.setFooterRowDef = function (footerRowDef) {
                    this._customFooterRowDefs = new Set([footerRowDef]);
                    this._footerRowDefChanged = true;
                };
                /**
                 * Adds a column definition that was not included as part of the content children.
                 * @param {?} columnDef
                 * @return {?}
                 */
                CdkTable.prototype.addColumnDef = function (columnDef) {
                    this._customColumnDefs.add(columnDef);
                };
                /**
                 * Removes a column definition that was not included as part of the content children.
                 * @param {?} columnDef
                 * @return {?}
                 */
                CdkTable.prototype.removeColumnDef = function (columnDef) {
                    this._customColumnDefs.delete(columnDef);
                };
                /**
                 * Adds a row definition that was not included as part of the content children.
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype.addRowDef = function (rowDef) {
                    this._customRowDefs.add(rowDef);
                };
                /**
                 * Removes a row definition that was not included as part of the content children.
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype.removeRowDef = function (rowDef) {
                    this._customRowDefs.delete(rowDef);
                };
                /**
                 * Adds a header row definition that was not included as part of the content children.
                 * @param {?} headerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.addHeaderRowDef = function (headerRowDef) {
                    this._customHeaderRowDefs.add(headerRowDef);
                    this._headerRowDefChanged = true;
                };
                /**
                 * Removes a header row definition that was not included as part of the content children.
                 * @param {?} headerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.removeHeaderRowDef = function (headerRowDef) {
                    this._customHeaderRowDefs.delete(headerRowDef);
                    this._headerRowDefChanged = true;
                };
                /**
                 * Adds a footer row definition that was not included as part of the content children.
                 * @param {?} footerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.addFooterRowDef = function (footerRowDef) {
                    this._customFooterRowDefs.add(footerRowDef);
                    this._footerRowDefChanged = true;
                };
                /**
                 * Removes a footer row definition that was not included as part of the content children.
                 * @param {?} footerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.removeFooterRowDef = function (footerRowDef) {
                    this._customFooterRowDefs.delete(footerRowDef);
                    this._footerRowDefChanged = true;
                };
                /**
                 * Updates the header sticky styles. First resets all applied styles with respect to the cells
                 * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
                 * automatically called when the header row changes its displayed set of columns, or if its
                 * sticky input changes. May be called manually for cases where the cell content changes outside
                 * of these events.
                 * @return {?}
                 */
                CdkTable.prototype.updateStickyHeaderRowStyles = function () {
                    /** @type {?} */
                    var headerRows = this._getRenderedRows(this._headerRowOutlet);
                    /** @type {?} */
                    var tableElement = ( /** @type {?} */(this._elementRef.nativeElement));
                    // Hide the thead element if there are no header rows. This is necessary to satisfy
                    // overzealous a11y checkers that fail because the `rowgroup` element does not contain
                    // required child `row`.
                    /** @type {?} */
                    var thead = tableElement.querySelector('thead');
                    if (thead) {
                        thead.style.display = headerRows.length ? '' : 'none';
                    }
                    /** @type {?} */
                    var stickyStates = this._headerRowDefs.map(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.sticky; }));
                    this._stickyStyler.clearStickyPositioning(headerRows, ['top']);
                    this._stickyStyler.stickRows(headerRows, stickyStates, 'top');
                    // Reset the dirty state of the sticky input change since it has been used.
                    this._headerRowDefs.forEach(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.resetStickyChanged(); }));
                };
                /**
                 * Updates the footer sticky styles. First resets all applied styles with respect to the cells
                 * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
                 * automatically called when the footer row changes its displayed set of columns, or if its
                 * sticky input changes. May be called manually for cases where the cell content changes outside
                 * of these events.
                 * @return {?}
                 */
                CdkTable.prototype.updateStickyFooterRowStyles = function () {
                    /** @type {?} */
                    var footerRows = this._getRenderedRows(this._footerRowOutlet);
                    /** @type {?} */
                    var tableElement = ( /** @type {?} */(this._elementRef.nativeElement));
                    // Hide the tfoot element if there are no footer rows. This is necessary to satisfy
                    // overzealous a11y checkers that fail because the `rowgroup` element does not contain
                    // required child `row`.
                    /** @type {?} */
                    var tfoot = tableElement.querySelector('tfoot');
                    if (tfoot) {
                        tfoot.style.display = footerRows.length ? '' : 'none';
                    }
                    /** @type {?} */
                    var stickyStates = this._footerRowDefs.map(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.sticky; }));
                    this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);
                    this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');
                    this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
                    // Reset the dirty state of the sticky input change since it has been used.
                    this._footerRowDefs.forEach(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.resetStickyChanged(); }));
                };
                /**
                 * Updates the column sticky styles. First resets all applied styles with respect to the cells
                 * sticking to the left and right. Then sticky styles are added for the left and right according
                 * to the column definitions for each cell in each row. This is automatically called when
                 * the data source provides a new set of data or when a column definition changes its sticky
                 * input. May be called manually for cases where the cell content changes outside of these events.
                 * @return {?}
                 */
                CdkTable.prototype.updateStickyColumnStyles = function () {
                    var _this = this;
                    /** @type {?} */
                    var headerRows = this._getRenderedRows(this._headerRowOutlet);
                    /** @type {?} */
                    var dataRows = this._getRenderedRows(this._rowOutlet);
                    /** @type {?} */
                    var footerRows = this._getRenderedRows(this._footerRowOutlet);
                    // Clear the left and right positioning from all columns in the table across all rows since
                    // sticky columns span across all table sections (header, data, footer)
                    this._stickyStyler.clearStickyPositioning(headerRows.concat(dataRows, footerRows), ['left', 'right']);
                    // Update the sticky styles for each header row depending on the def's sticky state
                    headerRows.forEach(( /**
                     * @param {?} headerRow
                     * @param {?} i
                     * @return {?}
                     */function (headerRow, i) {
                        _this._addStickyColumnStyles([headerRow], _this._headerRowDefs[i]);
                    }));
                    // Update the sticky styles for each data row depending on its def's sticky state
                    this._rowDefs.forEach(( /**
                     * @param {?} rowDef
                     * @return {?}
                     */function (/**
                     * @param {?} rowDef
                     * @return {?}
                     */ rowDef) {
                        // Collect all the rows rendered with this row definition.
                        /** @type {?} */
                        var rows = [];
                        for (var i = 0; i < dataRows.length; i++) {
                            if (_this._renderRows[i].rowDef === rowDef) {
                                rows.push(dataRows[i]);
                            }
                        }
                        _this._addStickyColumnStyles(rows, rowDef);
                    }));
                    // Update the sticky styles for each footer row depending on the def's sticky state
                    footerRows.forEach(( /**
                     * @param {?} footerRow
                     * @param {?} i
                     * @return {?}
                     */function (footerRow, i) {
                        _this._addStickyColumnStyles([footerRow], _this._footerRowDefs[i]);
                    }));
                    // Reset the dirty state of the sticky input change since it has been used.
                    Array.from(this._columnDefsByName.values()).forEach(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.resetStickyChanged(); }));
                };
                /**
                 * Get the list of RenderRow objects to render according to the current list of data and defined
                 * row definitions. If the previous list already contained a particular pair, it should be reused
                 * so that the differ equates their references.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._getAllRenderRows = function () {
                    /** @type {?} */
                    var renderRows = [];
                    // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the
                    // new cache while unused ones can be picked up by garbage collection.
                    /** @type {?} */
                    var prevCachedRenderRows = this._cachedRenderRowsMap;
                    this._cachedRenderRowsMap = new Map();
                    // For each data object, get the list of rows that should be rendered, represented by the
                    // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.
                    for (var i = 0; i < this._data.length; i++) {
                        /** @type {?} */
                        var data = this._data[i];
                        /** @type {?} */
                        var renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
                        if (!this._cachedRenderRowsMap.has(data)) {
                            this._cachedRenderRowsMap.set(data, new WeakMap());
                        }
                        for (var j = 0; j < renderRowsForData.length; j++) {
                            /** @type {?} */
                            var renderRow = renderRowsForData[j];
                            /** @type {?} */
                            var cache = ( /** @type {?} */(this._cachedRenderRowsMap.get(renderRow.data)));
                            if (cache.has(renderRow.rowDef)) {
                                ( /** @type {?} */(cache.get(renderRow.rowDef))).push(renderRow);
                            }
                            else {
                                cache.set(renderRow.rowDef, [renderRow]);
                            }
                            renderRows.push(renderRow);
                        }
                    }
                    return renderRows;
                };
                /**
                 * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
                 * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
                 * `(T, CdkRowDef)` pair.
                 * @private
                 * @param {?} data
                 * @param {?} dataIndex
                 * @param {?=} cache
                 * @return {?}
                 */
                CdkTable.prototype._getRenderRowsForData = function (data, dataIndex, cache) {
                    /** @type {?} */
                    var rowDefs = this._getRowDefs(data, dataIndex);
                    return rowDefs.map(( /**
                     * @param {?} rowDef
                     * @return {?}
                     */function (/**
                     * @param {?} rowDef
                     * @return {?}
                     */ rowDef) {
                        /** @type {?} */
                        var cachedRenderRows = (cache && cache.has(rowDef)) ? ( /** @type {?} */(cache.get(rowDef))) : [];
                        if (cachedRenderRows.length) {
                            /** @type {?} */
                            var dataRow = ( /** @type {?} */(cachedRenderRows.shift()));
                            dataRow.dataIndex = dataIndex;
                            return dataRow;
                        }
                        else {
                            return { data: data, rowDef: rowDef, dataIndex: dataIndex };
                        }
                    }));
                };
                /**
                 * Update the map containing the content's column definitions.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._cacheColumnDefs = function () {
                    var _this = this;
                    this._columnDefsByName.clear();
                    /** @type {?} */
                    var columnDefs = mergeQueryListAndSet(this._contentColumnDefs, this._customColumnDefs);
                    columnDefs.forEach(( /**
                     * @param {?} columnDef
                     * @return {?}
                     */function (/**
                     * @param {?} columnDef
                     * @return {?}
                     */ columnDef) {
                        if (_this._columnDefsByName.has(columnDef.name)) {
                            throw getTableDuplicateColumnNameError(columnDef.name);
                        }
                        _this._columnDefsByName.set(columnDef.name, columnDef);
                    }));
                };
                /**
                 * Update the list of all available row definitions that can be used.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._cacheRowDefs = function () {
                    this._headerRowDefs =
                        mergeQueryListAndSet(this._contentHeaderRowDefs, this._customHeaderRowDefs);
                    this._footerRowDefs =
                        mergeQueryListAndSet(this._contentFooterRowDefs, this._customFooterRowDefs);
                    this._rowDefs = mergeQueryListAndSet(this._contentRowDefs, this._customRowDefs);
                    // After all row definitions are determined, find the row definition to be considered default.
                    /** @type {?} */
                    var defaultRowDefs = this._rowDefs.filter(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return !def.when; }));
                    if (!this.multiTemplateDataRows && defaultRowDefs.length > 1) {
                        throw getTableMultipleDefaultRowDefsError();
                    }
                    this._defaultRowDef = defaultRowDefs[0];
                };
                /**
                 * Check if the header, data, or footer rows have changed what columns they want to display or
                 * whether the sticky states have changed for the header or footer. If there is a diff, then
                 * re-render that section.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._renderUpdatedColumns = function () {
                    /** @type {?} */
                    var columnsDiffReducer = ( /**
                     * @param {?} acc
                     * @param {?} def
                     * @return {?}
                     */function (acc, def) { return acc || !!def.getColumnsDiff(); });
                    // Force re-render data rows if the list of column definitions have changed.
                    if (this._rowDefs.reduce(columnsDiffReducer, false)) {
                        this._forceRenderDataRows();
                    }
                    // Force re-render header/footer rows if the list of column definitions have changed..
                    if (this._headerRowDefs.reduce(columnsDiffReducer, false)) {
                        this._forceRenderHeaderRows();
                    }
                    if (this._footerRowDefs.reduce(columnsDiffReducer, false)) {
                        this._forceRenderFooterRows();
                    }
                };
                /**
                 * Switch to the provided data source by resetting the data and unsubscribing from the current
                 * render change subscription if one exists. If the data source is null, interpret this by
                 * clearing the row outlet. Otherwise start listening for new data.
                 * @private
                 * @param {?} dataSource
                 * @return {?}
                 */
                CdkTable.prototype._switchDataSource = function (dataSource) {
                    this._data = [];
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
                        this.dataSource.disconnect(this);
                    }
                    // Stop listening for data from the previous data source.
                    if (this._renderChangeSubscription) {
                        this._renderChangeSubscription.unsubscribe();
                        this._renderChangeSubscription = null;
                    }
                    if (!dataSource) {
                        if (this._dataDiffer) {
                            this._dataDiffer.diff([]);
                        }
                        this._rowOutlet.viewContainer.clear();
                    }
                    this._dataSource = dataSource;
                };
                /**
                 * Set up a subscription for the data provided by the data source.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._observeRenderChanges = function () {
                    var _this = this;
                    // If no data source has been set, there is nothing to observe for changes.
                    if (!this.dataSource) {
                        return;
                    }
                    /** @type {?} */
                    var dataStream;
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
                        dataStream = this.dataSource.connect(this);
                    }
                    else if (this.dataSource instanceof rxjs__WEBPACK_IMPORTED_MODULE_6__["Observable"]) {
                        dataStream = this.dataSource;
                    }
                    else if (Array.isArray(this.dataSource)) {
                        dataStream = Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])(this.dataSource);
                    }
                    if (dataStream === undefined) {
                        throw getTableUnknownDataSourceError();
                    }
                    this._renderChangeSubscription = dataStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._onDestroy)).subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (/**
                     * @param {?} data
                     * @return {?}
                     */ data) {
                        _this._data = data || [];
                        _this.renderRows();
                    }));
                };
                /**
                 * Clears any existing content in the header row outlet and creates a new embedded view
                 * in the outlet using the header row definition.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._forceRenderHeaderRows = function () {
                    var _this = this;
                    // Clear the header row outlet if any content exists.
                    if (this._headerRowOutlet.viewContainer.length > 0) {
                        this._headerRowOutlet.viewContainer.clear();
                    }
                    this._headerRowDefs.forEach(( /**
                     * @param {?} def
                     * @param {?} i
                     * @return {?}
                     */function (def, i) { return _this._renderRow(_this._headerRowOutlet, def, i); }));
                    this.updateStickyHeaderRowStyles();
                    this.updateStickyColumnStyles();
                };
                /**
                 * Clears any existing content in the footer row outlet and creates a new embedded view
                 * in the outlet using the footer row definition.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._forceRenderFooterRows = function () {
                    var _this = this;
                    // Clear the footer row outlet if any content exists.
                    if (this._footerRowOutlet.viewContainer.length > 0) {
                        this._footerRowOutlet.viewContainer.clear();
                    }
                    this._footerRowDefs.forEach(( /**
                     * @param {?} def
                     * @param {?} i
                     * @return {?}
                     */function (def, i) { return _this._renderRow(_this._footerRowOutlet, def, i); }));
                    this.updateStickyFooterRowStyles();
                    this.updateStickyColumnStyles();
                };
                /**
                 * Adds the sticky column styles for the rows according to the columns' stick states.
                 * @private
                 * @param {?} rows
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype._addStickyColumnStyles = function (rows, rowDef) {
                    var _this = this;
                    /** @type {?} */
                    var columnDefs = Array.from(rowDef.columns || []).map(( /**
                     * @param {?} columnName
                     * @return {?}
                     */function (/**
                     * @param {?} columnName
                     * @return {?}
                     */ columnName) {
                        /** @type {?} */
                        var columnDef = _this._columnDefsByName.get(columnName);
                        if (!columnDef) {
                            throw getTableUnknownColumnError(columnName);
                        }
                        return ( /** @type {?} */(columnDef));
                    }));
                    /** @type {?} */
                    var stickyStartStates = columnDefs.map(( /**
                     * @param {?} columnDef
                     * @return {?}
                     */function (/**
                     * @param {?} columnDef
                     * @return {?}
                     */ columnDef) { return columnDef.sticky; }));
                    /** @type {?} */
                    var stickyEndStates = columnDefs.map(( /**
                     * @param {?} columnDef
                     * @return {?}
                     */function (/**
                     * @param {?} columnDef
                     * @return {?}
                     */ columnDef) { return columnDef.stickyEnd; }));
                    this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates);
                };
                /**
                 * Gets the list of rows that have been rendered in the row outlet.
                 * @param {?} rowOutlet
                 * @return {?}
                 */
                CdkTable.prototype._getRenderedRows = function (rowOutlet) {
                    /** @type {?} */
                    var renderedRows = [];
                    for (var i = 0; i < rowOutlet.viewContainer.length; i++) {
                        /** @type {?} */
                        var viewRef = (( /** @type {?} */(( /** @type {?} */(rowOutlet.viewContainer.get(i))))));
                        renderedRows.push(viewRef.rootNodes[0]);
                    }
                    return renderedRows;
                };
                /**
                 * Get the matching row definitions that should be used for this row data. If there is only
                 * one row definition, it is returned. Otherwise, find the row definitions that has a when
                 * predicate that returns true with the data. If none return true, return the default row
                 * definition.
                 * @param {?} data
                 * @param {?} dataIndex
                 * @return {?}
                 */
                CdkTable.prototype._getRowDefs = function (data, dataIndex) {
                    if (this._rowDefs.length == 1) {
                        return [this._rowDefs[0]];
                    }
                    /** @type {?} */
                    var rowDefs = [];
                    if (this.multiTemplateDataRows) {
                        rowDefs = this._rowDefs.filter(( /**
                         * @param {?} def
                         * @return {?}
                         */function (/**
                         * @param {?} def
                         * @return {?}
                         */ def) { return !def.when || def.when(dataIndex, data); }));
                    }
                    else {
                        /** @type {?} */
                        var rowDef = this._rowDefs.find(( /**
                         * @param {?} def
                         * @return {?}
                         */function (/**
                         * @param {?} def
                         * @return {?}
                         */ def) { return def.when && def.when(dataIndex, data); })) || this._defaultRowDef;
                        if (rowDef) {
                            rowDefs.push(rowDef);
                        }
                    }
                    if (!rowDefs.length) {
                        throw getTableMissingMatchingRowDefError(data);
                    }
                    return rowDefs;
                };
                /**
                 * Create the embedded view for the data row template and place it in the correct index location
                 * within the data row view container.
                 * @private
                 * @param {?} renderRow
                 * @param {?} renderIndex
                 * @return {?}
                 */
                CdkTable.prototype._insertRow = function (renderRow, renderIndex) {
                    /** @type {?} */
                    var rowDef = renderRow.rowDef;
                    /** @type {?} */
                    var context = { $implicit: renderRow.data };
                    this._renderRow(this._rowOutlet, rowDef, renderIndex, context);
                };
                /**
                 * Creates a new row template in the outlet and fills it with the set of cell templates.
                 * Optionally takes a context to provide to the row and cells, as well as an optional index
                 * of where to place the new row template in the outlet.
                 * @private
                 * @param {?} outlet
                 * @param {?} rowDef
                 * @param {?} index
                 * @param {?=} context
                 * @return {?}
                 */
                CdkTable.prototype._renderRow = function (outlet, rowDef, index, context) {
                    if (context === void 0) { context = {}; }
                    // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView
                    outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
                    for (var _a = 0, _b = this._getCellTemplates(rowDef); _a < _b.length; _a++) {
                        var cellTemplate = _b[_a];
                        if (CdkCellOutlet.mostRecentCellOutlet) {
                            CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Updates the index-related context for each row to reflect any changes in the index of the rows,
                 * e.g. first/last/even/odd.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._updateRowIndexContext = function () {
                    /** @type {?} */
                    var viewContainer = this._rowOutlet.viewContainer;
                    for (var renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
                        /** @type {?} */
                        var viewRef = ( /** @type {?} */(viewContainer.get(renderIndex)));
                        /** @type {?} */
                        var context = ( /** @type {?} */(viewRef.context));
                        context.count = count;
                        context.first = renderIndex === 0;
                        context.last = renderIndex === count - 1;
                        context.even = renderIndex % 2 === 0;
                        context.odd = !context.even;
                        if (this.multiTemplateDataRows) {
                            context.dataIndex = this._renderRows[renderIndex].dataIndex;
                            context.renderIndex = renderIndex;
                        }
                        else {
                            context.index = this._renderRows[renderIndex].dataIndex;
                        }
                    }
                };
                /**
                 * Gets the column definitions for the provided row def.
                 * @private
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype._getCellTemplates = function (rowDef) {
                    var _this = this;
                    if (!rowDef || !rowDef.columns) {
                        return [];
                    }
                    return Array.from(rowDef.columns, ( /**
                     * @param {?} columnId
                     * @return {?}
                     */function (/**
                     * @param {?} columnId
                     * @return {?}
                     */ columnId) {
                        /** @type {?} */
                        var column = _this._columnDefsByName.get(columnId);
                        if (!column) {
                            throw getTableUnknownColumnError(columnId);
                        }
                        return rowDef.extractCellTemplate(column);
                    }));
                };
                /**
                 * Adds native table sections (e.g. tbody) and moves the row outlets into them.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._applyNativeTableSections = function () {
                    /** @type {?} */
                    var documentFragment = this._document.createDocumentFragment();
                    /** @type {?} */
                    var sections = [
                        { tag: 'thead', outlet: this._headerRowOutlet },
                        { tag: 'tbody', outlet: this._rowOutlet },
                        { tag: 'tfoot', outlet: this._footerRowOutlet },
                    ];
                    for (var _a = 0, sections_1 = sections; _a < sections_1.length; _a++) {
                        var section = sections_1[_a];
                        /** @type {?} */
                        var element = this._document.createElement(section.tag);
                        element.setAttribute('role', 'rowgroup');
                        element.appendChild(section.outlet.elementRef.nativeElement);
                        documentFragment.appendChild(element);
                    }
                    // Use a DocumentFragment so we don't hit the DOM on each iteration.
                    this._elementRef.nativeElement.appendChild(documentFragment);
                };
                /**
                 * Forces a re-render of the data rows. Should be called in cases where there has been an input
                 * change that affects the evaluation of which rows should be rendered, e.g. toggling
                 * `multiTemplateDataRows` or adding/removing row definitions.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._forceRenderDataRows = function () {
                    this._dataDiffer.diff([]);
                    this._rowOutlet.viewContainer.clear();
                    this.renderRows();
                    this.updateStickyColumnStyles();
                };
                /**
                 * Checks if there has been a change in sticky states since last check and applies the correct
                 * sticky styles. Since checking resets the "dirty" state, this should only be performed once
                 * during a change detection and after the inputs are settled (after content check).
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._checkStickyStates = function () {
                    /** @type {?} */
                    var stickyCheckReducer = ( /**
                     * @param {?} acc
                     * @param {?} d
                     * @return {?}
                     */function (acc, d) {
                        return acc || d.hasStickyChanged();
                    });
                    // Note that the check needs to occur for every definition since it notifies the definition
                    // that it can reset its dirty state. Using another operator like `some` may short-circuit
                    // remaining definitions and leave them in an unchecked state.
                    if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
                        this.updateStickyHeaderRowStyles();
                    }
                    if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
                        this.updateStickyFooterRowStyles();
                    }
                    if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
                        this.updateStickyColumnStyles();
                    }
                };
                /**
                 * Creates the sticky styler that will be used for sticky rows and columns. Listens
                 * for directionality changes and provides the latest direction to the styler. Re-applies column
                 * stickiness when directionality changes.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._setupStickyStyler = function () {
                    var _this = this;
                    /** @type {?} */
                    var direction = this._dir ? this._dir.value : 'ltr';
                    this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._platform.isBrowser);
                    (this._dir ? this._dir.change : Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])())
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._onDestroy))
                        .subscribe(( /**
                 * @param {?} value
                 * @return {?}
                 */function (/**
                 * @param {?} value
                 * @return {?}
                 */ value) {
                        _this._stickyStyler.direction = value;
                        _this.updateStickyColumnStyles();
                    }));
                };
                return CdkTable;
            }());
            CdkTable.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-table, table[cdk-table]',
                            exportAs: 'cdkTable',
                            template: CDK_TABLE_TEMPLATE,
                            host: {
                                'class': 'cdk-table',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // The "OnPush" status for the `MatTable` component is effectively a noop, so we are removing it.
                            // The view for `MatTable` consists entirely of templates declared in other views. As they are
                            // declared elsewhere, they are checked when their declaration points are checked.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /** @nocollapse */
            CdkTable.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"], args: ['role',] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"] }
            ]; };
            CdkTable.propDecorators = {
                trackBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                dataSource: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                multiTemplateDataRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                _rowOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [DataRowOutlet, { static: true },] }],
                _headerRowOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [HeaderRowOutlet, { static: true },] }],
                _footerRowOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [FooterRowOutlet, { static: true },] }],
                _contentColumnDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkColumnDef,] }],
                _contentRowDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkRowDef,] }],
                _contentHeaderRowDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkHeaderRowDef,] }],
                _contentFooterRowDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkFooterRowDef,] }]
            };
            /**
             * Utility function that gets a merged list of the entries in a QueryList and values of a Set.
             * @template T
             * @param {?} queryList
             * @param {?} set
             * @return {?}
             */
            function mergeQueryListAndSet(queryList, set) {
                return queryList.toArray().concat(Array.from(set));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify the text column options.
             * @type {?}
             */
            var TEXT_COLUMN_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('text-column-options');
            /**
             * Column that simply shows text content for the header and row cells. Assumes that the table
             * is using the native table implementation (`<table>`).
             *
             * By default, the name of this column will be the header text and data property accessor.
             * The header text can be overridden with the `headerText` input. Cell values can be overridden with
             * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
             * input.
             * @template T
             */
            var CdkTextColumn = /** @class */ (function () {
                /**
                 * @param {?} _table
                 * @param {?} _options
                 */
                function CdkTextColumn(_table, _options) {
                    this._table = _table;
                    this._options = _options;
                    /**
                     * Alignment of the cell values.
                     */
                    this.justify = 'start';
                    this._options = _options || {};
                }
                Object.defineProperty(CdkTextColumn.prototype, "name", {
                    /**
                     * Column name that should be used to reference this column.
                     * @return {?}
                     */
                    get: function () {
                        return this._name;
                    },
                    /**
                     * @param {?} name
                     * @return {?}
                     */
                    set: function (name) {
                        this._name = name;
                        // With Ivy, inputs can be initialized before static query results are
                        // available. In that case, we defer the synchronization until "ngOnInit" fires.
                        this._syncColumnDefName();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTextColumn.prototype.ngOnInit = function () {
                    this._syncColumnDefName();
                    if (this.headerText === undefined) {
                        this.headerText = this._createDefaultHeaderText();
                    }
                    if (!this.dataAccessor) {
                        this.dataAccessor =
                            this._options.defaultDataAccessor || (( /**
                             * @param {?} data
                             * @param {?} name
                             * @return {?}
                             */function (data, name) { return (( /** @type {?} */(data)))[name]; }));
                    }
                    if (this._table) {
                        // Provide the cell and headerCell directly to the table with the static `ViewChild` query,
                        // since the columnDef will not pick up its content by the time the table finishes checking
                        // its content and initializing the rows.
                        this.columnDef.cell = this.cell;
                        this.columnDef.headerCell = this.headerCell;
                        this._table.addColumnDef(this.columnDef);
                    }
                    else {
                        throw getTableTextColumnMissingParentTableError();
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTextColumn.prototype.ngOnDestroy = function () {
                    if (this._table) {
                        this._table.removeColumnDef(this.columnDef);
                    }
                };
                /**
                 * Creates a default header text. Use the options' header text transformation function if one
                 * has been provided. Otherwise simply capitalize the column name.
                 * @return {?}
                 */
                CdkTextColumn.prototype._createDefaultHeaderText = function () {
                    /** @type {?} */
                    var name = this.name;
                    if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && !name) {
                        throw getTableTextColumnMissingNameError();
                    }
                    if (this._options && this._options.defaultHeaderTextTransform) {
                        return this._options.defaultHeaderTextTransform(name);
                    }
                    return name[0].toUpperCase() + name.slice(1);
                };
                /**
                 * Synchronizes the column definition name with the text column name.
                 * @private
                 * @return {?}
                 */
                CdkTextColumn.prototype._syncColumnDefName = function () {
                    if (this.columnDef) {
                        this.columnDef.name = this.name;
                    }
                };
                return CdkTextColumn;
            }());
            CdkTextColumn.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-text-column',
                            template: "\n    <ng-container cdkColumnDef>\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  ",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // Change detection is intentionally not set to OnPush. This component's template will be provided
                            // to the table to be inserted into its view. This is problematic when change detection runs since
                            // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
                            // mean's the template in the table's view will not have the updated value (and in fact will cause
                            // an ExpressionChangedAfterItHasBeenCheckedError).
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /** @nocollapse */
            CdkTextColumn.ctorParameters = function () { return [
                { type: CdkTable, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [TEXT_COLUMN_OPTIONS,] }] }
            ]; };
            CdkTextColumn.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                headerText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                dataAccessor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                justify: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                columnDef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [CdkColumnDef, { static: true },] }],
                cell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [CdkCellDef, { static: true },] }],
                headerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [CdkHeaderCellDef, { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var EXPORTED_DECLARATIONS = [
                CdkTable,
                CdkRowDef,
                CdkCellDef,
                CdkCellOutlet,
                CdkHeaderCellDef,
                CdkFooterCellDef,
                CdkColumnDef,
                CdkCell,
                CdkRow,
                CdkHeaderCell,
                CdkFooterCell,
                CdkHeaderRow,
                CdkHeaderRowDef,
                CdkFooterRow,
                CdkFooterRowDef,
                DataRowOutlet,
                HeaderRowOutlet,
                FooterRowOutlet,
                CdkTextColumn,
            ];
            var CdkTableModule = /** @class */ (function () {
                function CdkTableModule() {
                }
                return CdkTableModule;
            }());
            CdkTableModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: EXPORTED_DECLARATIONS,
                            declarations: EXPORTED_DECLARATIONS
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=table.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/text-field.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/text-field.js ***!
          \*********************************************************/
        /*! exports provided: AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutofillMonitor", function () { return AutofillMonitor; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAutofill", function () { return CdkAutofill; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTextareaAutosize", function () { return CdkTextareaAutosize; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextFieldModule", function () { return TextFieldModule; });
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Options to pass to the animationstart listener.
             * @type {?}
             */
            var listenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["normalizePassiveListenerOptions"])({ passive: true });
            /**
             * An injectable service that can be used to monitor the autofill state of an input.
             * Based on the following blog post:
             * https://medium.com/\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7
             */
            var AutofillMonitor = /** @class */ (function () {
                /**
                 * @param {?} _platform
                 * @param {?} _ngZone
                 */
                function AutofillMonitor(_platform, _ngZone) {
                    this._platform = _platform;
                    this._ngZone = _ngZone;
                    this._monitoredElements = new Map();
                }
                /**
                 * @param {?} elementOrRef
                 * @return {?}
                 */
                AutofillMonitor.prototype.monitor = function (elementOrRef) {
                    var _this = this;
                    if (!this._platform.isBrowser) {
                        return rxjs__WEBPACK_IMPORTED_MODULE_3__["EMPTY"];
                    }
                    /** @type {?} */
                    var element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceElement"])(elementOrRef);
                    /** @type {?} */
                    var info = this._monitoredElements.get(element);
                    if (info) {
                        return info.subject.asObservable();
                    }
                    /** @type {?} */
                    var result = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /** @type {?} */
                    var cssClass = 'cdk-text-field-autofilled';
                    /** @type {?} */
                    var listener = ( /** @type {?} */((( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        // Animation events fire on initial element render, we check for the presence of the autofill
                        // CSS class to make sure this is a real change in state, not just the initial render before
                        // we fire off events.
                        if (event.animationName === 'cdk-text-field-autofill-start' &&
                            !element.classList.contains(cssClass)) {
                            element.classList.add(cssClass);
                            _this._ngZone.run(( /**
                             * @return {?}
                             */function () { return result.next({ target: ( /** @type {?} */(event.target)), isAutofilled: true }); }));
                        }
                        else if (event.animationName === 'cdk-text-field-autofill-end' &&
                            element.classList.contains(cssClass)) {
                            element.classList.remove(cssClass);
                            _this._ngZone.run(( /**
                             * @return {?}
                             */function () { return result.next({ target: ( /** @type {?} */(event.target)), isAutofilled: false }); }));
                        }
                    }))));
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        element.addEventListener('animationstart', listener, listenerOptions);
                        element.classList.add('cdk-text-field-autofill-monitored');
                    }));
                    this._monitoredElements.set(element, {
                        subject: result,
                        unlisten: ( /**
                         * @return {?}
                         */function () {
                            element.removeEventListener('animationstart', listener, listenerOptions);
                        })
                    });
                    return result.asObservable();
                };
                /**
                 * @param {?} elementOrRef
                 * @return {?}
                 */
                AutofillMonitor.prototype.stopMonitoring = function (elementOrRef) {
                    /** @type {?} */
                    var element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceElement"])(elementOrRef);
                    /** @type {?} */
                    var info = this._monitoredElements.get(element);
                    if (info) {
                        info.unlisten();
                        info.subject.complete();
                        element.classList.remove('cdk-text-field-autofill-monitored');
                        element.classList.remove('cdk-text-field-autofilled');
                        this._monitoredElements.delete(element);
                    }
                };
                /**
                 * @return {?}
                 */
                AutofillMonitor.prototype.ngOnDestroy = function () {
                    var _this = this;
                    this._monitoredElements.forEach(( /**
                     * @param {?} _info
                     * @param {?} element
                     * @return {?}
                     */function (_info, element) { return _this.stopMonitoring(element); }));
                };
                return AutofillMonitor;
            }());
            AutofillMonitor.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */
            AutofillMonitor.ctorParameters = function () { return [
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
            ]; };
            /** @nocollapse */ AutofillMonitor.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"])); }, token: AutofillMonitor, providedIn: "root" });
            /**
             * A directive that can be used to monitor the autofill state of an input.
             */
            var CdkAutofill = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _autofillMonitor
                 */
                function CdkAutofill(_elementRef, _autofillMonitor) {
                    this._elementRef = _elementRef;
                    this._autofillMonitor = _autofillMonitor;
                    /**
                     * Emits when the autofill state of the element changes.
                     */
                    this.cdkAutofill = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                }
                /**
                 * @return {?}
                 */
                CdkAutofill.prototype.ngOnInit = function () {
                    var _this = this;
                    this._autofillMonitor
                        .monitor(this._elementRef)
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return _this.cdkAutofill.emit(event); }));
                };
                /**
                 * @return {?}
                 */
                CdkAutofill.prototype.ngOnDestroy = function () {
                    this._autofillMonitor.stopMonitoring(this._elementRef);
                };
                return CdkAutofill;
            }());
            CdkAutofill.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkAutofill]',
                        },] },
            ];
            /** @nocollapse */
            CdkAutofill.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: AutofillMonitor }
            ]; };
            CdkAutofill.propDecorators = {
                cdkAutofill: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive to automatically resize a textarea to fit its content.
             */
            var CdkTextareaAutosize = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _platform
                 * @param {?} _ngZone
                 */
                function CdkTextareaAutosize(_elementRef, _platform, _ngZone) {
                    this._elementRef = _elementRef;
                    this._platform = _platform;
                    this._ngZone = _ngZone;
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    this._enabled = true;
                    /**
                     * Value of minRows as of last resize. If the minRows has decreased, the
                     * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight
                     * does not have the same problem because it does not affect the textarea's scrollHeight.
                     */
                    this._previousMinRows = -1;
                    this._textareaElement = ( /** @type {?} */(this._elementRef.nativeElement));
                }
                Object.defineProperty(CdkTextareaAutosize.prototype, "minRows", {
                    /**
                     * Minimum amount of rows in the textarea.
                     * @return {?}
                     */
                    get: function () { return this._minRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minRows = value;
                        this._setMinHeight();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTextareaAutosize.prototype, "maxRows", {
                    /**
                     * Maximum amount of rows in the textarea.
                     * @return {?}
                     */
                    get: function () { return this._maxRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxRows = value;
                        this._setMaxHeight();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTextareaAutosize.prototype, "enabled", {
                    /**
                     * Whether autosizing is enabled or not
                     * @return {?}
                     */
                    get: function () { return this._enabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        // Only act if the actual value changed. This specifically helps to not run
                        // resizeToFitContent too early (i.e. before ngAfterViewInit)
                        if (this._enabled !== value) {
                            (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the minimum height of the textarea as determined by minRows.
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._setMinHeight = function () {
                    /** @type {?} */
                    var minHeight = this.minRows && this._cachedLineHeight ?
                        this.minRows * this._cachedLineHeight + "px" : null;
                    if (minHeight) {
                        this._textareaElement.style.minHeight = minHeight;
                    }
                };
                /**
                 * Sets the maximum height of the textarea as determined by maxRows.
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._setMaxHeight = function () {
                    /** @type {?} */
                    var maxHeight = this.maxRows && this._cachedLineHeight ?
                        this.maxRows * this._cachedLineHeight + "px" : null;
                    if (maxHeight) {
                        this._textareaElement.style.maxHeight = maxHeight;
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    if (this._platform.isBrowser) {
                        // Remember the height which we started with in case autosizing is disabled
                        this._initialHeight = this._textareaElement.style.height;
                        this.resizeToFitContent();
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["fromEvent"])(window, 'resize')
                                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["auditTime"])(16), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(_this._destroyed))
                                .subscribe(( /**
                         * @return {?}
                         */function () { return _this.resizeToFitContent(true); }));
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Cache the height of a single-row textarea if it has not already been cached.
                 *
                 * We need to know how large a single "row" of a textarea is in order to apply minRows and
                 * maxRows. For the initial version, we will assume that the height of a single line in the
                 * textarea does not ever change.
                 * @private
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._cacheTextareaLineHeight = function () {
                    if (this._cachedLineHeight) {
                        return;
                    }
                    // Use a clone element because we have to override some styles.
                    /** @type {?} */
                    var textareaClone = ( /** @type {?} */(this._textareaElement.cloneNode(false)));
                    textareaClone.rows = 1;
                    // Use `position: absolute` so that this doesn't cause a browser layout and use
                    // `visibility: hidden` so that nothing is rendered. Clear any other styles that
                    // would affect the height.
                    textareaClone.style.position = 'absolute';
                    textareaClone.style.visibility = 'hidden';
                    textareaClone.style.border = 'none';
                    textareaClone.style.padding = '0';
                    textareaClone.style.height = '';
                    textareaClone.style.minHeight = '';
                    textareaClone.style.maxHeight = '';
                    // In Firefox it happens that textarea elements are always bigger than the specified amount
                    // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.
                    // As a workaround that removes the extra space for the scrollbar, we can just set overflow
                    // to hidden. This ensures that there is no invalid calculation of the line height.
                    // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654
                    textareaClone.style.overflow = 'hidden';
                    ( /** @type {?} */(this._textareaElement.parentNode)).appendChild(textareaClone);
                    this._cachedLineHeight = textareaClone.clientHeight;
                    ( /** @type {?} */(this._textareaElement.parentNode)).removeChild(textareaClone);
                    // Min and max heights have to be re-calculated if the cached line height changes
                    this._setMinHeight();
                    this._setMaxHeight();
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.ngDoCheck = function () {
                    if (this._platform.isBrowser) {
                        this.resizeToFitContent();
                    }
                };
                /**
                 * Resize the textarea to fit its content.
                 * @param {?=} force Whether to force a height recalculation. By default the height will be
                 *    recalculated only if the value changed since the last call.
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.resizeToFitContent = function (force) {
                    var _this = this;
                    if (force === void 0) { force = false; }
                    // If autosizing is disabled, just skip everything else
                    if (!this._enabled) {
                        return;
                    }
                    this._cacheTextareaLineHeight();
                    // If we haven't determined the line-height yet, we know we're still hidden and there's no point
                    // in checking the height of the textarea.
                    if (!this._cachedLineHeight) {
                        return;
                    }
                    /** @type {?} */
                    var textarea = ( /** @type {?} */(this._elementRef.nativeElement));
                    /** @type {?} */
                    var value = textarea.value;
                    // Only resize if the value or minRows have changed since these calculations can be expensive.
                    if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {
                        return;
                    }
                    /** @type {?} */
                    var placeholderText = textarea.placeholder;
                    // Reset the textarea height to auto in order to shrink back to its default size.
                    // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.
                    // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight
                    // value. To ensure that the scrollHeight is not bigger than the content, the placeholders
                    // need to be removed temporarily.
                    textarea.classList.add('cdk-textarea-autosize-measuring');
                    textarea.placeholder = '';
                    // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with
                    // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).
                    /** @type {?} */
                    var height = textarea.scrollHeight - 4;
                    // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
                    textarea.style.height = height + "px";
                    textarea.classList.remove('cdk-textarea-autosize-measuring');
                    textarea.placeholder = placeholderText;
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        if (typeof requestAnimationFrame !== 'undefined') {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () { return _this._scrollToCaretPosition(textarea); }));
                        }
                        else {
                            setTimeout(( /**
                             * @return {?}
                             */function () { return _this._scrollToCaretPosition(textarea); }));
                        }
                    }));
                    this._previousValue = value;
                    this._previousMinRows = this._minRows;
                };
                /**
                 * Resets the textarea to its original size
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype.reset = function () {
                    // Do not try to change the textarea, if the initialHeight has not been determined yet
                    // This might potentially remove styles when reset() is called before ngAfterViewInit
                    if (this._initialHeight === undefined) {
                        return;
                    }
                    this._textareaElement.style.height = this._initialHeight;
                };
                /**
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._noopInputHandler = function () {
                    // no-op handler that ensures we're running change detection on input events.
                };
                /**
                 * Scrolls a textarea to the caret position. On Firefox resizing the textarea will
                 * prevent it from scrolling to the caret position. We need to re-set the selection
                 * in order for it to scroll to the proper position.
                 * @private
                 * @param {?} textarea
                 * @return {?}
                 */
                CdkTextareaAutosize.prototype._scrollToCaretPosition = function (textarea) {
                    var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;
                    // IE will throw an "Unspecified error" if we try to set the selection range after the
                    // element has been removed from the DOM. Assert that the directive hasn't been destroyed
                    // between the time we requested the animation frame and when it was executed.
                    // Also note that we have to assert that the textarea is focused before we set the
                    // selection range. Setting the selection range on a non-focused textarea will cause
                    // it to receive focus on IE and Edge.
                    if (!this._destroyed.isStopped && document.activeElement === textarea) {
                        textarea.setSelectionRange(selectionStart, selectionEnd);
                    }
                };
                return CdkTextareaAutosize;
            }());
            CdkTextareaAutosize.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'textarea[cdkTextareaAutosize]',
                            exportAs: 'cdkTextareaAutosize',
                            host: {
                                'class': 'cdk-textarea-autosize',
                                // Textarea elements that have the directive applied should have a single row by default.
                                // Browsers normally show two rows by default and therefore this limits the minRows binding.
                                'rows': '1',
                                '(input)': '_noopInputHandler()',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkTextareaAutosize.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
            ]; };
            CdkTextareaAutosize.propDecorators = {
                minRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkAutosizeMinRows',] }],
                maxRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkAutosizeMaxRows',] }],
                enabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkTextareaAutosize',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var TextFieldModule = /** @class */ (function () {
                function TextFieldModule() {
                }
                return TextFieldModule;
            }());
            TextFieldModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            declarations: [CdkAutofill, CdkTextareaAutosize],
                            imports: [_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["PlatformModule"]],
                            exports: [CdkAutofill, CdkTextareaAutosize],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=text-field.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/bottom-sheet/typings/index.ngfactory.js": 
        /*!********************************************************************************!*\
          !*** ./node_modules/@angular/material/bottom-sheet/typings/index.ngfactory.js ***!
          \********************************************************************************/
        /*! exports provided: MatBottomSheetModuleNgFactory, RenderType_MatBottomSheetContainer, View_MatBottomSheetContainer_0, View_MatBottomSheetContainer_Host_0, MatBottomSheetContainerNgFactory */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetModuleNgFactory", function () { return MatBottomSheetModuleNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatBottomSheetContainer", function () { return RenderType_MatBottomSheetContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatBottomSheetContainer_0", function () { return View_MatBottomSheetContainer_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatBottomSheetContainer_Host_0", function () { return View_MatBottomSheetContainer_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetContainerNgFactory", function () { return MatBottomSheetContainerNgFactory; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/bottom-sheet */ "./node_modules/@angular/material/esm2015/bottom-sheet.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /**
             * @fileoverview This file was generated by the Angular template compiler. Do not edit.
             *
             * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
             * tslint:disable
             */
            var MatBottomSheetModuleNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcmf"](_angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__["MatBottomSheetModule"], [], function (_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmod"]([_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](512, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵCodegenComponentFactoryResolver"], [[8, [MatBottomSheetContainerNgFactory]], [3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModuleRef"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgLocalization"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgLocaleLocalization"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["LOCALE_ID"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵangular_packages_common_common_a"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["Overlay"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["Overlay"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["ScrollStrategyOptions"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["OverlayContainer"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["OverlayPositionBuilder"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["OverlayKeyboardDispatcher"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_2__["Location"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["ɵc"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["ɵd"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["BidiModule"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["BidiModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["PlatformModule"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["PlatformModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__["ScrollingModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__["ScrollingModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["OverlayModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__["OverlayModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"], [[2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MATERIAL_SANITY_CHECKS"]], [2, _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_LOADER"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__["MatBottomSheetModule"], _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__["MatBottomSheetModule"], [])]); });
            var styles_MatBottomSheetContainer = [".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}@media (-ms-high-contrast:active){.mat-bottom-sheet-container{outline:1px solid}}.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium,.mat-bottom-sheet-container-xlarge{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}"];
            var RenderType_MatBottomSheetContainer = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatBottomSheetContainer, data: { "animation": [{ type: 7, name: "state", definitions: [{ type: 0, name: "void, hidden", styles: { type: 6, styles: { transform: "translateY(100%)" }, offset: null }, options: undefined }, { type: 0, name: "visible", styles: { type: 6, styles: { transform: "translateY(0%)" }, offset: null }, options: undefined }, { type: 1, expr: "visible => void, visible => hidden", animation: { type: 4, styles: null, timings: "375ms cubic-bezier(0.4,0.0,1,1)" }, options: null }, { type: 1, expr: "void => visible", animation: { type: 4, styles: null, timings: "195ms cubic-bezier(0.0,0.0,0.2,1)" }, options: null }], options: {} }] } });
            function View_MatBottomSheetContainer_1(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](0, null, null, 0))], null, null); }
            function View_MatBottomSheetContainer_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](402653184, 1, { _portalOutlet: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatBottomSheetContainer_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 212992, [[1, 4]], 0, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["CdkPortalOutlet"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]], { portal: [0, "portal"] }, null)], function (_ck, _v) { var currVal_0 = ""; _ck(_v, 2, 0, currVal_0); }, null); }
            function View_MatBottomSheetContainer_Host_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-bottom-sheet-container", [["aria-modal", "true"], ["class", "mat-bottom-sheet-container"], ["role", "dialog"], ["tabindex", "-1"]], [[1, "aria-label", 0], [40, "@state", 0]], [["component", "@state.start"], ["component", "@state.done"]], function (_v, en, $event) {
                        var ad = true;
                        if (("component:@state.start" === en)) {
                            var pd_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._onAnimationStart($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("component:@state.done" === en)) {
                            var pd_1 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._onAnimationDone($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        return ad;
                    }, View_MatBottomSheetContainer_0, RenderType_MatBottomSheetContainer)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 180224, null, 0, _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__["MatBottomSheetContainer"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusTrapFactory"], _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_11__["BreakpointObserver"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]], _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__["MatBottomSheetConfig"]], null, null)], null, function (_ck, _v) { var currVal_0 = ((_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).bottomSheetConfig == null) ? null : _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).bottomSheetConfig.ariaLabel); var currVal_1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._animationState; _ck(_v, 0, 0, currVal_0, currVal_1); });
            }
            var MatBottomSheetContainerNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-bottom-sheet-container", _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_1__["MatBottomSheetContainer"], View_MatBottomSheetContainer_Host_0, {}, {}, []);
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/button/typings/index.ngfactory.js": 
        /*!**************************************************************************!*\
          !*** ./node_modules/@angular/material/button/typings/index.ngfactory.js ***!
          \**************************************************************************/
        /*! exports provided: MatButtonModuleNgFactory, RenderType_MatButton, View_MatButton_0, View_MatButton_Host_0, MatButtonNgFactory, RenderType_MatAnchor, View_MatAnchor_0, View_MatAnchor_Host_0, MatAnchorNgFactory */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonModuleNgFactory", function () { return MatButtonModuleNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatButton", function () { return RenderType_MatButton; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatButton_0", function () { return View_MatButton_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatButton_Host_0", function () { return View_MatButton_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonNgFactory", function () { return MatButtonNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatAnchor", function () { return RenderType_MatAnchor; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatAnchor_0", function () { return View_MatAnchor_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatAnchor_Host_0", function () { return View_MatAnchor_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAnchorNgFactory", function () { return MatAnchorNgFactory; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /**
             * @fileoverview This file was generated by the Angular template compiler. Do not edit.
             *
             * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
             * tslint:disable
             */
            var MatButtonModuleNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcmf"](_angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatButtonModule"], [], function (_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmod"]([_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](512, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵCodegenComponentFactoryResolver"], [[8, []], [3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModuleRef"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgLocalization"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgLocaleLocalization"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["LOCALE_ID"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵangular_packages_common_common_a"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__["BidiModule"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__["BidiModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], [[2, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MATERIAL_SANITY_CHECKS"]], [2, _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__["HAMMER_LOADER"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["PlatformModule"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["PlatformModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRippleModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatButtonModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatButtonModule"], [])]); });
            var styles_MatButton = [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"];
            var RenderType_MatButton = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatButton, data: {} });
            function View_MatButton_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { ripple: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 1, "span", [["class", "mat-button-wrapper"]], null, null, null, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵncd"](null, 0), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](3, 0, null, null, 1, "div", [["class", "mat-button-ripple mat-ripple"], ["matRipple", ""]], [[2, "mat-button-ripple-round", null], [2, "mat-ripple-unbounded", null]], null, null, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 212992, [[1, 4]], 0, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRipple"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["Platform"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_RIPPLE_GLOBAL_OPTIONS"]], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"]]], { centered: [0, "centered"], disabled: [1, "disabled"], trigger: [2, "trigger"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](5, 0, null, null, 0, "div", [["class", "mat-button-focus-overlay"]], null, null, null, null, null))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co.isIconButton; var currVal_3 = _co._isRippleDisabled(); var currVal_4 = _co._getHostElement(); _ck(_v, 4, 0, currVal_2, currVal_3, currVal_4); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = (_co.isRoundButton || _co.isIconButton); var currVal_1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 4).unbounded; _ck(_v, 3, 0, currVal_0, currVal_1); }); }
            function View_MatButton_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "button", [["mat-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], null, null, View_MatButton_0, RenderType_MatButton)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 180224, null, 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatButton"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__["FocusMonitor"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"]]], null, null)], null, function (_ck, _v) { var currVal_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).disabled || null); var currVal_1 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._animationMode === "NoopAnimations"); _ck(_v, 0, 0, currVal_0, currVal_1); }); }
            var MatButtonNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("button[mat-button], button[mat-raised-button], button[mat-icon-button],\n             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],\n             button[mat-flat-button]", _angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatButton"], View_MatButton_Host_0, { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, {}, ["*"]);
            var styles_MatAnchor = [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"];
            var RenderType_MatAnchor = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatAnchor, data: {} });
            function View_MatAnchor_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { ripple: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 1, "span", [["class", "mat-button-wrapper"]], null, null, null, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵncd"](null, 0), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](3, 0, null, null, 1, "div", [["class", "mat-button-ripple mat-ripple"], ["matRipple", ""]], [[2, "mat-button-ripple-round", null], [2, "mat-ripple-unbounded", null]], null, null, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 212992, [[1, 4]], 0, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRipple"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["Platform"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_RIPPLE_GLOBAL_OPTIONS"]], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"]]], { centered: [0, "centered"], disabled: [1, "disabled"], trigger: [2, "trigger"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](5, 0, null, null, 0, "div", [["class", "mat-button-focus-overlay"]], null, null, null, null, null))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co.isIconButton; var currVal_3 = _co._isRippleDisabled(); var currVal_4 = _co._getHostElement(); _ck(_v, 4, 0, currVal_2, currVal_3, currVal_4); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = (_co.isRoundButton || _co.isIconButton); var currVal_1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 4).unbounded; _ck(_v, 3, 0, currVal_0, currVal_1); }); }
            function View_MatAnchor_Host_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "a", [["mat-button", ""]], [[1, "tabindex", 0], [1, "disabled", 0], [1, "aria-disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        if (("click" === en)) {
                            var pd_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._haltDisabledEvents($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, View_MatAnchor_0, RenderType_MatAnchor)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 180224, null, 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatAnchor"], [_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__["FocusMonitor"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"]]], null, null)], null, function (_ck, _v) { var currVal_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).disabled ? (0 - 1) : (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).tabIndex || 0)); var currVal_1 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).disabled || null); var currVal_2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).disabled.toString(); var currVal_3 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._animationMode === "NoopAnimations"); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); });
            }
            var MatAnchorNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],\n             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]", _angular_material_button__WEBPACK_IMPORTED_MODULE_1__["MatAnchor"], View_MatAnchor_Host_0, { disabled: "disabled", disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex" }, {}, ["*"]);
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/datepicker/typings/index.ngfactory.js": 
        /*!******************************************************************************!*\
          !*** ./node_modules/@angular/material/datepicker/typings/index.ngfactory.js ***!
          \******************************************************************************/
        /*! exports provided: MatDatepickerModuleNgFactory, RenderType_MatCalendarHeader, View_MatCalendarHeader_0, View_MatCalendarHeader_Host_0, MatCalendarHeaderNgFactory, RenderType_MatCalendar, View_MatCalendar_0, View_MatCalendar_Host_0, MatCalendarNgFactory, RenderType_MatCalendarBody, View_MatCalendarBody_0, View_MatCalendarBody_Host_0, MatCalendarBodyNgFactory, RenderType_MatDatepickerContent, View_MatDatepickerContent_0, View_MatDatepickerContent_Host_0, MatDatepickerContentNgFactory, RenderType_MatDatepicker, View_MatDatepicker_0, View_MatDatepicker_Host_0, MatDatepickerNgFactory, RenderType_MatDatepickerToggle, View_MatDatepickerToggle_0, View_MatDatepickerToggle_Host_0, MatDatepickerToggleNgFactory, RenderType_MatMonthView, View_MatMonthView_0, View_MatMonthView_Host_0, MatMonthViewNgFactory, RenderType_MatYearView, View_MatYearView_0, View_MatYearView_Host_0, MatYearViewNgFactory, RenderType_MatMultiYearView, View_MatMultiYearView_0, View_MatMultiYearView_Host_0, MatMultiYearViewNgFactory */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerModuleNgFactory", function () { return MatDatepickerModuleNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatCalendarHeader", function () { return RenderType_MatCalendarHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatCalendarHeader_0", function () { return View_MatCalendarHeader_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatCalendarHeader_Host_0", function () { return View_MatCalendarHeader_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarHeaderNgFactory", function () { return MatCalendarHeaderNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatCalendar", function () { return RenderType_MatCalendar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatCalendar_0", function () { return View_MatCalendar_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatCalendar_Host_0", function () { return View_MatCalendar_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarNgFactory", function () { return MatCalendarNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatCalendarBody", function () { return RenderType_MatCalendarBody; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatCalendarBody_0", function () { return View_MatCalendarBody_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatCalendarBody_Host_0", function () { return View_MatCalendarBody_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarBodyNgFactory", function () { return MatCalendarBodyNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatDatepickerContent", function () { return RenderType_MatDatepickerContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatDatepickerContent_0", function () { return View_MatDatepickerContent_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatDatepickerContent_Host_0", function () { return View_MatDatepickerContent_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerContentNgFactory", function () { return MatDatepickerContentNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatDatepicker", function () { return RenderType_MatDatepicker; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatDatepicker_0", function () { return View_MatDatepicker_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatDatepicker_Host_0", function () { return View_MatDatepicker_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerNgFactory", function () { return MatDatepickerNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatDatepickerToggle", function () { return RenderType_MatDatepickerToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatDatepickerToggle_0", function () { return View_MatDatepickerToggle_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatDatepickerToggle_Host_0", function () { return View_MatDatepickerToggle_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggleNgFactory", function () { return MatDatepickerToggleNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatMonthView", function () { return RenderType_MatMonthView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatMonthView_0", function () { return View_MatMonthView_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatMonthView_Host_0", function () { return View_MatMonthView_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMonthViewNgFactory", function () { return MatMonthViewNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatYearView", function () { return RenderType_MatYearView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatYearView_0", function () { return View_MatYearView_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatYearView_Host_0", function () { return View_MatYearView_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatYearViewNgFactory", function () { return MatYearViewNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatMultiYearView", function () { return RenderType_MatMultiYearView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatMultiYearView_0", function () { return View_MatMultiYearView_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatMultiYearView_Host_0", function () { return View_MatMultiYearView_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMultiYearViewNgFactory", function () { return MatMultiYearViewNgFactory; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/datepicker */ "./node_modules/@angular/material/esm2015/datepicker.js");
            /* harmony import */ var _dialog_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dialog/typings/index.ngfactory */ "./node_modules/@angular/material/dialog/typings/index.ngfactory.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/dialog */ "./node_modules/@angular/material/esm2015/dialog.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../button/typings/index.ngfactory */ "./node_modules/@angular/material/button/typings/index.ngfactory.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /**
             * @fileoverview This file was generated by the Angular template compiler. Do not edit.
             *
             * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
             * tslint:disable
             */
            var MatDatepickerModuleNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcmf"](_angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerModule"], [], function (_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmod"]([_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](512, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵCodegenComponentFactoryResolver"], [[8, [_dialog_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_2__["MatDialogContainerNgFactory"], MatDatepickerContentNgFactory, MatCalendarHeaderNgFactory]], [3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModuleRef"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgLocalization"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgLocaleLocalization"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["LOCALE_ID"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵangular_packages_common_common_a"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["ScrollStrategyOptions"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayContainer"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayPositionBuilder"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayKeyboardDispatcher"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_3__["Location"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["ɵc"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["ɵd"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MAT_DIALOG_SCROLL_STRATEGY"], _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](135680, _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MatDialog"], _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MatDialog"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_3__["Location"]], [2, _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MAT_DIALOG_DEFAULT_OPTIONS"]], _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MAT_DIALOG_SCROLL_STRATEGY"], [3, _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MatDialog"]], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayContainer"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["MutationObserverFactory"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["MutationObserverFactory"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerIntl"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerIntl"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MAT_DATEPICKER_SCROLL_STRATEGY"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["BidiModule"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["BidiModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"], [[2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MATERIAL_SANITY_CHECKS"]], [2, _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_LOADER"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_10__["PlatformModule"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_10__["PlatformModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatRippleModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_button__WEBPACK_IMPORTED_MODULE_11__["MatButtonModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_11__["MatButtonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_12__["PortalModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_12__["PortalModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_13__["ScrollingModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_13__["ScrollingModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MatDialogModule"], _angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MatDialogModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["ObserversModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["ObserversModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["A11yModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["A11yModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerModule"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerModule"], [])]); });
            var styles_MatCalendarHeader = [];
            var RenderType_MatCalendarHeader = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatCalendarHeader, data: {} });
            function View_MatCalendarHeader_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 12, "div", [["class", "mat-calendar-header"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 11, "div", [["class", "mat-calendar-controls"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](2, 0, null, null, 4, "button", [["cdkAriaLive", "polite"], ["class", "mat-calendar-period-button"], ["mat-button", ""], ["type", "button"]], [[1, "aria-label", 0], [1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("click" === en)) {
                            var pd_0 = (_co.currentPeriodClicked() !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["View_MatButton_0"], _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["RenderType_MatButton"])), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](3, 180224, null, 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_11__["MatButton"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["FocusMonitor"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_16__["ANIMATION_MODULE_TYPE"]]], null, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 147456, null, 0, _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["CdkAriaLive"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["LiveAnnouncer"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["ContentObserver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]], { politeness: [0, "politeness"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](5, 0, ["", ""])), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](6, 0, null, 0, 0, "div", [["class", "mat-calendar-arrow"]], [[2, "mat-calendar-invert", null]], null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](7, 0, null, null, 0, "div", [["class", "mat-calendar-spacer"]], null, null, null, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵncd"](null, 0), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](9, 0, null, null, 1, "button", [["class", "mat-calendar-previous-button"], ["mat-icon-button", ""], ["type", "button"]], [[1, "aria-label", 0], [1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("click" === en)) {
                            var pd_0 = (_co.previousClicked() !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["View_MatButton_0"], _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["RenderType_MatButton"])), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](10, 180224, null, 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_11__["MatButton"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["FocusMonitor"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_16__["ANIMATION_MODULE_TYPE"]]], { disabled: [0, "disabled"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](11, 0, null, null, 1, "button", [["class", "mat-calendar-next-button"], ["mat-icon-button", ""], ["type", "button"]], [[1, "aria-label", 0], [1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("click" === en)) {
                            var pd_0 = (_co.nextClicked() !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["View_MatButton_0"], _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["RenderType_MatButton"])), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](12, 180224, null, 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_11__["MatButton"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["FocusMonitor"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_16__["ANIMATION_MODULE_TYPE"]]], { disabled: [0, "disabled"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_3 = "polite"; _ck(_v, 4, 0, currVal_3); var currVal_9 = !_co.previousEnabled(); _ck(_v, 10, 0, currVal_9); var currVal_13 = !_co.nextEnabled(); _ck(_v, 12, 0, currVal_13); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.periodButtonLabel; var currVal_1 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 3).disabled || null); var currVal_2 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 3)._animationMode === "NoopAnimations"); _ck(_v, 2, 0, currVal_0, currVal_1, currVal_2); var currVal_4 = _co.periodButtonText; _ck(_v, 5, 0, currVal_4); var currVal_5 = (_co.calendar.currentView != "month"); _ck(_v, 6, 0, currVal_5); var currVal_6 = _co.prevButtonLabel; var currVal_7 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 10).disabled || null); var currVal_8 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 10)._animationMode === "NoopAnimations"); _ck(_v, 9, 0, currVal_6, currVal_7, currVal_8); var currVal_10 = _co.nextButtonLabel; var currVal_11 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 12).disabled || null); var currVal_12 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 12)._animationMode === "NoopAnimations"); _ck(_v, 11, 0, currVal_10, currVal_11, currVal_12); });
            }
            function View_MatCalendarHeader_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-calendar-header", [], null, null, null, View_MatCalendarHeader_0, RenderType_MatCalendarHeader)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 49152, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarHeader"], [_angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerIntl"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendar"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]], null, null)], null, null); }
            var MatCalendarHeaderNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-calendar-header", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarHeader"], View_MatCalendarHeader_Host_0, {}, {}, ["*"]);
            var styles_MatCalendar = [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}"];
            var RenderType_MatCalendar = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatCalendar, data: {} });
            function View_MatCalendar_1(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](0, null, null, 0))], null, null); }
            function View_MatCalendar_2(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-month-view", [], null, [[null, "activeDateChange"], [null, "selectedChange"], [null, "_userSelection"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("activeDateChange" === en)) {
                            var pd_0 = ((_co.activeDate = $event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("selectedChange" === en)) {
                            var pd_1 = (_co._dateSelected($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        if (("_userSelection" === en)) {
                            var pd_2 = (_co._userSelected() !== false);
                            ad = (pd_2 && ad);
                        }
                        return ad;
                    }, View_MatMonthView_0, RenderType_MatMonthView)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1097728, [[1, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatMonthView"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]]], { activeDate: [0, "activeDate"], selected: [1, "selected"], minDate: [2, "minDate"], maxDate: [3, "maxDate"], dateFilter: [4, "dateFilter"], dateClass: [5, "dateClass"] }, { selectedChange: "selectedChange", _userSelection: "_userSelection", activeDateChange: "activeDateChange" })], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.activeDate; var currVal_1 = _co.selected; var currVal_2 = _co.minDate; var currVal_3 = _co.maxDate; var currVal_4 = _co.dateFilter; var currVal_5 = _co.dateClass; _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5); }, null);
            }
            function View_MatCalendar_3(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-year-view", [], null, [[null, "activeDateChange"], [null, "monthSelected"], [null, "selectedChange"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("activeDateChange" === en)) {
                            var pd_0 = ((_co.activeDate = $event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("monthSelected" === en)) {
                            var pd_1 = (_co._monthSelectedInYearView($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        if (("selectedChange" === en)) {
                            var pd_2 = (_co._goToDateInView($event, "month") !== false);
                            ad = (pd_2 && ad);
                        }
                        return ad;
                    }, View_MatYearView_0, RenderType_MatYearView)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1097728, [[2, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatYearView"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]]], { activeDate: [0, "activeDate"], selected: [1, "selected"], minDate: [2, "minDate"], maxDate: [3, "maxDate"], dateFilter: [4, "dateFilter"] }, { selectedChange: "selectedChange", monthSelected: "monthSelected", activeDateChange: "activeDateChange" })], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.activeDate; var currVal_1 = _co.selected; var currVal_2 = _co.minDate; var currVal_3 = _co.maxDate; var currVal_4 = _co.dateFilter; _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }, null);
            }
            function View_MatCalendar_4(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-multi-year-view", [], null, [[null, "activeDateChange"], [null, "yearSelected"], [null, "selectedChange"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("activeDateChange" === en)) {
                            var pd_0 = ((_co.activeDate = $event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("yearSelected" === en)) {
                            var pd_1 = (_co._yearSelectedInMultiYearView($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        if (("selectedChange" === en)) {
                            var pd_2 = (_co._goToDateInView($event, "year") !== false);
                            ad = (pd_2 && ad);
                        }
                        return ad;
                    }, View_MatMultiYearView_0, RenderType_MatMultiYearView)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1097728, [[3, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatMultiYearView"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]]], { activeDate: [0, "activeDate"], selected: [1, "selected"], minDate: [2, "minDate"], maxDate: [3, "maxDate"], dateFilter: [4, "dateFilter"] }, { selectedChange: "selectedChange", yearSelected: "yearSelected", activeDateChange: "activeDateChange" })], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.activeDate; var currVal_1 = _co.selected; var currVal_2 = _co.minDate; var currVal_3 = _co.maxDate; var currVal_4 = _co.dateFilter; _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }, null);
            }
            function View_MatCalendar_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { monthView: 0 }), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 2, { yearView: 0 }), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 3, { multiYearView: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendar_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 212992, null, 0, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_12__["CdkPortalOutlet"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]], { portal: [0, "portal"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](5, 0, null, null, 8, "div", [["cdkMonitorSubtreeFocus", ""], ["class", "mat-calendar-content"], ["tabindex", "-1"]], null, null, null, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](6, 16384, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitch"], [], { ngSwitch: [0, "ngSwitch"] }, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](7, 147456, null, 0, _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["CdkMonitorFocus"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["FocusMonitor"]], null, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendar_2)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](9, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitchCase"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitch"]], { ngSwitchCase: [0, "ngSwitchCase"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendar_3)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](11, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitchCase"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitch"]], { ngSwitchCase: [0, "ngSwitchCase"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendar_4)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](13, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitchCase"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitch"]], { ngSwitchCase: [0, "ngSwitchCase"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co._calendarHeaderPortal; _ck(_v, 4, 0, currVal_0); var currVal_1 = _co.currentView; _ck(_v, 6, 0, currVal_1); var currVal_2 = "month"; _ck(_v, 9, 0, currVal_2); var currVal_3 = "year"; _ck(_v, 11, 0, currVal_3); var currVal_4 = "multi-year"; _ck(_v, 13, 0, currVal_4); }, null); }
            function View_MatCalendar_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-calendar", [["class", "mat-calendar"]], null, null, null, View_MatCalendar_0, RenderType_MatCalendar)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 10141696, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendar"], [_angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerIntl"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]], null, null)], null, null); }
            var MatCalendarNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-calendar", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendar"], View_MatCalendar_Host_0, { headerComponent: "headerComponent", startAt: "startAt", startView: "startView", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter", dateClass: "dateClass" }, { selectedChange: "selectedChange", yearSelected: "yearSelected", monthSelected: "monthSelected", _userSelection: "_userSelection" }, []);
            var styles_MatCalendarBody = [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}}[dir=rtl] .mat-calendar-body-label{text-align:right}"];
            var RenderType_MatCalendarBody = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatCalendarBody, data: {} });
            function View_MatCalendarBody_1(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 2, "tr", [["aria-hidden", "true"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 1, "td", [["class", "mat-calendar-body-label"]], [[1, "colspan", 0], [4, "paddingTop", null], [4, "paddingBottom", null]], null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](2, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.numCols; var currVal_1 = _co._cellPadding; var currVal_2 = _co._cellPadding; _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2); var currVal_3 = _co.label; _ck(_v, 2, 0, currVal_3); }); }
            function View_MatCalendarBody_3(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "td", [["aria-hidden", "true"], ["class", "mat-calendar-body-label"]], [[1, "colspan", 0], [4, "paddingTop", null], [4, "paddingBottom", null]], null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](1, null, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co._firstRowOffset; var currVal_1 = _co._cellPadding; var currVal_2 = _co._cellPadding; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2); var currVal_3 = ((_co._firstRowOffset >= _co.labelMinRequiredCells) ? _co.label : ""); _ck(_v, 1, 0, currVal_3); }); }
            function View_MatCalendarBody_4(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 4, "td", [["class", "mat-calendar-body-cell"], ["role", "button"]], [[8, "tabIndex", 0], [2, "mat-calendar-body-disabled", null], [2, "mat-calendar-body-active", null], [1, "aria-label", 0], [1, "aria-disabled", 0], [1, "aria-selected", 0], [4, "width", null], [4, "paddingTop", null], [4, "paddingBottom", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("click" === en)) {
                            var pd_0 = (_co._cellClicked(_v.context.$implicit) !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵprd"](512, null, _angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵNgClassImpl"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵNgClassR2Impl"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["KeyValueDiffers"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Renderer2"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgClass"], [_angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵNgClassImpl"]], { klass: [0, "klass"], ngClass: [1, "ngClass"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](3, 0, null, null, 1, "div", [["class", "mat-calendar-body-cell-content"]], [[2, "mat-calendar-body-selected", null], [2, "mat-calendar-body-today", null]], null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](4, null, ["", ""]))], function (_ck, _v) { var currVal_9 = "mat-calendar-body-cell"; var currVal_10 = _v.context.$implicit.cssClasses; _ck(_v, 2, 0, currVal_9, currVal_10); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = (_co._isActiveCell(_v.parent.context.index, _v.context.index) ? 0 : (0 - 1)); var currVal_1 = !_v.context.$implicit.enabled; var currVal_2 = _co._isActiveCell(_v.parent.context.index, _v.context.index); var currVal_3 = _v.context.$implicit.ariaLabel; var currVal_4 = (!_v.context.$implicit.enabled || null); var currVal_5 = (_co.selectedValue === _v.context.$implicit.value); var currVal_6 = _co._cellWidth; var currVal_7 = _co._cellPadding; var currVal_8 = _co._cellPadding; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5, currVal_6, currVal_7, currVal_8); var currVal_11 = (_co.selectedValue === _v.context.$implicit.value); var currVal_12 = (_co.todayValue === _v.context.$implicit.value); _ck(_v, 3, 0, currVal_11, currVal_12); var currVal_13 = _v.context.$implicit.displayValue; _ck(_v, 4, 0, currVal_13); });
            }
            function View_MatCalendarBody_2(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 4, "tr", [["role", "row"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendarBody_3)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 16384, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgIf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]], { ngIf: [0, "ngIf"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendarBody_4)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgForOf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"]], { ngForOf: [0, "ngForOf"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = ((_v.context.index === 0) && _co._firstRowOffset); _ck(_v, 2, 0, currVal_0); var currVal_1 = _v.context.$implicit; _ck(_v, 4, 0, currVal_1); }, null); }
            function View_MatCalendarBody_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendarBody_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 16384, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgIf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]], { ngIf: [0, "ngIf"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatCalendarBody_2)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](3, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgForOf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"]], { ngForOf: [0, "ngForOf"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = (_co._firstRowOffset < _co.labelMinRequiredCells); _ck(_v, 1, 0, currVal_0); var currVal_1 = _co.rows; _ck(_v, 3, 0, currVal_1); }, null); }
            function View_MatCalendarBody_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "div", [["aria-readonly", "true"], ["class", "mat-calendar-body"], ["mat-calendar-body", ""], ["role", "grid"]], null, null, null, View_MatCalendarBody_0, RenderType_MatCalendarBody)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 573440, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarBody"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]], null, null)], null, null); }
            var MatCalendarBodyNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("[mat-calendar-body]", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarBody"], View_MatCalendarBody_Host_0, { label: "label", rows: "rows", todayValue: "todayValue", selectedValue: "selectedValue", labelMinRequiredCells: "labelMinRequiredCells", numCols: "numCols", activeCell: "activeCell", cellAspectRatio: "cellAspectRatio" }, { selectedValueChange: "selectedValueChange" }, []);
            var styles_MatDatepickerContent = [".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"];
            var RenderType_MatDatepickerContent = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatDatepickerContent, data: { "animation": [{ type: 7, name: "transformPanel", definitions: [{ type: 0, name: "void", styles: { type: 6, styles: { opacity: 0, transform: "scale(1, 0.8)" }, offset: null }, options: undefined }, { type: 1, expr: "void => enter", animation: { type: 4, styles: { type: 6, styles: { opacity: 1, transform: "scale(1, 1)" }, offset: null }, timings: "120ms cubic-bezier(0, 0, 0.2, 1)" }, options: null }, { type: 1, expr: "* => void", animation: { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: "100ms linear" }, options: null }], options: {} }, { type: 7, name: "fadeInCalendar", definitions: [{ type: 0, name: "void", styles: { type: 6, styles: { opacity: 0 }, offset: null }, options: undefined }, { type: 0, name: "enter", styles: { type: 6, styles: { opacity: 1 }, offset: null }, options: undefined }, { type: 1, expr: "void => *", animation: { type: 4, styles: null, timings: "120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)" }, options: null }], options: {} }] } });
            function View_MatDatepickerContent_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { _calendar: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 4, "mat-calendar", [["cdkTrapFocus", ""], ["class", "mat-calendar"]], [[8, "id", 0], [24, "@fadeInCalendar", 0]], [[null, "selectedChange"], [null, "yearSelected"], [null, "monthSelected"], [null, "_userSelection"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("selectedChange" === en)) {
                            var pd_0 = (_co.datepicker.select($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("yearSelected" === en)) {
                            var pd_1 = (_co.datepicker._selectYear($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        if (("monthSelected" === en)) {
                            var pd_2 = (_co.datepicker._selectMonth($event) !== false);
                            ad = (pd_2 && ad);
                        }
                        if (("_userSelection" === en)) {
                            var pd_3 = (_co.datepicker.close() !== false);
                            ad = (pd_3 && ad);
                        }
                        return ad;
                    }, View_MatCalendar_0, RenderType_MatCalendar)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵprd"](512, null, _angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵNgClassImpl"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵNgClassR2Impl"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["KeyValueDiffers"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Renderer2"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](3, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgClass"], [_angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵNgClassImpl"]], { ngClass: [0, "ngClass"] }, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 1458176, null, 0, _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["CdkTrapFocus"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["FocusTrapFactory"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]], { enabled: [0, "enabled"] }, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](5, 10141696, [[1, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendar"], [_angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerIntl"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]], { headerComponent: [0, "headerComponent"], startAt: [1, "startAt"], startView: [2, "startView"], selected: [3, "selected"], minDate: [4, "minDate"], maxDate: [5, "maxDate"], dateFilter: [6, "dateFilter"], dateClass: [7, "dateClass"] }, { selectedChange: "selectedChange", yearSelected: "yearSelected", monthSelected: "monthSelected", _userSelection: "_userSelection" })], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co.datepicker.panelClass; _ck(_v, 3, 0, currVal_2); var currVal_3 = ""; _ck(_v, 4, 0, currVal_3); var currVal_4 = _co.datepicker.calendarHeaderComponent; var currVal_5 = _co.datepicker.startAt; var currVal_6 = _co.datepicker.startView; var currVal_7 = _co.datepicker._selected; var currVal_8 = _co.datepicker._minDate; var currVal_9 = _co.datepicker._maxDate; var currVal_10 = _co.datepicker._dateFilter; var currVal_11 = _co.datepicker.dateClass; _ck(_v, 5, 0, currVal_4, currVal_5, currVal_6, currVal_7, currVal_8, currVal_9, currVal_10, currVal_11); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.datepicker.id; var currVal_1 = "enter"; _ck(_v, 1, 0, currVal_0, currVal_1); });
            }
            function View_MatDatepickerContent_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-datepicker-content", [["class", "mat-datepicker-content"]], [[40, "@transformPanel", 0], [2, "mat-datepicker-content-touch", null]], null, null, View_MatDatepickerContent_0, RenderType_MatDatepickerContent)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 4243456, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerContent"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]], null, null)], null, function (_ck, _v) { var currVal_0 = "enter"; var currVal_1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker.touchUi; _ck(_v, 0, 0, currVal_0, currVal_1); }); }
            var MatDatepickerContentNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-datepicker-content", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerContent"], View_MatDatepickerContent_Host_0, { color: "color" }, {}, []);
            var styles_MatDatepicker = [];
            var RenderType_MatDatepicker = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatDatepicker, data: {} });
            function View_MatDatepicker_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [], null, null); }
            function View_MatDatepicker_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 16777216, null, null, 1, "mat-datepicker", [], null, null, null, View_MatDatepicker_0, RenderType_MatDatepicker)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 180224, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepicker"], [_angular_material_dialog__WEBPACK_IMPORTED_MODULE_6__["MatDialog"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MAT_DATEPICKER_SCROLL_STRATEGY"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]], [2, _angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]], null, null)], null, null); }
            var MatDatepickerNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-datepicker", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepicker"], View_MatDatepicker_Host_0, { calendarHeaderComponent: "calendarHeaderComponent", startAt: "startAt", startView: "startView", color: "color", touchUi: "touchUi", disabled: "disabled", panelClass: "panelClass", dateClass: "dateClass", opened: "opened" }, { yearSelected: "yearSelected", monthSelected: "monthSelected", openedStream: "opened", closedStream: "closed" }, []);
            var styles_MatDatepickerToggle = [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}"];
            var RenderType_MatDatepickerToggle = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatDatepickerToggle, data: {} });
            function View_MatDatepickerToggle_1(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, ":svg:svg", [["class", "mat-datepicker-toggle-default-icon"], ["fill", "currentColor"], ["focusable", "false"], ["height", "24px"], ["viewBox", "0 0 24 24"], ["width", "24px"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 0, ":svg:path", [["d", "M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"]], null, null, null, null, null))], null, null); }
            function View_MatDatepickerToggle_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { _button: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 4, "button", [["mat-icon-button", ""], ["type", "button"]], [[1, "aria-haspopup", 0], [1, "aria-label", 0], [1, "tabindex", 0], [1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("click" === en)) {
                            var pd_0 = (_co._open($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["View_MatButton_0"], _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_15__["RenderType_MatButton"])), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 180224, [[1, 4], ["button", 4]], 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_11__["MatButton"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_14__["FocusMonitor"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_16__["ANIMATION_MODULE_TYPE"]]], { disabled: [0, "disabled"], disableRipple: [1, "disableRipple"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, 0, 1, null, View_MatDatepickerToggle_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](4, 16384, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgIf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]], { ngIf: [0, "ngIf"] }, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵncd"](0, 0)], function (_ck, _v) { var _co = _v.component; var currVal_5 = _co.disabled; var currVal_6 = _co.disableRipple; _ck(_v, 2, 0, currVal_5, currVal_6); var currVal_7 = !_co._customIcon; _ck(_v, 4, 0, currVal_7); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = (_co.datepicker ? "dialog" : null); var currVal_1 = _co._intl.openCalendarLabel; var currVal_2 = (_co.disabled ? (0 - 1) : _co.tabIndex); var currVal_3 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 2).disabled || null); var currVal_4 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 2)._animationMode === "NoopAnimations"); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); });
            }
            function View_MatDatepickerToggle_Host_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 2, "mat-datepicker-toggle", [["class", "mat-datepicker-toggle"]], [[1, "tabindex", 0], [2, "mat-datepicker-toggle-active", null], [2, "mat-accent", null], [2, "mat-warn", null]], [[null, "focus"]], function (_v, en, $event) {
                        var ad = true;
                        if (("focus" === en)) {
                            var pd_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._button.focus() !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, View_MatDatepickerToggle_0, RenderType_MatDatepickerToggle)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1753088, null, 1, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerToggle"], [_angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerIntl"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [8, null]], null, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](603979776, 1, { _customIcon: 0 })], null, function (_ck, _v) { var currVal_0 = (0 - 1); var currVal_1 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker.opened); var currVal_2 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker && (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker.color === "accent")); var currVal_3 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker && (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).datepicker.color === "warn")); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); });
            }
            var MatDatepickerToggleNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-datepicker-toggle", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatDatepickerToggle"], View_MatDatepickerToggle_Host_0, { datepicker: "for", tabIndex: "tabIndex", disabled: "disabled", disableRipple: "disableRipple" }, {}, ["[matDatepickerToggleIcon]"]);
            var styles_MatMonthView = [];
            var RenderType_MatMonthView = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatMonthView, data: {} });
            function View_MatMonthView_1(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "th", [["scope", "col"]], [[1, "aria-label", 0]], null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](1, null, ["", ""]))], null, function (_ck, _v) { var currVal_0 = _v.context.$implicit.long; _ck(_v, 0, 0, currVal_0); var currVal_1 = _v.context.$implicit.narrow; _ck(_v, 1, 0, currVal_1); }); }
            function View_MatMonthView_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { _matCalendarBody: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 8, "table", [["class", "mat-calendar-table"], ["role", "presentation"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](2, 0, null, null, 5, "thead", [["class", "mat-calendar-table-header"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](3, 0, null, null, 2, "tr", [], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatMonthView_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](5, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgForOf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"]], { ngForOf: [0, "ngForOf"] }, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](6, 0, null, null, 1, "tr", [], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](7, 0, null, null, 0, "th", [["aria-hidden", "true"], ["class", "mat-calendar-table-header-divider"], ["colspan", "7"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](8, 0, null, null, 1, "tbody", [["aria-readonly", "true"], ["class", "mat-calendar-body"], ["mat-calendar-body", ""], ["role", "grid"]], null, [[null, "selectedValueChange"], [null, "keydown"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("selectedValueChange" === en)) {
                            var pd_0 = (_co._dateSelected($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("keydown" === en)) {
                            var pd_1 = (_co._handleCalendarBodyKeydown($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        return ad;
                    }, View_MatCalendarBody_0, RenderType_MatCalendarBody)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](9, 573440, [[1, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarBody"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]], { label: [0, "label"], rows: [1, "rows"], todayValue: [2, "todayValue"], selectedValue: [3, "selectedValue"], labelMinRequiredCells: [4, "labelMinRequiredCells"], activeCell: [5, "activeCell"] }, { selectedValueChange: "selectedValueChange" })], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co._weekdays; _ck(_v, 5, 0, currVal_0); var currVal_1 = _co._monthLabel; var currVal_2 = _co._weeks; var currVal_3 = _co._todayDate; var currVal_4 = _co._selectedDate; var currVal_5 = 3; var currVal_6 = (_co._dateAdapter.getDate(_co.activeDate) - 1); _ck(_v, 9, 0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5, currVal_6); }, null);
            }
            function View_MatMonthView_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-month-view", [], null, null, null, View_MatMonthView_0, RenderType_MatMonthView)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1097728, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatMonthView"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]]], null, null)], null, null); }
            var MatMonthViewNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-month-view", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatMonthView"], View_MatMonthView_Host_0, { activeDate: "activeDate", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter", dateClass: "dateClass" }, { selectedChange: "selectedChange", _userSelection: "_userSelection", activeDateChange: "activeDateChange" }, []);
            var styles_MatYearView = [];
            var RenderType_MatYearView = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatYearView, data: {} });
            function View_MatYearView_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { _matCalendarBody: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 5, "table", [["class", "mat-calendar-table"], ["role", "presentation"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](2, 0, null, null, 2, "thead", [["class", "mat-calendar-table-header"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](3, 0, null, null, 1, "tr", [], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](4, 0, null, null, 0, "th", [["class", "mat-calendar-table-header-divider"], ["colspan", "4"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](5, 0, null, null, 1, "tbody", [["aria-readonly", "true"], ["class", "mat-calendar-body"], ["mat-calendar-body", ""], ["role", "grid"]], null, [[null, "selectedValueChange"], [null, "keydown"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("selectedValueChange" === en)) {
                            var pd_0 = (_co._monthSelected($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("keydown" === en)) {
                            var pd_1 = (_co._handleCalendarBodyKeydown($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        return ad;
                    }, View_MatCalendarBody_0, RenderType_MatCalendarBody)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](6, 573440, [[1, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarBody"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]], { label: [0, "label"], rows: [1, "rows"], todayValue: [2, "todayValue"], selectedValue: [3, "selectedValue"], labelMinRequiredCells: [4, "labelMinRequiredCells"], numCols: [5, "numCols"], activeCell: [6, "activeCell"], cellAspectRatio: [7, "cellAspectRatio"] }, { selectedValueChange: "selectedValueChange" })], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co._yearLabel; var currVal_1 = _co._months; var currVal_2 = _co._todayMonth; var currVal_3 = _co._selectedMonth; var currVal_4 = 2; var currVal_5 = 4; var currVal_6 = _co._dateAdapter.getMonth(_co.activeDate); var currVal_7 = (4 / 7); _ck(_v, 6, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5, currVal_6, currVal_7); }, null);
            }
            function View_MatYearView_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-year-view", [], null, null, null, View_MatYearView_0, RenderType_MatYearView)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1097728, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatYearView"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]]], null, null)], null, null); }
            var MatYearViewNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-year-view", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatYearView"], View_MatYearView_Host_0, { activeDate: "activeDate", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter" }, { selectedChange: "selectedChange", monthSelected: "monthSelected", activeDateChange: "activeDateChange" }, []);
            var styles_MatMultiYearView = [];
            var RenderType_MatMultiYearView = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatMultiYearView, data: {} });
            function View_MatMultiYearView_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](671088640, 1, { _matCalendarBody: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 5, "table", [["class", "mat-calendar-table"], ["role", "presentation"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](2, 0, null, null, 2, "thead", [["class", "mat-calendar-table-header"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](3, 0, null, null, 1, "tr", [], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](4, 0, null, null, 0, "th", [["class", "mat-calendar-table-header-divider"], ["colspan", "4"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](5, 0, null, null, 1, "tbody", [["aria-readonly", "true"], ["class", "mat-calendar-body"], ["mat-calendar-body", ""], ["role", "grid"]], null, [[null, "selectedValueChange"], [null, "keydown"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("selectedValueChange" === en)) {
                            var pd_0 = (_co._yearSelected($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("keydown" === en)) {
                            var pd_1 = (_co._handleCalendarBodyKeydown($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        return ad;
                    }, View_MatCalendarBody_0, RenderType_MatCalendarBody)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](6, 573440, [[1, 4]], 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatCalendarBody"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]], { rows: [0, "rows"], todayValue: [1, "todayValue"], selectedValue: [2, "selectedValue"], numCols: [3, "numCols"], activeCell: [4, "activeCell"], cellAspectRatio: [5, "cellAspectRatio"] }, { selectedValueChange: "selectedValueChange" })], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co._years; var currVal_1 = _co._todayYear; var currVal_2 = _co._selectedYear; var currVal_3 = 4; var currVal_4 = _co._getActiveCell(); var currVal_5 = (4 / 7); _ck(_v, 6, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4, currVal_5); }, null);
            }
            function View_MatMultiYearView_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-multi-year-view", [], null, null, null, View_MatMultiYearView_0, RenderType_MatMultiYearView)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 1097728, null, 0, _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatMultiYearView"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]], [2, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"]]], null, null)], null, null); }
            var MatMultiYearViewNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-multi-year-view", _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_1__["MatMultiYearView"], View_MatMultiYearView_Host_0, { activeDate: "activeDate", selected: "selected", minDate: "minDate", maxDate: "maxDate", dateFilter: "dateFilter" }, { selectedChange: "selectedChange", yearSelected: "yearSelected", activeDateChange: "activeDateChange" }, []);
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/autocomplete.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/autocomplete.js ***!
          \****************************************************************/
        /*! exports provided: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY", function () { return MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteSelectedEvent", function () { return MatAutocompleteSelectedEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS", function () { return MAT_AUTOCOMPLETE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocomplete", function () { return MatAutocomplete; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteModule", function () { return MatAutocompleteModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatAutocompleteMissingPanelError", function () { return getMatAutocompleteMissingPanelError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_OPTION_HEIGHT", function () { return AUTOCOMPLETE_OPTION_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_PANEL_HEIGHT", function () { return AUTOCOMPLETE_PANEL_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_VALUE_ACCESSOR", function () { return MAT_AUTOCOMPLETE_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteTrigger", function () { return MatAutocompleteTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteOrigin", function () { return MatAutocompleteOrigin; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Autocomplete IDs need to be unique across components, so this counter exists outside of
             * the component definition.
             * @type {?}
             */
            var _uniqueAutocompleteIdCounter = 0;
            /**
             * Event object that is emitted when an autocomplete option is selected.
             */
            var MatAutocompleteSelectedEvent = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} option
                 */
                function MatAutocompleteSelectedEvent(source, option) {
                    this.source = source;
                    this.option = option;
                }
                return MatAutocompleteSelectedEvent;
            }());
            // Boilerplate for applying mixins to MatAutocomplete.
            /**
             * \@docs-private
             */
            var MatAutocompleteBase = /** @class */ (function () {
                function MatAutocompleteBase() {
                }
                return MatAutocompleteBase;
            }());
            /** @type {?} */
            var _MatAutocompleteMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(MatAutocompleteBase);
            /**
             * Injection token to be used to override the default options for `mat-autocomplete`.
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('mat-autocomplete-default-options', {
                providedIn: 'root',
                factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {
                return { autoActiveFirstOption: false };
            }
            var MatAutocomplete = /** @class */ (function (_super) {
                __extends(MatAutocomplete, _super);
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} defaults
                 */
                function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {
                    var _this = _super.call(this) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._elementRef = _elementRef;
                    /**
                     * Whether the autocomplete panel should be visible, depending on option length.
                     */
                    _this.showPanel = false;
                    _this._isOpen = false;
                    /**
                     * Function that maps an option's control value to its display value in the trigger.
                     */
                    _this.displayWith = null;
                    /**
                     * Event that is emitted whenever an option from the list is selected.
                     */
                    _this.optionSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    /**
                     * Event that is emitted when the autocomplete panel is opened.
                     */
                    _this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    /**
                     * Event that is emitted when the autocomplete panel is closed.
                     */
                    _this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    _this._classList = {};
                    /**
                     * Unique ID to be used by autocomplete trigger's "aria-owns" property.
                     */
                    _this.id = "mat-autocomplete-" + _uniqueAutocompleteIdCounter++;
                    _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;
                    return _this;
                }
                Object.defineProperty(MatAutocomplete.prototype, "isOpen", {
                    /**
                     * Whether the autocomplete panel is open.
                     * @return {?}
                     */
                    get: function () { return this._isOpen && this.showPanel; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocomplete.prototype, "autoActiveFirstOption", {
                    /**
                     * Whether the first option should be highlighted when the autocomplete panel is opened.
                     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.
                     * @return {?}
                     */
                    get: function () { return this._autoActiveFirstOption; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._autoActiveFirstOption = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocomplete.prototype, "classList", {
                    /**
                     * Takes classes set on the host mat-autocomplete element and applies them to the panel
                     * inside the overlay container to allow for easy styling.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value && value.length) {
                            this._classList = value.split(' ').reduce(( /**
                             * @param {?} classList
                             * @param {?} className
                             * @return {?}
                             */function (classList, className) {
                                classList[className.trim()] = true;
                                return classList;
                            }), ( /** @type {?} */({})));
                        }
                        else {
                            this._classList = {};
                        }
                        this._setVisibilityClasses(this._classList);
                        this._elementRef.nativeElement.className = '';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAutocomplete.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["ActiveDescendantKeyManager"](this.options).withWrap();
                    // Set the initial visibility state.
                    this._setVisibility();
                };
                /**
                 * Sets the panel scrollTop. This allows us to manually scroll to display options
                 * above or below the fold, as they are not actually being focused when active.
                 * @param {?} scrollTop
                 * @return {?}
                 */
                MatAutocomplete.prototype._setScrollTop = function (scrollTop) {
                    if (this.panel) {
                        this.panel.nativeElement.scrollTop = scrollTop;
                    }
                };
                /**
                 * Returns the panel's scrollTop.
                 * @return {?}
                 */
                MatAutocomplete.prototype._getScrollTop = function () {
                    return this.panel ? this.panel.nativeElement.scrollTop : 0;
                };
                /**
                 * Panel should hide itself when the option list is empty.
                 * @return {?}
                 */
                MatAutocomplete.prototype._setVisibility = function () {
                    this.showPanel = !!this.options.length;
                    this._setVisibilityClasses(this._classList);
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Emits the `select` event.
                 * @param {?} option
                 * @return {?}
                 */
                MatAutocomplete.prototype._emitSelectEvent = function (option) {
                    /** @type {?} */
                    var event = new MatAutocompleteSelectedEvent(this, option);
                    this.optionSelected.emit(event);
                };
                /**
                 * Sets the autocomplete visibility classes on a classlist based on the panel is visible.
                 * @private
                 * @param {?} classList
                 * @return {?}
                 */
                MatAutocomplete.prototype._setVisibilityClasses = function (classList) {
                    classList['mat-autocomplete-visible'] = this.showPanel;
                    classList['mat-autocomplete-hidden'] = !this.showPanel;
                };
                return MatAutocomplete;
            }(_MatAutocompleteMixinBase));
            MatAutocomplete.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"], args: [{ selector: 'mat-autocomplete',
                            template: "<ng-template><div class=\"mat-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel><ng-content></ng-content></div></ng-template>",
                            styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
                            exportAs: 'matAutocomplete',
                            inputs: ['disableRipple'],
                            host: {
                                'class': 'mat-autocomplete'
                            },
                            providers: [
                                { provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_OPTION_PARENT_COMPONENT"], useExisting: MatAutocomplete }
                            ]
                        },] },
            ];
            /** @nocollapse */
            MatAutocomplete.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatAutocomplete.propDecorators = {
                template: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["TemplateRef"], { static: true },] }],
                panel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"], args: ['panel', { static: false },] }],
                options: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOption"], { descendants: true },] }],
                optionGroups: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptgroup"],] }],
                displayWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                autoActiveFirstOption: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                panelWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                optionSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                classList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['class',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive applied to an element to make it usable
             * as a connection point for an autocomplete panel.
             */
            var MatAutocompleteOrigin = /** @class */ (function () {
                /**
                 * @param {?} elementRef
                 */
                function MatAutocompleteOrigin(elementRef) {
                    this.elementRef = elementRef;
                }
                return MatAutocompleteOrigin;
            }());
            MatAutocompleteOrigin.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: '[matAutocompleteOrigin]',
                            exportAs: 'matAutocompleteOrigin',
                        },] },
            ];
            /** @nocollapse */
            MatAutocompleteOrigin.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The height of each autocomplete option.
             * @type {?}
             */
            var AUTOCOMPLETE_OPTION_HEIGHT = 48;
            /**
             * The total height of the autocomplete panel.
             * @type {?}
             */
            var AUTOCOMPLETE_PANEL_HEIGHT = 256;
            /**
             * Injection token that determines the scroll handling while the autocomplete panel is open.
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('mat-autocomplete-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]],
                useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Provider that allows the autocomplete to register as a ControlValueAccessor.
             * \@docs-private
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatAutocompleteTrigger; })),
                multi: true
            };
            /**
             * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
             * \@docs-private
             * @return {?}
             */
            function getMatAutocompleteMissingPanelError() {
                return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +
                    'Make sure that the id passed to the `matAutocomplete` is correct and that ' +
                    'you\'re attempting to open it after the ngAfterContentInit hook.');
            }
            var MatAutocompleteTrigger = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?} _overlay
                 * @param {?} _viewContainerRef
                 * @param {?} _zone
                 * @param {?} _changeDetectorRef
                 * @param {?} scrollStrategy
                 * @param {?} _dir
                 * @param {?} _formField
                 * @param {?} _document
                 * @param {?=} _viewportRuler
                 */
                function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {
                    var _this = this;
                    this._element = _element;
                    this._overlay = _overlay;
                    this._viewContainerRef = _viewContainerRef;
                    this._zone = _zone;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dir = _dir;
                    this._formField = _formField;
                    this._document = _document;
                    this._viewportRuler = _viewportRuler;
                    this._componentDestroyed = false;
                    this._autocompleteDisabled = false;
                    /**
                     * Whether or not the label state is being overridden.
                     */
                    this._manuallyFloatingLabel = false;
                    /**
                     * Subscription to viewport size changes.
                     */
                    this._viewportSubscription = rxjs__WEBPACK_IMPORTED_MODULE_13__["Subscription"].EMPTY;
                    /**
                     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,
                     * closed autocomplete from being reopened if the user switches to another browser tab and then
                     * comes back.
                     */
                    this._canOpenOnNextFocus = true;
                    /**
                     * Stream of keyboard events that can close the panel.
                     */
                    this._closeKeyEventStream = new rxjs__WEBPACK_IMPORTED_MODULE_13__["Subject"]();
                    /**
                     * Event handler for when the window is blurred. Needs to be an
                     * arrow function in order to preserve the context.
                     */
                    this._windowBlurHandler = ( /**
                     * @return {?}
                     */function () {
                        // If the user blurred the window while the autocomplete is focused, it means that it'll be
                        // refocused when they come back. In this case we want to skip the first focus event, if the
                        // pane was closed, in order to avoid reopening it unintentionally.
                        _this._canOpenOnNextFocus =
                            _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;
                    });
                    /**
                     * `View -> model callback called when value changes`
                     */
                    this._onChange = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * `View -> model callback called when autocomplete has been touched`
                     */
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Position of the autocomplete panel relative to the trigger element. A position of `auto`
                     * will render the panel underneath the trigger if there is enough space for it to fit in
                     * the viewport, otherwise the panel will be shown above it. If the position is set to
                     * `above` or `below`, the panel will always be shown above or below the trigger. no matter
                     * whether it fits completely in the viewport.
                     */
                    this.position = 'auto';
                    /**
                     * `autocomplete` attribute to be set on the input element.
                     * \@docs-private
                     */
                    this.autocompleteAttribute = 'off';
                    this._overlayAttached = false;
                    /**
                     * Stream of autocomplete option selections.
                     */
                    this.optionSelections = ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["defer"])(( /**
                     * @return {?}
                     */function () {
                        if (_this.autocomplete && _this.autocomplete.options) {
                            return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"]).apply(void 0, _this.autocomplete.options.map(( /**
                             * @param {?} option
                             * @return {?}
                             */function (/**
                             * @param {?} option
                             * @return {?}
                             */ option) { return option.onSelectionChange; })));
                        }
                        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                        // Return a stream that we'll replace with the real one once everything is in place.
                        return _this._zone.onStable
                            .asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["switchMap"])(( /**
                     * @return {?}
                     */function () { return _this.optionSelections; })));
                    }))));
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatAutocompleteTrigger.prototype, "autocompleteDisabled", {
                    /**
                     * Whether the autocomplete is disabled. When disabled, the element will
                     * act as a regular input and the user won't be able to open the panel.
                     * @return {?}
                     */
                    get: function () { return this._autocompleteDisabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._autocompleteDisabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    if (typeof window !== 'undefined') {
                        this._zone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            window.addEventListener('blur', _this._windowBlurHandler);
                        }));
                        if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__["_supportsShadowDom"])()) {
                            /** @type {?} */
                            var element = this._element.nativeElement;
                            /** @type {?} */
                            var rootNode = element.getRootNode ? element.getRootNode() : null;
                            // We need to take the `ShadowRoot` off of `window`, because the built-in types are
                            // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.
                            this._isInsideShadowRoot = rootNode instanceof (( /** @type {?} */(window))).ShadowRoot;
                        }
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {
                    if (changes['position'] && this._positionStrategy) {
                        this._setStrategyPositions(this._positionStrategy);
                        if (this.panelOpen) {
                            ( /** @type {?} */(this._overlayRef)).updatePosition();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngOnDestroy = function () {
                    if (typeof window !== 'undefined') {
                        window.removeEventListener('blur', this._windowBlurHandler);
                    }
                    this._viewportSubscription.unsubscribe();
                    this._componentDestroyed = true;
                    this._destroyPanel();
                    this._closeKeyEventStream.complete();
                };
                Object.defineProperty(MatAutocompleteTrigger.prototype, "panelOpen", {
                    /**
                     * Whether or not the autocomplete panel is open.
                     * @return {?}
                     */
                    get: function () {
                        return this._overlayAttached && this.autocomplete.showPanel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens the autocomplete suggestion panel.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.openPanel = function () {
                    this._attachOverlay();
                    this._floatLabel();
                };
                /**
                 * Closes the autocomplete suggestion panel.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.closePanel = function () {
                    this._resetLabel();
                    if (!this._overlayAttached) {
                        return;
                    }
                    if (this.panelOpen) {
                        // Only emit if the panel was visible.
                        this.autocomplete.closed.emit();
                    }
                    this.autocomplete._isOpen = this._overlayAttached = false;
                    if (this._overlayRef && this._overlayRef.hasAttached()) {
                        this._overlayRef.detach();
                        this._closingActionsSubscription.unsubscribe();
                    }
                    // Note that in some cases this can end up being called after the component is destroyed.
                    // Add a check to ensure that we don't try to run change detection on a destroyed view.
                    if (!this._componentDestroyed) {
                        // We need to trigger change detection manually, because
                        // `fromEvent` doesn't seem to do it at the proper time.
                        // This ensures that the label is reset when the
                        // user clicks outside.
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
                 * within the viewport.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.updatePosition = function () {
                    if (this._overlayAttached) {
                        ( /** @type {?} */(this._overlayRef)).updatePosition();
                    }
                };
                Object.defineProperty(MatAutocompleteTrigger.prototype, "panelClosingActions", {
                    /**
                     * A stream of actions that should close the autocomplete panel, including
                     * when an option is selected, on blur, and when TAB is pressed.
                     * @return {?}
                     */
                    get: function () {
                        var _this = this;
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                         * @return {?}
                         */function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?
                            this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                             * @return {?}
                             */function () { return _this._overlayAttached; }))) :
                            Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["of"])()).pipe(
                        // Normalize the output so we return a consistent type.
                        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event instanceof _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionSelectionChange"] ? event : null; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocompleteTrigger.prototype, "activeOption", {
                    /**
                     * The currently active option, coerced to MatOption type.
                     * @return {?}
                     */
                    get: function () {
                        if (this.autocomplete && this.autocomplete._keyManager) {
                            return this.autocomplete._keyManager.activeItem;
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Stream of clicks outside of the autocomplete panel.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {
                    var _this = this;
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["fromEvent"])(this._document, 'click'))), ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["fromEvent"])(this._document, 'touchend'))))
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
                        // fall back to check the first element in the path of the click event.
                        /** @type {?} */
                        var clickTarget = ( /** @type {?} */((_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :
                            event.target)));
                        /** @type {?} */
                        var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;
                        return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&
                            (!formField || !formField.contains(clickTarget)) &&
                            (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
                    })));
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.writeValue = function (value) {
                    var _this = this;
                    Promise.resolve(null).then(( /**
                     * @return {?}
                     */function () { return _this._setTriggerValue(value); }));
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {
                    this._element.nativeElement.disabled = isDisabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    // Prevent the default action on all escape key presses. This is here primarily to bring IE
                    // in line with other browsers. By default, pressing escape on IE will cause it to revert
                    // the input value to the one that it had on focus, however it won't dispatch any events
                    // which means that the model value will be out of sync with the view.
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"]) {
                        event.preventDefault();
                    }
                    if (this.activeOption && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] && this.panelOpen) {
                        this.activeOption._selectViaInteraction();
                        this._resetActiveItem();
                        event.preventDefault();
                    }
                    else if (this.autocomplete) {
                        /** @type {?} */
                        var prevActiveItem = this.autocomplete._keyManager.activeItem;
                        /** @type {?} */
                        var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"];
                        if (this.panelOpen || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["TAB"]) {
                            this.autocomplete._keyManager.onKeydown(event);
                        }
                        else if (isArrowKey && this._canOpen()) {
                            this.openPanel();
                        }
                        if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                            this._scrollToOption();
                        }
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleInput = function (event) {
                    /** @type {?} */
                    var target = ( /** @type {?} */(event.target));
                    /** @type {?} */
                    var value = target.value;
                    // Based on `NumberValueAccessor` from forms.
                    if (target.type === 'number') {
                        value = value == '' ? null : parseFloat(value);
                    }
                    // If the input has a placeholder, IE will fire the `input` event on page load,
                    // focus and blur, in addition to when the user actually changed the value. To
                    // filter out all of the extra events, we save the value on focus and between
                    // `input` events, and we check whether it changed.
                    // See: https://connect.microsoft.com/IE/feedback/details/885747/
                    if (this._previousValue !== value) {
                        this._previousValue = value;
                        this._onChange(value);
                        if (this._canOpen() && this._document.activeElement === event.target) {
                            this.openPanel();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleFocus = function () {
                    if (!this._canOpenOnNextFocus) {
                        this._canOpenOnNextFocus = true;
                    }
                    else if (this._canOpen()) {
                        this._previousValue = this._element.nativeElement.value;
                        this._attachOverlay();
                        this._floatLabel(true);
                    }
                };
                /**
                 * In "auto" mode, the label will animate down as soon as focus is lost.
                 * This causes the value to jump when selecting an option with the mouse.
                 * This method manually floats the label until the panel can be closed.
                 * @private
                 * @param {?=} shouldAnimate Whether the label should be animated when it is floated.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {
                    if (shouldAnimate === void 0) { shouldAnimate = false; }
                    if (this._formField && this._formField.floatLabel === 'auto') {
                        if (shouldAnimate) {
                            this._formField._animateAndLockLabel();
                        }
                        else {
                            this._formField.floatLabel = 'always';
                        }
                        this._manuallyFloatingLabel = true;
                    }
                };
                /**
                 * If the label has been manually elevated, return it to its normal state.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._resetLabel = function () {
                    if (this._manuallyFloatingLabel) {
                        this._formField.floatLabel = 'auto';
                        this._manuallyFloatingLabel = false;
                    }
                };
                /**
                 * Given that we are not actually focusing active options, we must manually adjust scroll
                 * to reveal options below the fold. First, we find the offset of the option from the top
                 * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
                 * the panel height + the option height, so the active option will be just visible at the
                 * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
                 * will become the offset. If that offset is visible within the panel already, the scrollTop is
                 * not adjusted.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._scrollToOption = function () {
                    /** @type {?} */
                    var index = this.autocomplete._keyManager.activeItemIndex || 0;
                    /** @type {?} */
                    var labelCount = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["_countGroupLabelsBeforeOption"])(index, this.autocomplete.options, this.autocomplete.optionGroups);
                    if (index === 0 && labelCount === 1) {
                        // If we've got one group label before the option and we're at the top option,
                        // scroll the list to the top. This is better UX than scrolling the list to the
                        // top of the option, because it allows the user to read the top group's label.
                        this.autocomplete._setScrollTop(0);
                    }
                    else {
                        /** @type {?} */
                        var newScrollPosition = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["_getOptionScrollPosition"])(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);
                        this.autocomplete._setScrollTop(newScrollPosition);
                    }
                };
                /**
                 * This method listens to a stream of panel closing actions and resets the
                 * stream every time the option list changes.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {
                    var _this = this;
                    /** @type {?} */
                    var firstStable = this._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1));
                    /** @type {?} */
                    var optionChanges = this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["tap"])(( /**
                     * @return {?}
                     */function () { return _this._positionStrategy.reapplyLastPosition(); })), 
                    // Defer emitting to the stream until the next tick, because changing
                    // bindings in here will cause "changed after checked" errors.
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["delay"])(0));
                    // When the zone is stable initially, and when the option list changes...
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(firstStable, optionChanges)
                        .pipe(
                    // create a new stream of panelClosingActions, replacing any previous streams
                    // that were created, and flatten it so our stream only emits closing events...
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["switchMap"])(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var wasOpen = _this.panelOpen;
                        _this._resetActiveItem();
                        _this.autocomplete._setVisibility();
                        if (_this.panelOpen) {
                            ( /** @type {?} */(_this._overlayRef)).updatePosition();
                            // If the `panelOpen` state changed, we need to make sure to emit the `opened`
                            // event, because we may not have emitted it when the panel was attached. This
                            // can happen if the users opens the panel and there are no options, but the
                            // options come in slightly later or as a result of the value changing.
                            if (wasOpen !== _this.panelOpen) {
                                _this.autocomplete.opened.emit();
                            }
                        }
                        return _this.panelClosingActions;
                    })), 
                    // when the first closing event occurs...
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1))
                        // set the value, close the panel, and complete.
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return _this._setValueAndClose(event); }));
                };
                /**
                 * Destroys the autocomplete suggestion panel.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._destroyPanel = function () {
                    if (this._overlayRef) {
                        this.closePanel();
                        this._overlayRef.dispose();
                        this._overlayRef = null;
                    }
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {
                    /** @type {?} */
                    var toDisplay = this.autocomplete && this.autocomplete.displayWith ?
                        this.autocomplete.displayWith(value) :
                        value;
                    // Simply falling back to an empty string if the display value is falsy does not work properly.
                    // The display value can also be the number zero and shouldn't fall back to an empty string.
                    /** @type {?} */
                    var inputValue = toDisplay != null ? toDisplay : '';
                    // If it's used within a `MatFormField`, we should set it through the property so it can go
                    // through change detection.
                    if (this._formField) {
                        this._formField._control.value = inputValue;
                    }
                    else {
                        this._element.nativeElement.value = inputValue;
                    }
                    this._previousValue = inputValue;
                };
                /**
                 * This method closes the panel, and if a value is specified, also sets the associated
                 * control to that value. It will also mark the control as dirty if this interaction
                 * stemmed from the user.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {
                    if (event && event.source) {
                        this._clearPreviousSelectedOption(event.source);
                        this._setTriggerValue(event.source.value);
                        this._onChange(event.source.value);
                        this._element.nativeElement.focus();
                        this.autocomplete._emitSelectEvent(event.source);
                    }
                    this.closePanel();
                };
                /**
                 * Clear any previous selected option and emit a selection change event for this option
                 * @private
                 * @param {?} skip
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {
                    this.autocomplete.options.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) {
                        if (option != skip && option.selected) {
                            option.deselect();
                        }
                    }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._attachOverlay = function () {
                    var _this = this;
                    if (!this.autocomplete) {
                        throw getMatAutocompleteMissingPanelError();
                    }
                    /** @type {?} */
                    var overlayRef = this._overlayRef;
                    if (!overlayRef) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["TemplatePortal"](this.autocomplete.template, this._viewContainerRef);
                        overlayRef = this._overlay.create(this._getOverlayConfig());
                        this._overlayRef = overlayRef;
                        // Use the `keydownEvents` in order to take advantage of
                        // the overlay event targeting provided by the CDK overlay.
                        overlayRef.keydownEvents().subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                            if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"] || (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] && event.altKey)) {
                                _this._resetActiveItem();
                                _this._closeKeyEventStream.next();
                                // We need to stop propagation, otherwise the event will eventually
                                // reach the input itself and cause the overlay to be reopened.
                                event.stopPropagation();
                                event.preventDefault();
                            }
                        }));
                        if (this._viewportRuler) {
                            this._viewportSubscription = this._viewportRuler.change().subscribe(( /**
                             * @return {?}
                             */function () {
                                if (_this.panelOpen && overlayRef) {
                                    overlayRef.updateSize({ width: _this._getPanelWidth() });
                                }
                            }));
                        }
                    }
                    else {
                        // Update the trigger, panel width and direction, in case anything has changed.
                        this._positionStrategy.setOrigin(this._getConnectedElement());
                        overlayRef.updateSize({ width: this._getPanelWidth() });
                    }
                    if (overlayRef && !overlayRef.hasAttached()) {
                        overlayRef.attach(this._portal);
                        this._closingActionsSubscription = this._subscribeToClosingActions();
                    }
                    /** @type {?} */
                    var wasOpen = this.panelOpen;
                    this.autocomplete._setVisibility();
                    this.autocomplete._isOpen = this._overlayAttached = true;
                    // We need to do an extra `panelOpen` check in here, because the
                    // autocomplete won't be shown if there are no options.
                    if (this.panelOpen && wasOpen !== this.panelOpen) {
                        this.autocomplete.opened.emit();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOverlayConfig = function () {
                    return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayConfig"]({
                        positionStrategy: this._getOverlayPosition(),
                        scrollStrategy: this._scrollStrategy(),
                        width: this._getPanelWidth(),
                        direction: this._dir
                    });
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOverlayPosition = function () {
                    /** @type {?} */
                    var strategy = this._overlay.position()
                        .flexibleConnectedTo(this._getConnectedElement())
                        .withFlexibleDimensions(false)
                        .withPush(false);
                    this._setStrategyPositions(strategy);
                    this._positionStrategy = strategy;
                    return strategy;
                };
                /**
                 * Sets the positions on a position strategy based on the directive's input state.
                 * @private
                 * @param {?} positionStrategy
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {
                    /** @type {?} */
                    var belowPosition = {
                        originX: 'start',
                        originY: 'bottom',
                        overlayX: 'start',
                        overlayY: 'top'
                    };
                    /** @type {?} */
                    var abovePosition = {
                        originX: 'start',
                        originY: 'top',
                        overlayX: 'start',
                        overlayY: 'bottom',
                        // The overlay edge connected to the trigger should have squared corners, while
                        // the opposite end has rounded corners. We apply a CSS class to swap the
                        // border-radius based on the overlay position.
                        panelClass: 'mat-autocomplete-panel-above'
                    };
                    /** @type {?} */
                    var positions;
                    if (this.position === 'above') {
                        positions = [abovePosition];
                    }
                    else if (this.position === 'below') {
                        positions = [belowPosition];
                    }
                    else {
                        positions = [belowPosition, abovePosition];
                    }
                    positionStrategy.withPositions(positions);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getConnectedElement = function () {
                    if (this.connectedTo) {
                        return this.connectedTo.elementRef;
                    }
                    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getPanelWidth = function () {
                    return this.autocomplete.panelWidth || this._getHostWidth();
                };
                /**
                 * Returns the width of the input element, so the panel width can match it.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getHostWidth = function () {
                    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
                };
                /**
                 * Resets the active item to -1 so arrow events will activate the
                 * correct options, or to 0 if the consumer opted into it.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._resetActiveItem = function () {
                    this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);
                };
                /**
                 * Determines whether the panel can be opened.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._canOpen = function () {
                    /** @type {?} */
                    var element = this._element.nativeElement;
                    return !element.readOnly && !element.disabled && !this._autocompleteDisabled;
                };
                return MatAutocompleteTrigger;
            }());
            MatAutocompleteTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: "input[matAutocomplete], textarea[matAutocomplete]",
                            host: {
                                'class': 'mat-autocomplete-trigger',
                                '[attr.autocomplete]': 'autocompleteAttribute',
                                '[attr.role]': 'autocompleteDisabled ? null : "combobox"',
                                '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : "list"',
                                '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',
                                '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',
                                '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',
                                '[attr.aria-haspopup]': '!autocompleteDisabled',
                                // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                                // a little earlier. This avoids issues where IE delays the focusing of the input.
                                '(focusin)': '_handleFocus()',
                                '(blur)': '_onTouched()',
                                '(input)': '_handleInput($event)',
                                '(keydown)': '_handleKeydown($event)',
                            },
                            exportAs: 'matAutocompleteTrigger',
                            providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]
                        },] },
            ];
            /** @nocollapse */
            MatAutocompleteTrigger.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Host"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["DOCUMENT"],] }] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] }
            ]; };
            MatAutocompleteTrigger.propDecorators = {
                autocomplete: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocomplete',] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompletePosition',] }],
                connectedTo: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompleteConnectedTo',] }],
                autocompleteAttribute: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['autocomplete',] }],
                autocompleteDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompleteDisabled',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatAutocompleteModule = /** @class */ (function () {
                function MatAutocompleteModule() {
                }
                return MatAutocompleteModule;
            }());
            MatAutocompleteModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"]],
                            exports: [
                                MatAutocomplete,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionModule"],
                                MatAutocompleteTrigger,
                                MatAutocompleteOrigin,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]
                            ],
                            declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],
                            providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=autocomplete.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/badge.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/badge.js ***!
          \*********************************************************/
        /*! exports provided: MatBadgeModule, MatBadge */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBadgeModule", function () { return MatBadgeModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBadge", function () { return MatBadge; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var nextId = 0;
            // Boilerplate for applying mixins to MatBadge.
            /**
             * \@docs-private
             */
            var MatBadgeBase = /** @class */ (function () {
                function MatBadgeBase() {
                }
                return MatBadgeBase;
            }());
            /** @type {?} */
            var _MatBadgeMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatBadgeBase);
            /**
             * Directive to display a text badge.
             */
            var MatBadge = /** @class */ (function (_super) {
                __extends(MatBadge, _super);
                /**
                 * @param {?} _ngZone
                 * @param {?} _elementRef
                 * @param {?} _ariaDescriber
                 * @param {?} _renderer
                 * @param {?=} _animationMode
                 */
                function MatBadge(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {
                    var _this = _super.call(this) || this;
                    _this._ngZone = _ngZone;
                    _this._elementRef = _elementRef;
                    _this._ariaDescriber = _ariaDescriber;
                    _this._renderer = _renderer;
                    _this._animationMode = _animationMode;
                    /**
                     * Whether the badge has any content.
                     */
                    _this._hasContent = false;
                    _this._color = 'primary';
                    _this._overlap = true;
                    /**
                     * Position the badge should reside.
                     * Accepts any combination of 'above'|'below' and 'before'|'after'
                     */
                    _this.position = 'above after';
                    /**
                     * Size of the badge. Can be 'small', 'medium', or 'large'.
                     */
                    _this.size = 'medium';
                    /**
                     * Unique id for the badge
                     */
                    _this._id = nextId++;
                    if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["isDevMode"])()) {
                        /** @type {?} */
                        var nativeElement = _elementRef.nativeElement;
                        if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {
                            throw Error('matBadge must be attached to an element node.');
                        }
                    }
                    return _this;
                }
                Object.defineProperty(MatBadge.prototype, "color", {
                    /**
                     * The color of the badge. Can be `primary`, `accent`, or `warn`.
                     * @return {?}
                     */
                    get: function () { return this._color; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._setColor(value);
                        this._color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatBadge.prototype, "overlap", {
                    /**
                     * Whether the badge should overlap its contents or not
                     * @return {?}
                     */
                    get: function () { return this._overlap; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) {
                        this._overlap = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(val);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatBadge.prototype, "description", {
                    /**
                     * Message used to describe the decorated element via aria-describedby
                     * @return {?}
                     */
                    get: function () { return this._description; },
                    /**
                     * @param {?} newDescription
                     * @return {?}
                     */
                    set: function (newDescription) {
                        if (newDescription !== this._description) {
                            /** @type {?} */
                            var badgeElement = this._badgeElement;
                            this._updateHostAriaDescription(newDescription, this._description);
                            this._description = newDescription;
                            if (badgeElement) {
                                newDescription ? badgeElement.setAttribute('aria-label', newDescription) :
                                    badgeElement.removeAttribute('aria-label');
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatBadge.prototype, "hidden", {
                    /**
                     * Whether the badge is hidden.
                     * @return {?}
                     */
                    get: function () { return this._hidden; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) {
                        this._hidden = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(val);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether the badge is above the host or not
                 * @return {?}
                 */
                MatBadge.prototype.isAbove = function () {
                    return this.position.indexOf('below') === -1;
                };
                /**
                 * Whether the badge is after the host or not
                 * @return {?}
                 */
                MatBadge.prototype.isAfter = function () {
                    return this.position.indexOf('before') === -1;
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatBadge.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var contentChange = changes['content'];
                    if (contentChange) {
                        /** @type {?} */
                        var value = contentChange.currentValue;
                        this._hasContent = value != null && ("" + value).trim().length > 0;
                        this._updateTextContent();
                    }
                };
                /**
                 * @return {?}
                 */
                MatBadge.prototype.ngOnDestroy = function () {
                    /** @type {?} */
                    var badgeElement = this._badgeElement;
                    if (badgeElement) {
                        if (this.description) {
                            this._ariaDescriber.removeDescription(badgeElement, this.description);
                        }
                        // When creating a badge through the Renderer, Angular will keep it in an index.
                        // We have to destroy it ourselves, otherwise it'll be retained in memory.
                        if (this._renderer.destroyNode) {
                            this._renderer.destroyNode(badgeElement);
                        }
                    }
                };
                /**
                 * Gets the element into which the badge's content is being rendered.
                 * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).
                 * @return {?}
                 */
                MatBadge.prototype.getBadgeElement = function () {
                    return this._badgeElement;
                };
                /**
                 * Injects a span element into the DOM with the content.
                 * @private
                 * @return {?}
                 */
                MatBadge.prototype._updateTextContent = function () {
                    if (!this._badgeElement) {
                        this._badgeElement = this._createBadgeElement();
                    }
                    else {
                        this._badgeElement.textContent = this.content;
                    }
                    return this._badgeElement;
                };
                /**
                 * Creates the badge element
                 * @private
                 * @return {?}
                 */
                MatBadge.prototype._createBadgeElement = function () {
                    /** @type {?} */
                    var badgeElement = this._renderer.createElement('span');
                    /** @type {?} */
                    var activeClass = 'mat-badge-active';
                    /** @type {?} */
                    var contentClass = 'mat-badge-content';
                    // Clear any existing badges which may have persisted from a server-side render.
                    this._clearExistingBadges(contentClass);
                    badgeElement.setAttribute('id', "mat-badge-content-" + this._id);
                    badgeElement.classList.add(contentClass);
                    badgeElement.textContent = this.content;
                    if (this._animationMode === 'NoopAnimations') {
                        badgeElement.classList.add('_mat-animation-noopable');
                    }
                    if (this.description) {
                        badgeElement.setAttribute('aria-label', this.description);
                    }
                    this._elementRef.nativeElement.appendChild(badgeElement);
                    // animate in after insertion
                    if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () {
                                badgeElement.classList.add(activeClass);
                            }));
                        }));
                    }
                    else {
                        badgeElement.classList.add(activeClass);
                    }
                    return badgeElement;
                };
                /**
                 * Sets the aria-label property on the element
                 * @private
                 * @param {?} newDescription
                 * @param {?} oldDescription
                 * @return {?}
                 */
                MatBadge.prototype._updateHostAriaDescription = function (newDescription, oldDescription) {
                    // ensure content available before setting label
                    /** @type {?} */
                    var content = this._updateTextContent();
                    if (oldDescription) {
                        this._ariaDescriber.removeDescription(content, oldDescription);
                    }
                    if (newDescription) {
                        this._ariaDescriber.describe(content, newDescription);
                    }
                };
                /**
                 * Adds css theme class given the color to the component host
                 * @private
                 * @param {?} colorPalette
                 * @return {?}
                 */
                MatBadge.prototype._setColor = function (colorPalette) {
                    if (colorPalette !== this._color) {
                        if (this._color) {
                            this._elementRef.nativeElement.classList.remove("mat-badge-" + this._color);
                        }
                        if (colorPalette) {
                            this._elementRef.nativeElement.classList.add("mat-badge-" + colorPalette);
                        }
                    }
                };
                /**
                 * Clears any existing badges that might be left over from server-side rendering.
                 * @private
                 * @param {?} cssClass
                 * @return {?}
                 */
                MatBadge.prototype._clearExistingBadges = function (cssClass) {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var childCount = element.children.length;
                    // Use a reverse while, because we'll be removing elements from the list as we're iterating.
                    while (childCount--) {
                        /** @type {?} */
                        var currentChild = element.children[childCount];
                        if (currentChild.classList.contains(cssClass)) {
                            element.removeChild(currentChild);
                        }
                    }
                };
                return MatBadge;
            }(_MatBadgeMixinBase));
            MatBadge.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: '[matBadge]',
                            inputs: ['disabled: matBadgeDisabled'],
                            host: {
                                'class': 'mat-badge',
                                '[class.mat-badge-overlap]': 'overlap',
                                '[class.mat-badge-above]': 'isAbove()',
                                '[class.mat-badge-below]': '!isAbove()',
                                '[class.mat-badge-before]': '!isAfter()',
                                '[class.mat-badge-after]': 'isAfter()',
                                '[class.mat-badge-small]': 'size === "small"',
                                '[class.mat-badge-medium]': 'size === "medium"',
                                '[class.mat-badge-large]': 'size === "large"',
                                '[class.mat-badge-hidden]': 'hidden || !_hasContent',
                                '[class.mat-badge-disabled]': 'disabled',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatBadge.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["AriaDescriber"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Renderer2"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatBadge.propDecorators = {
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeColor',] }],
                overlap: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeOverlap',] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgePosition',] }],
                content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadge',] }],
                description: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeDescription',] }],
                size: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeSize',] }],
                hidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeHidden',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatBadgeModule = /** @class */ (function () {
                function MatBadgeModule() {
                }
                return MatBadgeModule;
            }());
            MatBadgeModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["A11yModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]
                            ],
                            exports: [MatBadge],
                            declarations: [MatBadge],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=badge.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/bottom-sheet.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/bottom-sheet.js ***!
          \****************************************************************/
        /*! exports provided: MatBottomSheetModule, MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, MatBottomSheet, MAT_BOTTOM_SHEET_DATA, MatBottomSheetConfig, MatBottomSheetContainer, matBottomSheetAnimations, MatBottomSheetRef */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetModule", function () { return MatBottomSheetModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BOTTOM_SHEET_DEFAULT_OPTIONS", function () { return MAT_BOTTOM_SHEET_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheet", function () { return MatBottomSheet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BOTTOM_SHEET_DATA", function () { return MAT_BOTTOM_SHEET_DATA; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetConfig", function () { return MatBottomSheetConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetContainer", function () { return MatBottomSheetContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matBottomSheetAnimations", function () { return matBottomSheetAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetRef", function () { return MatBottomSheetRef; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to access the data that was passed in to a bottom sheet.
             * @type {?}
             */
            var MAT_BOTTOM_SHEET_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MatBottomSheetData');
            /**
             * Configuration used when opening a bottom sheet.
             * @template D
             */
            var MatBottomSheetConfig = /** @class */ (function () {
                function MatBottomSheetConfig() {
                    /**
                     * Data being injected into the child component.
                     */
                    this.data = null;
                    /**
                     * Whether the bottom sheet has a backdrop.
                     */
                    this.hasBackdrop = true;
                    /**
                     * Whether the user can use escape or clicking outside to close the bottom sheet.
                     */
                    this.disableClose = false;
                    /**
                     * Aria label to assign to the bottom sheet element.
                     */
                    this.ariaLabel = null;
                    /**
                     * Whether the bottom sheet should close when the user goes backwards/forwards in history.
                     * Note that this usually doesn't include clicking on links (unless the user is using
                     * the `HashLocationStrategy`).
                     */
                    this.closeOnNavigation = true;
                    // Note that this is disabled by default, because while the a11y recommendations are to focus
                    // the first focusable element, doing so prevents screen readers from reading out the
                    // rest of the bottom sheet content.
                    /**
                     * Whether the bottom sheet should focus the first focusable element on open.
                     */
                    this.autoFocus = false;
                    /**
                     * Whether the bottom sheet should restore focus to the
                     * previously-focused element, after it's closed.
                     */
                    this.restoreFocus = true;
                }
                return MatBottomSheetConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material bottom sheet.
             * @type {?}
             */
            var matBottomSheetAnimations = {
                /**
                 * Animation that shows and hides a bottom sheet.
                 */
                bottomSheetState: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('state', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('void, hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'translateY(100%)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'translateY(0%)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('visible => void, visible => hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationDurations"].COMPLEX + " " + _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationCurves"].ACCELERATION_CURVE)),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('void => visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationDurations"].EXITING + " " + _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationCurves"].DECELERATION_CURVE)),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(crisbeto): consolidate some logic between this, MatDialog and MatSnackBar
            /**
             * Internal component that wraps user-provided bottom sheet content.
             * \@docs-private
             */
            var MatBottomSheetContainer = /** @class */ (function (_super) {
                __extends(MatBottomSheetContainer, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _focusTrapFactory
                 * @param {?} breakpointObserver
                 * @param {?} document
                 * @param {?} bottomSheetConfig
                 */
                function MatBottomSheetContainer(_elementRef, _changeDetectorRef, _focusTrapFactory, breakpointObserver, document, bottomSheetConfig) {
                    var _this = _super.call(this) || this;
                    _this._elementRef = _elementRef;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._focusTrapFactory = _focusTrapFactory;
                    _this.bottomSheetConfig = bottomSheetConfig;
                    /**
                     * The state of the bottom sheet animations.
                     */
                    _this._animationState = 'void';
                    /**
                     * Emits whenever the state of the animation changes.
                     */
                    _this._animationStateChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Element that was focused before the bottom sheet was opened.
                     */
                    _this._elementFocusedBeforeOpened = null;
                    _this._document = document;
                    _this._breakpointSubscription = breakpointObserver
                        .observe([_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Medium, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Large, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].XLarge])
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._toggleClass('mat-bottom-sheet-container-medium', breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Medium));
                        _this._toggleClass('mat-bottom-sheet-container-large', breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Large));
                        _this._toggleClass('mat-bottom-sheet-container-xlarge', breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].XLarge));
                    }));
                    return _this;
                }
                /**
                 * Attach a component portal as content to this bottom sheet container.
                 * @template T
                 * @param {?} portal
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.attachComponentPortal = function (portal) {
                    this._validatePortalAttached();
                    this._setPanelClass();
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachComponentPortal(portal);
                };
                /**
                 * Attach a template portal as content to this bottom sheet container.
                 * @template C
                 * @param {?} portal
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.attachTemplatePortal = function (portal) {
                    this._validatePortalAttached();
                    this._setPanelClass();
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachTemplatePortal(portal);
                };
                /**
                 * Begin animation of bottom sheet entrance into view.
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.enter = function () {
                    if (!this._destroyed) {
                        this._animationState = 'visible';
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Begin animation of the bottom sheet exiting from view.
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.exit = function () {
                    if (!this._destroyed) {
                        this._animationState = 'hidden';
                        this._changeDetectorRef.markForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.ngOnDestroy = function () {
                    this._breakpointSubscription.unsubscribe();
                    this._destroyed = true;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._onAnimationDone = function (event) {
                    if (event.toState === 'hidden') {
                        this._restoreFocus();
                    }
                    else if (event.toState === 'visible') {
                        this._trapFocus();
                    }
                    this._animationStateChanged.emit(event);
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._onAnimationStart = function (event) {
                    this._animationStateChanged.emit(event);
                };
                /**
                 * @private
                 * @param {?} cssClass
                 * @param {?} add
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._toggleClass = function (cssClass, add) {
                    /** @type {?} */
                    var classList = this._elementRef.nativeElement.classList;
                    add ? classList.add(cssClass) : classList.remove(cssClass);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._validatePortalAttached = function () {
                    if (this._portalOutlet.hasAttached()) {
                        throw Error('Attempting to attach bottom sheet content after content is already attached');
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._setPanelClass = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var panelClass = this.bottomSheetConfig.panelClass;
                    if (Array.isArray(panelClass)) {
                        // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                        panelClass.forEach(( /**
                         * @param {?} cssClass
                         * @return {?}
                         */function (/**
                         * @param {?} cssClass
                         * @return {?}
                         */ cssClass) { return element.classList.add(cssClass); }));
                    }
                    else if (panelClass) {
                        element.classList.add(panelClass);
                    }
                };
                /**
                 * Moves the focus inside the focus trap.
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._trapFocus = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (!this._focusTrap) {
                        this._focusTrap = this._focusTrapFactory.create(element);
                    }
                    if (this.bottomSheetConfig.autoFocus) {
                        this._focusTrap.focusInitialElementWhenReady();
                    }
                    else {
                        /** @type {?} */
                        var activeElement = this._document.activeElement;
                        // Otherwise ensure that focus is on the container. It's possible that a different
                        // component tried to move focus while the open animation was running. See:
                        // https://github.com/angular/components/issues/16215. Note that we only want to do this
                        // if the focus isn't inside the bottom sheet already, because it's possible that the
                        // consumer turned off `autoFocus` in order to move focus themselves.
                        if (activeElement !== element && !element.contains(activeElement)) {
                            element.focus();
                        }
                    }
                };
                /**
                 * Restores focus to the element that was focused before the bottom sheet was opened.
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._restoreFocus = function () {
                    /** @type {?} */
                    var toFocus = this._elementFocusedBeforeOpened;
                    // We need the extra check, because IE can set the `activeElement` to null in some cases.
                    if (this.bottomSheetConfig.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                        toFocus.focus();
                    }
                    if (this._focusTrap) {
                        this._focusTrap.destroy();
                    }
                };
                /**
                 * Saves a reference to the element that was focused before the bottom sheet was opened.
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._savePreviouslyFocusedElement = function () {
                    var _this = this;
                    this._elementFocusedBeforeOpened = ( /** @type {?} */(this._document.activeElement));
                    // The `focus` method isn't available during server-side rendering.
                    if (this._elementRef.nativeElement.focus) {
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () { return _this._elementRef.nativeElement.focus(); }));
                    }
                };
                return MatBottomSheetContainer;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["BasePortalOutlet"]));
            MatBottomSheetContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-bottom-sheet-container',
                            template: "<ng-template cdkPortalOutlet></ng-template>",
                            styles: [".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}@media (-ms-high-contrast:active){.mat-bottom-sheet-container{outline:1px solid}}.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium,.mat-bottom-sheet-container-xlarge{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            animations: [matBottomSheetAnimations.bottomSheetState],
                            host: {
                                'class': 'mat-bottom-sheet-container',
                                'tabindex': '-1',
                                'role': 'dialog',
                                'aria-modal': 'true',
                                '[attr.aria-label]': 'bottomSheetConfig?.ariaLabel',
                                '[@state]': '_animationState',
                                '(@state.start)': '_onAnimationStart($event)',
                                '(@state.done)': '_onAnimationDone($event)'
                            },
                        },] },
            ];
            /** @nocollapse */
            MatBottomSheetContainer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__["FocusTrapFactory"] },
                { type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["BreakpointObserver"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] },
                { type: MatBottomSheetConfig }
            ]; };
            MatBottomSheetContainer.propDecorators = {
                _portalOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["CdkPortalOutlet"], { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatBottomSheetModule = /** @class */ (function () {
                function MatBottomSheetModule() {
                }
                return MatBottomSheetModule;
            }());
            MatBottomSheetModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["OverlayModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalModule"],
                            ],
                            exports: [MatBottomSheetContainer, _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"]],
                            declarations: [MatBottomSheetContainer],
                            entryComponents: [MatBottomSheetContainer],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Reference to a bottom sheet dispatched from the bottom sheet service.
             * @template T, R
             */
            var MatBottomSheetRef = /** @class */ (function () {
                /**
                 * @param {?} containerInstance
                 * @param {?} _overlayRef
                 * @param {?=} _location
                 */
                function MatBottomSheetRef(containerInstance, _overlayRef, 
                // @breaking-change 8.0.0 `_location` parameter to be removed.
                _location) {
                    var _this = this;
                    this._overlayRef = _overlayRef;
                    /**
                     * Subject for notifying the user that the bottom sheet has been dismissed.
                     */
                    this._afterDismissed = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Subject for notifying the user that the bottom sheet has opened and appeared.
                     */
                    this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    this.containerInstance = containerInstance;
                    this.disableClose = containerInstance.bottomSheetConfig.disableClose;
                    // Emit when opening animation completes
                    containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'done' && event.toState === 'visible'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._afterOpened.next();
                        _this._afterOpened.complete();
                    }));
                    // Dispose overlay when closing animation is complete
                    containerInstance._animationStateChanged
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return event.phaseName === 'done' && event.toState === 'hidden'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        clearTimeout(_this._closeFallbackTimeout);
                        _overlayRef.dispose();
                    }));
                    _overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._afterDismissed.next(_this._result);
                        _this._afterDismissed.complete();
                    }));
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"])(_overlayRef.backdropClick(), _overlayRef.keydownEvents().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["ESCAPE"]; })))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (!_this.disableClose &&
                            (event.type !== 'keydown' || !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["hasModifierKey"])(( /** @type {?} */(event))))) {
                            event.preventDefault();
                            _this.dismiss();
                        }
                    }));
                }
                /**
                 * Dismisses the bottom sheet.
                 * @param {?=} result Data to be passed back to the bottom sheet opener.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.dismiss = function (result) {
                    var _this = this;
                    if (!this._afterDismissed.closed) {
                        // Transition the backdrop in parallel to the bottom sheet.
                        this.containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event.phaseName === 'start'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            // The logic that disposes of the overlay depends on the exit animation completing, however
                            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
                            // timeout which will clean everything up if the animation hasn't fired within the specified
                            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
                            // vast majority of cases the timeout will have been cleared before it has fired.
                            _this._closeFallbackTimeout = setTimeout(( /**
                             * @return {?}
                             */function () {
                                _this._overlayRef.dispose();
                            }), event.totalTime + 100);
                            _this._overlayRef.detachBackdrop();
                        }));
                        this._result = result;
                        this.containerInstance.exit();
                    }
                };
                /**
                 * Gets an observable that is notified when the bottom sheet is finished closing.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.afterDismissed = function () {
                    return this._afterDismissed.asObservable();
                };
                /**
                 * Gets an observable that is notified when the bottom sheet has opened and appeared.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.afterOpened = function () {
                    return this._afterOpened.asObservable();
                };
                /**
                 * Gets an observable that emits when the overlay's backdrop has been clicked.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.backdropClick = function () {
                    return this._overlayRef.backdropClick();
                };
                /**
                 * Gets an observable that emits when keydown events are targeted on the overlay.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.keydownEvents = function () {
                    return this._overlayRef.keydownEvents();
                };
                return MatBottomSheetRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify default bottom sheet options.
             * @type {?}
             */
            var MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-bottom-sheet-default-options');
            /**
             * Service to trigger Material Design bottom sheets.
             */
            var MatBottomSheet = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _injector
                 * @param {?} _parentBottomSheet
                 * @param {?=} _location
                 * @param {?=} _defaultOptions
                 */
                function MatBottomSheet(_overlay, _injector, _parentBottomSheet, _location, _defaultOptions) {
                    this._overlay = _overlay;
                    this._injector = _injector;
                    this._parentBottomSheet = _parentBottomSheet;
                    this._location = _location;
                    this._defaultOptions = _defaultOptions;
                    this._bottomSheetRefAtThisLevel = null;
                }
                Object.defineProperty(MatBottomSheet.prototype, "_openedBottomSheetRef", {
                    /**
                     * Reference to the currently opened bottom sheet.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var parent = this._parentBottomSheet;
                        return parent ? parent._openedBottomSheetRef : this._bottomSheetRefAtThisLevel;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._parentBottomSheet) {
                            this._parentBottomSheet._openedBottomSheetRef = value;
                        }
                        else {
                            this._bottomSheetRefAtThisLevel = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @template T, D, R
                 * @param {?} componentOrTemplateRef
                 * @param {?=} config
                 * @return {?}
                 */
                MatBottomSheet.prototype.open = function (componentOrTemplateRef, config) {
                    var _this = this;
                    /** @type {?} */
                    var _config = _applyConfigDefaults(this._defaultOptions || new MatBottomSheetConfig(), config);
                    /** @type {?} */
                    var overlayRef = this._createOverlay(_config);
                    /** @type {?} */
                    var container = this._attachContainer(overlayRef, _config);
                    /** @type {?} */
                    var ref = new MatBottomSheetRef(container, overlayRef, this._location);
                    if (componentOrTemplateRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]) {
                        container.attachTemplatePortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["TemplatePortal"](componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({
                            $implicit: _config.data,
                            bottomSheetRef: ref
                        }))));
                    }
                    else {
                        /** @type {?} */
                        var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](componentOrTemplateRef, undefined, this._createInjector(_config, ref));
                        /** @type {?} */
                        var contentRef = container.attachComponentPortal(portal);
                        ref.instance = contentRef.instance;
                    }
                    // When the bottom sheet is dismissed, clear the reference to it.
                    ref.afterDismissed().subscribe(( /**
                     * @return {?}
                     */function () {
                        // Clear the bottom sheet ref if it hasn't already been replaced by a newer one.
                        if (_this._openedBottomSheetRef == ref) {
                            _this._openedBottomSheetRef = null;
                        }
                    }));
                    if (this._openedBottomSheetRef) {
                        // If a bottom sheet is already in view, dismiss it and enter the
                        // new bottom sheet after exit animation is complete.
                        this._openedBottomSheetRef.afterDismissed().subscribe(( /**
                         * @return {?}
                         */function () { return ref.containerInstance.enter(); }));
                        this._openedBottomSheetRef.dismiss();
                    }
                    else {
                        // If no bottom sheet is in view, enter the new bottom sheet.
                        ref.containerInstance.enter();
                    }
                    this._openedBottomSheetRef = ref;
                    return ref;
                };
                /**
                 * Dismisses the currently-visible bottom sheet.
                 * @return {?}
                 */
                MatBottomSheet.prototype.dismiss = function () {
                    if (this._openedBottomSheetRef) {
                        this._openedBottomSheetRef.dismiss();
                    }
                };
                /**
                 * @return {?}
                 */
                MatBottomSheet.prototype.ngOnDestroy = function () {
                    if (this._bottomSheetRefAtThisLevel) {
                        this._bottomSheetRefAtThisLevel.dismiss();
                    }
                };
                /**
                 * Attaches the bottom sheet container component to the overlay.
                 * @private
                 * @param {?} overlayRef
                 * @param {?} config
                 * @return {?}
                 */
                MatBottomSheet.prototype._attachContainer = function (overlayRef, config) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injector = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatBottomSheetConfig, config]
                    ]));
                    /** @type {?} */
                    var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](MatBottomSheetContainer, config.viewContainerRef, injector);
                    /** @type {?} */
                    var containerRef = overlayRef.attach(containerPortal);
                    return containerRef.instance;
                };
                /**
                 * Creates a new overlay and places it in the correct location.
                 * @private
                 * @param {?} config The user-specified bottom sheet config.
                 * @return {?}
                 */
                MatBottomSheet.prototype._createOverlay = function (config) {
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["OverlayConfig"]({
                        direction: config.direction,
                        hasBackdrop: config.hasBackdrop,
                        disposeOnNavigation: config.closeOnNavigation,
                        maxWidth: '100%',
                        scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(),
                        positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0')
                    });
                    if (config.backdropClass) {
                        overlayConfig.backdropClass = config.backdropClass;
                    }
                    return this._overlay.create(overlayConfig);
                };
                /**
                 * Creates an injector to be used inside of a bottom sheet component.
                 * @private
                 * @template T
                 * @param {?} config Config that was used to create the bottom sheet.
                 * @param {?} bottomSheetRef Reference to the bottom sheet.
                 * @return {?}
                 */
                MatBottomSheet.prototype._createInjector = function (config, bottomSheetRef) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injectionTokens = new WeakMap([
                        [MatBottomSheetRef, bottomSheetRef],
                        [MAT_BOTTOM_SHEET_DATA, config.data]
                    ]);
                    if (config.direction &&
                        (!userInjector || !userInjector.get(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__["Directionality"], null))) {
                        injectionTokens.set(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__["Directionality"], {
                            value: config.direction,
                            change: Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["of"])()
                        });
                    }
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, injectionTokens);
                };
                return MatBottomSheet;
            }());
            MatBottomSheet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: MatBottomSheetModule },] },
            ];
            /** @nocollapse */
            MatBottomSheet.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"] },
                { type: MatBottomSheet, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_5__["Location"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: MatBottomSheetConfig, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_BOTTOM_SHEET_DEFAULT_OPTIONS,] }] }
            ]; };
            /** @nocollapse */ MatBottomSheet.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatBottomSheet_Factory() { return new MatBottomSheet(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["Overlay"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MatBottomSheet, 12), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_5__["Location"], 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, 8)); }, token: MatBottomSheet, providedIn: MatBottomSheetModule });
            /**
             * Applies default options to the bottom sheet config.
             * @param {?} defaults Object containing the default values to which to fall back.
             * @param {?=} config The configuration to which the defaults will be applied.
             * @return {?} The new configuration object with defaults applied.
             */
            function _applyConfigDefaults(defaults, config) {
                return Object.assign({}, defaults, config);
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=bottom-sheet.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/button-toggle.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/button-toggle.js ***!
          \*****************************************************************/
        /*! exports provided: MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, MatButtonToggleGroupMultiple, MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle, MatButtonToggleModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS", function () { return MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR", function () { return MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroupMultiple", function () { return MatButtonToggleGroupMultiple; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleChange", function () { return MatButtonToggleChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroup", function () { return MatButtonToggleGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggle", function () { return MatButtonToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleModule", function () { return MatButtonToggleModule; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to configure the
             * default options for all button toggles within an app.
             * @type {?}
             */
            var MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS');
            /**
             * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)].
             * \@docs-private
             * @type {?}
             */
            var MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatButtonToggleGroup; })),
                multi: true
            };
            /**
             * @deprecated Use `MatButtonToggleGroup` instead.
             * \@breaking-change 8.0.0
             */
            var MatButtonToggleGroupMultiple = /** @class */ (function () {
                function MatButtonToggleGroupMultiple() {
                }
                return MatButtonToggleGroupMultiple;
            }());
            /** @type {?} */
            var _uniqueIdCounter = 0;
            /**
             * Change event object emitted by MatButtonToggle.
             */
            var MatButtonToggleChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatButtonToggleChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatButtonToggleChange;
            }());
            /**
             * Exclusive selection button toggle group that behaves like a radio-button group.
             */
            var MatButtonToggleGroup = /** @class */ (function () {
                /**
                 * @param {?} _changeDetector
                 * @param {?=} defaultOptions
                 */
                function MatButtonToggleGroup(_changeDetector, defaultOptions) {
                    this._changeDetector = _changeDetector;
                    this._vertical = false;
                    this._multiple = false;
                    this._disabled = false;
                    /**
                     * The method to be called in order to update ngModel.
                     * Now `ngModel` binding is not supported in multiple selection mode.
                     */
                    this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     */
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    this._name = "mat-button-toggle-group-" + _uniqueIdCounter++;
                    /**
                     * Event that emits whenever the value of the group changes.
                     * Used to facilitate two-way data binding.
                     * \@docs-private
                     */
                    this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the group's value changes.
                     */
                    this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    this.appearance =
                        defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
                }
                Object.defineProperty(MatButtonToggleGroup.prototype, "name", {
                    /**
                     * `name` attribute for the underlying `input` element.
                     * @return {?}
                     */
                    get: function () { return this._name; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        this._name = value;
                        if (this._buttonToggles) {
                            this._buttonToggles.forEach(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) {
                                toggle.name = _this._name;
                                toggle._markForCheck();
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "vertical", {
                    /**
                     * Whether the toggle group is vertical.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "value", {
                    /**
                     * Value of the toggle group.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var selected = this._selectionModel ? this._selectionModel.selected : [];
                        if (this.multiple) {
                            return selected.map(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) { return toggle.value; }));
                        }
                        return selected[0] ? selected[0].value : undefined;
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        this._setSelectionByValue(newValue);
                        this.valueChange.emit(this.value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "selected", {
                    /**
                     * Selected button toggles in the group.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var selected = this._selectionModel ? this._selectionModel.selected : [];
                        return this.multiple ? selected : (selected[0] || null);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "multiple", {
                    /**
                     * Whether multiple button toggles can be selected.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "disabled", {
                    /**
                     * Whether multiple button toggle group is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._buttonToggles) {
                            this._buttonToggles.forEach(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) { return toggle._markForCheck(); }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.ngOnInit = function () {
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__["SelectionModel"](this.multiple, undefined, false);
                };
                /**
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.ngAfterContentInit = function () {
                    var _a;
                    (_a = this._selectionModel).select.apply(_a, this._buttonToggles.filter(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) { return toggle.checked; })));
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value Value to be set to the model.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.writeValue = function (value) {
                    this.value = value;
                    this._changeDetector.markForCheck();
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * Dispatch change event with current selection and group value.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._emitChangeEvent = function () {
                    /** @type {?} */
                    var selected = this.selected;
                    /** @type {?} */
                    var source = Array.isArray(selected) ? selected[selected.length - 1] : selected;
                    /** @type {?} */
                    var event = new MatButtonToggleChange(( /** @type {?} */(source)), this.value);
                    this._controlValueAccessorChangeFn(event.value);
                    this.change.emit(event);
                };
                /**
                 * Syncs a button toggle's selected state with the model value.
                 * @param {?} toggle Toggle to be synced.
                 * @param {?} select Whether the toggle should be selected.
                 * @param {?=} isUserInput Whether the change was a result of a user interaction.
                 * @param {?=} deferEvents Whether to defer emitting the change events.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._syncButtonToggle = function (toggle, select, isUserInput, deferEvents) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    if (deferEvents === void 0) { deferEvents = false; }
                    // Deselect the currently-selected toggle, if we're in single-selection
                    // mode and the button being toggled isn't selected at the moment.
                    if (!this.multiple && this.selected && !toggle.checked) {
                        (( /** @type {?} */(this.selected))).checked = false;
                    }
                    if (this._selectionModel) {
                        if (select) {
                            this._selectionModel.select(toggle);
                        }
                        else {
                            this._selectionModel.deselect(toggle);
                        }
                    }
                    else {
                        deferEvents = true;
                    }
                    // We need to defer in some cases in order to avoid "changed after checked errors", however
                    // the side-effect is that we may end up updating the model value out of sequence in others
                    // The `deferEvents` flag allows us to decide whether to do it on a case-by-case basis.
                    if (deferEvents) {
                    }
                    else {
                        this._updateModelValue(isUserInput);
                    }
                };
                /**
                 * Checks whether a button toggle is selected.
                 * @param {?} toggle
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._isSelected = function (toggle) {
                    return this._selectionModel && this._selectionModel.isSelected(toggle);
                };
                /**
                 * Determines whether a button toggle should be checked on init.
                 * @param {?} toggle
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._isPrechecked = function (toggle) {
                    if (typeof this._rawValue === 'undefined') {
                        return false;
                    }
                    if (this.multiple && Array.isArray(this._rawValue)) {
                        return this._rawValue.some(( /**
                         * @param {?} value
                         * @return {?}
                         */function (/**
                         * @param {?} value
                         * @return {?}
                         */ value) { return toggle.value != null && value === toggle.value; }));
                    }
                    return toggle.value === this._rawValue;
                };
                /**
                 * Updates the selection state of the toggles in the group based on a value.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._setSelectionByValue = function (value) {
                    var _this = this;
                    this._rawValue = value;
                    if (!this._buttonToggles) {
                        return;
                    }
                    if (this.multiple && value) {
                        if (!Array.isArray(value)) {
                            throw Error('Value must be an array in multiple-selection mode.');
                        }
                        this._clearSelection();
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (currentValue) { return _this._selectValue(currentValue); }));
                    }
                    else {
                        this._clearSelection();
                        this._selectValue(value);
                    }
                };
                /**
                 * Clears the selected toggles.
                 * @private
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._clearSelection = function () {
                    this._selectionModel.clear();
                    this._buttonToggles.forEach(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) { return toggle.checked = false; }));
                };
                /**
                 * Selects a value if there's a toggle that corresponds to it.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._selectValue = function (value) {
                    /** @type {?} */
                    var correspondingOption = this._buttonToggles.find(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) {
                        return toggle.value != null && toggle.value === value;
                    }));
                    if (correspondingOption) {
                        correspondingOption.checked = true;
                        this._selectionModel.select(correspondingOption);
                    }
                };
                /**
                 * Syncs up the group's value with the model and emits the change event.
                 * @private
                 * @param {?} isUserInput
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._updateModelValue = function (isUserInput) {
                    // Only emit the change event for user input.
                    if (isUserInput) {
                        this._emitChangeEvent();
                    }
                    // Note: we emit this one no matter whether it was a user interaction, because
                    // it is used by Angular to sync up the two-way data binding.
                    this.valueChange.emit(this.value);
                };
                return MatButtonToggleGroup;
            }());
            MatButtonToggleGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-button-toggle-group',
                            providers: [
                                MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,
                                { provide: MatButtonToggleGroupMultiple, useExisting: MatButtonToggleGroup },
                            ],
                            host: {
                                'role': 'group',
                                'class': 'mat-button-toggle-group',
                                '[attr.aria-disabled]': 'disabled',
                                '[class.mat-button-toggle-vertical]': 'vertical',
                                '[class.mat-button-toggle-group-appearance-standard]': 'appearance === "standard"',
                            },
                            exportAs: 'matButtonToggleGroup',
                        },] },
            ];
            /** @nocollapse */
            MatButtonToggleGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatButtonToggleGroup.propDecorators = {
                _buttonToggles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatButtonToggle; })),] }],
                appearance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            // Boilerplate for applying mixins to the MatButtonToggle class.
            /**
             * \@docs-private
             */
            var MatButtonToggleBase = /** @class */ (function () {
                function MatButtonToggleBase() {
                }
                return MatButtonToggleBase;
            }());
            /** @type {?} */
            var _MatButtonToggleMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(MatButtonToggleBase);
            /**
             * Single button inside of a toggle group.
             */
            var MatButtonToggle = /** @class */ (function (_super) {
                __extends(MatButtonToggle, _super);
                /**
                 * @param {?} toggleGroup
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} _focusMonitor
                 * @param {?} defaultTabIndex
                 * @param {?=} defaultOptions
                 */
                function MatButtonToggle(toggleGroup, _changeDetectorRef, _elementRef, _focusMonitor, 
                // @breaking-change 8.0.0 `defaultTabIndex` to be made a required parameter.
                defaultTabIndex, defaultOptions) {
                    var _this = _super.call(this) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._elementRef = _elementRef;
                    _this._focusMonitor = _focusMonitor;
                    _this._isSingleSelector = false;
                    _this._checked = false;
                    /**
                     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
                     */
                    _this.ariaLabelledby = null;
                    _this._disabled = false;
                    /**
                     * Event emitted when the group value changes.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /** @type {?} */
                    var parsedTabIndex = Number(defaultTabIndex);
                    _this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
                    _this.buttonToggleGroup = toggleGroup;
                    _this.appearance =
                        defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
                    return _this;
                }
                Object.defineProperty(MatButtonToggle.prototype, "buttonId", {
                    /**
                     * Unique ID for the underlying `button` element.
                     * @return {?}
                     */
                    get: function () { return this.id + "-button"; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "appearance", {
                    /**
                     * The appearance style of the button.
                     * @return {?}
                     */
                    get: function () {
                        return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._appearance = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "checked", {
                    /**
                     * Whether the button is checked.
                     * @return {?}
                     */
                    get: function () {
                        return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (newValue !== this._checked) {
                            this._checked = newValue;
                            if (this.buttonToggleGroup) {
                                this.buttonToggleGroup._syncButtonToggle(this, this._checked);
                            }
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "disabled", {
                    /**
                     * Whether the button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatButtonToggle.prototype.ngOnInit = function () {
                    this._isSingleSelector = this.buttonToggleGroup && !this.buttonToggleGroup.multiple;
                    this._type = this._isSingleSelector ? 'radio' : 'checkbox';
                    this.id = this.id || "mat-button-toggle-" + _uniqueIdCounter++;
                    if (this._isSingleSelector) {
                        this.name = this.buttonToggleGroup.name;
                    }
                    if (this.buttonToggleGroup && this.buttonToggleGroup._isPrechecked(this)) {
                        this.checked = true;
                    }
                    this._focusMonitor.monitor(this._elementRef, true);
                };
                /**
                 * @return {?}
                 */
                MatButtonToggle.prototype.ngOnDestroy = function () {
                    /** @type {?} */
                    var group = this.buttonToggleGroup;
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    // Remove the toggle from the selection once it's destroyed. Needs to happen
                    // on the next tick in order to avoid "changed after checked" errors.
                    if (group && group._isSelected(this)) {
                        group._syncButtonToggle(this, false, false, true);
                    }
                };
                /**
                 * Focuses the button.
                 * @param {?=} options
                 * @return {?}
                 */
                MatButtonToggle.prototype.focus = function (options) {
                    this._buttonElement.nativeElement.focus(options);
                };
                /**
                 * Checks the button toggle due to an interaction with the underlying native button.
                 * @return {?}
                 */
                MatButtonToggle.prototype._onButtonClick = function () {
                    /** @type {?} */
                    var newChecked = this._isSingleSelector ? true : !this._checked;
                    if (newChecked !== this._checked) {
                        this._checked = newChecked;
                        if (this.buttonToggleGroup) {
                            this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);
                            this.buttonToggleGroup._onTouched();
                        }
                    }
                    // Emit a change event when it's the single selector
                    this.change.emit(new MatButtonToggleChange(this, this.value));
                };
                /**
                 * Marks the button toggle as needing checking for change detection.
                 * This method is exposed because the parent button toggle group will directly
                 * update bound properties of the radio button.
                 * @return {?}
                 */
                MatButtonToggle.prototype._markForCheck = function () {
                    // When the group value changes, the button will not be notified.
                    // Use `markForCheck` to explicit update button toggle's status.
                    this._changeDetectorRef.markForCheck();
                };
                return MatButtonToggle;
            }(_MatButtonToggleMixinBase));
            MatButtonToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-button-toggle',
                            template: "<button #button class=\"mat-button-toggle-button\" type=\"button\" [id]=\"buttonId\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [attr.aria-pressed]=\"checked\" [disabled]=\"disabled || null\" [attr.name]=\"name || null\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (click)=\"_onButtonClick()\"><div class=\"mat-button-toggle-label-content\"><ng-content></ng-content></div></button><div class=\"mat-button-toggle-focus-overlay\"></div><div class=\"mat-button-toggle-ripple\" matRipple [matRippleTrigger]=\"button\" [matRippleDisabled]=\"this.disableRipple || this.disabled\"></div>",
                            styles: [".mat-button-toggle-group,.mat-button-toggle-standalone{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;border-radius:2px;-webkit-tap-highlight-color:transparent}@media (-ms-high-contrast:active){.mat-button-toggle-group,.mat-button-toggle-standalone{outline:solid 1px}}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border-radius:4px}@media (-ms-high-contrast:active){.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{outline:0}}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}@media (-ms-high-contrast:active){.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:.5}}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:.04}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.12}@media (-ms-high-contrast:active){.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.5}}@media (hover:none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px;padding:0 12px}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;top:0;left:0;right:0;bottom:0;position:absolute}.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 36px}@media (-ms-high-contrast:active){.mat-button-toggle-checked .mat-button-toggle-focus-overlay{opacity:.5;height:0}}@media (-ms-high-contrast:active){.mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 48px}}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:0 0;color:inherit;padding:0;margin:0;font:inherit;outline:0;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matButtonToggle',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disableRipple'],
                            host: {
                                '[class.mat-button-toggle-standalone]': '!buttonToggleGroup',
                                '[class.mat-button-toggle-checked]': 'checked',
                                '[class.mat-button-toggle-disabled]': 'disabled',
                                '[class.mat-button-toggle-appearance-standard]': 'appearance === "standard"',
                                'class': 'mat-button-toggle',
                                // Always reset the tabindex to -1 so it doesn't conflict with the one on the `button`,
                                // but can still receive focus from things like cdkFocusInitial.
                                '[attr.tabindex]': '-1',
                                '[attr.id]': 'id',
                                '[attr.name]': 'null',
                                '(focus)': 'focus()',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatButtonToggle.ctorParameters = function () { return [
                { type: MatButtonToggleGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatButtonToggle.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-labelledby',] }],
                _buttonElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: ['button', { static: false },] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                appearance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatButtonToggleModule = /** @class */ (function () {
                function MatButtonToggleModule() {
                }
                return MatButtonToggleModule;
            }());
            MatButtonToggleModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"]],
                            exports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"], MatButtonToggleGroup, MatButtonToggle],
                            declarations: [MatButtonToggleGroup, MatButtonToggle],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=button-toggle.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/button.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/button.js ***!
          \**********************************************************/
        /*! exports provided: MatButtonModule, MatButton, MatAnchor */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonModule", function () { return MatButtonModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButton", function () { return MatButton; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAnchor", function () { return MatAnchor; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Default color palette for round buttons (mat-fab and mat-mini-fab)
             * @type {?}
             */
            var DEFAULT_ROUND_BUTTON_COLOR = 'accent';
            /**
             * List of classes to add to MatButton instances based on host attributes to
             * style as different variants.
             * @type {?}
             */
            var BUTTON_HOST_ATTRIBUTES = [
                'mat-button',
                'mat-flat-button',
                'mat-icon-button',
                'mat-raised-button',
                'mat-stroked-button',
                'mat-mini-fab',
                'mat-fab',
            ];
            // Boilerplate for applying mixins to MatButton.
            /**
             * \@docs-private
             */
            var MatButtonBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatButtonBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatButtonBase;
            }());
            /** @type {?} */
            var _MatButtonMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisabled"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisableRipple"])(MatButtonBase)));
            /**
             * Material design button.
             */
            var MatButton = /** @class */ (function (_super) {
                __extends(MatButton, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _animationMode
                 */
                function MatButton(elementRef, _focusMonitor, _animationMode) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._focusMonitor = _focusMonitor;
                    _this._animationMode = _animationMode;
                    /**
                     * Whether the button is round.
                     */
                    _this.isRoundButton = _this._hasHostAttributes('mat-fab', 'mat-mini-fab');
                    /**
                     * Whether the button is icon button.
                     */
                    _this.isIconButton = _this._hasHostAttributes('mat-icon-button');
                    // For each of the variant selectors that is present in the button's host
                    // attributes, add the correct corresponding class.
                    for (var _a = 0, BUTTON_HOST_ATTRIBUTES_1 = BUTTON_HOST_ATTRIBUTES; _a < BUTTON_HOST_ATTRIBUTES_1.length; _a++) {
                        var attr = BUTTON_HOST_ATTRIBUTES_1[_a];
                        if (_this._hasHostAttributes(attr)) {
                            (( /** @type {?} */(_this._getHostElement()))).classList.add(attr);
                        }
                    }
                    // Add a class that applies to all buttons. This makes it easier to target if somebody
                    // wants to target all Material buttons. We do it here rather than `host` to ensure that
                    // the class is applied to derived classes.
                    elementRef.nativeElement.classList.add('mat-button-base');
                    _this._focusMonitor.monitor(_this._elementRef, true);
                    if (_this.isRoundButton) {
                        _this.color = DEFAULT_ROUND_BUTTON_COLOR;
                    }
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatButton.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Focuses the button.
                 * @param {?=} origin
                 * @param {?=} options
                 * @return {?}
                 */
                MatButton.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    this._focusMonitor.focusVia(this._getHostElement(), origin, options);
                };
                /**
                 * @return {?}
                 */
                MatButton.prototype._getHostElement = function () {
                    return this._elementRef.nativeElement;
                };
                /**
                 * @return {?}
                 */
                MatButton.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * Gets whether the button has one of the given attributes.
                 * @param {...?} attributes
                 * @return {?}
                 */
                MatButton.prototype._hasHostAttributes = function () {
                    var _this = this;
                    var attributes = [];
                    for (var _a = 0; _a < arguments.length; _a++) {
                        attributes[_a] = arguments[_a];
                    }
                    return attributes.some(( /**
                     * @param {?} attribute
                     * @return {?}
                     */function (/**
                     * @param {?} attribute
                     * @return {?}
                     */ attribute) { return _this._getHostElement().hasAttribute(attribute); }));
                };
                return MatButton;
            }(_MatButtonMixinBase));
            MatButton.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],\n             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],\n             button[mat-flat-button]",
                            exportAs: 'matButton',
                            host: {
                                '[attr.disabled]': 'disabled || null',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            },
                            template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div matRipple class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"isRoundButton || isIconButton\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"isIconButton\" [matRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\"></div>",
                            styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
                            inputs: ['disabled', 'disableRipple', 'color'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatButton.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_3__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatButton.propDecorators = {
                ripple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatRipple"], { static: false },] }]
            };
            /**
             * Material design anchor button.
             */
            var MatAnchor = /** @class */ (function (_super) {
                __extends(MatAnchor, _super);
                /**
                 * @param {?} focusMonitor
                 * @param {?} elementRef
                 * @param {?} animationMode
                 */
                function MatAnchor(focusMonitor, elementRef, animationMode) {
                    return _super.call(this, elementRef, focusMonitor, animationMode) || this;
                }
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAnchor.prototype._haltDisabledEvents = function (event) {
                    // A disabled button shouldn't apply any actions
                    if (this.disabled) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                    }
                };
                return MatAnchor;
            }(MatButton));
            MatAnchor.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: "a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],\n             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]",
                            exportAs: 'matButton, matAnchor',
                            host: {
                                // Note that we ignore the user-specified tabindex when it's disabled for
                                // consistency with the `mat-button` applied on native buttons where even
                                // though they have an index, they're not tabbable.
                                '[attr.tabindex]': 'disabled ? -1 : (tabIndex || 0)',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '(click)': '_haltDisabledEvents($event)',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            },
                            inputs: ['disabled', 'disableRipple', 'color'],
                            template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div matRipple class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"isRoundButton || isIconButton\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"isIconButton\" [matRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\"></div>",
                            styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatAnchor.ctorParameters = function () { return [
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_3__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatAnchor.propDecorators = {
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatButtonModule = /** @class */ (function () {
                function MatButtonModule() {
                }
                return MatButtonModule;
            }());
            MatButtonModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_4__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatRippleModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                            ],
                            exports: [
                                MatButton,
                                MatAnchor,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                            ],
                            declarations: [
                                MatButton,
                                MatAnchor,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=button.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/card.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/card.js ***!
          \********************************************************/
        /*! exports provided: MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardImage, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardXlImage, MatCardAvatar, MatCard, MatCardHeader, MatCardTitleGroup, MatCardModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardContent", function () { return MatCardContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardTitle", function () { return MatCardTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardSubtitle", function () { return MatCardSubtitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardActions", function () { return MatCardActions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardFooter", function () { return MatCardFooter; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardImage", function () { return MatCardImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardSmImage", function () { return MatCardSmImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardMdImage", function () { return MatCardMdImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardLgImage", function () { return MatCardLgImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardXlImage", function () { return MatCardXlImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardAvatar", function () { return MatCardAvatar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCard", function () { return MatCard; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardHeader", function () { return MatCardHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardTitleGroup", function () { return MatCardTitleGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardModule", function () { return MatCardModule; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Content of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardContent = /** @class */ (function () {
                function MatCardContent() {
                }
                return MatCardContent;
            }());
            MatCardContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-content',
                            host: { 'class': 'mat-card-content' }
                        },] },
            ];
            /**
             * Title of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardTitle = /** @class */ (function () {
                function MatCardTitle() {
                }
                return MatCardTitle;
            }());
            MatCardTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-card-title, [mat-card-title], [matCardTitle]",
                            host: {
                                'class': 'mat-card-title'
                            }
                        },] },
            ];
            /**
             * Sub-title of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardSubtitle = /** @class */ (function () {
                function MatCardSubtitle() {
                }
                return MatCardSubtitle;
            }());
            MatCardSubtitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]",
                            host: {
                                'class': 'mat-card-subtitle'
                            }
                        },] },
            ];
            /**
             * Action section of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardActions = /** @class */ (function () {
                function MatCardActions() {
                    /**
                     * Position of the actions inside the card.
                     */
                    this.align = 'start';
                }
                return MatCardActions;
            }());
            MatCardActions.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-actions',
                            exportAs: 'matCardActions',
                            host: {
                                'class': 'mat-card-actions',
                                '[class.mat-card-actions-align-end]': 'align === "end"',
                            }
                        },] },
            ];
            MatCardActions.propDecorators = {
                align: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Footer of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardFooter = /** @class */ (function () {
                function MatCardFooter() {
                }
                return MatCardFooter;
            }());
            MatCardFooter.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-footer',
                            host: { 'class': 'mat-card-footer' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardImage = /** @class */ (function () {
                function MatCardImage() {
                }
                return MatCardImage;
            }());
            MatCardImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-image], [matCardImage]',
                            host: { 'class': 'mat-card-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardSmImage = /** @class */ (function () {
                function MatCardSmImage() {
                }
                return MatCardSmImage;
            }());
            MatCardSmImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-sm-image], [matCardImageSmall]',
                            host: { 'class': 'mat-card-sm-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardMdImage = /** @class */ (function () {
                function MatCardMdImage() {
                }
                return MatCardMdImage;
            }());
            MatCardMdImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-md-image], [matCardImageMedium]',
                            host: { 'class': 'mat-card-md-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardLgImage = /** @class */ (function () {
                function MatCardLgImage() {
                }
                return MatCardLgImage;
            }());
            MatCardLgImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-lg-image], [matCardImageLarge]',
                            host: { 'class': 'mat-card-lg-image' }
                        },] },
            ];
            /**
             * Large image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardXlImage = /** @class */ (function () {
                function MatCardXlImage() {
                }
                return MatCardXlImage;
            }());
            MatCardXlImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-xl-image], [matCardImageXLarge]',
                            host: { 'class': 'mat-card-xl-image' }
                        },] },
            ];
            /**
             * Avatar image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardAvatar = /** @class */ (function () {
                function MatCardAvatar() {
                }
                return MatCardAvatar;
            }());
            MatCardAvatar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-avatar], [matCardAvatar]',
                            host: { 'class': 'mat-card-avatar' }
                        },] },
            ];
            /**
             * A basic content container component that adds the styles of a Material design card.
             *
             * While this component can be used alone, it also provides a number
             * of preset styles for common card sections, including:
             * - mat-card-title
             * - mat-card-subtitle
             * - mat-card-content
             * - mat-card-actions
             * - mat-card-footer
             */
            var MatCard = /** @class */ (function () {
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                /**
                 * @param {?=} _animationMode
                 */
                function MatCard(_animationMode) {
                    this._animationMode = _animationMode;
                }
                return MatCard;
            }());
            MatCard.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card',
                            exportAs: 'matCard',
                            template: "<ng-content></ng-content><ng-content select=\"mat-card-footer\"></ng-content>",
                            styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-card',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatCard.ctorParameters = function () { return [
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * Component intended to be used within the `<mat-card>` component. It adds styles for a
             * preset header section (i.e. a title, subtitle, and avatar layout).
             * \@docs-private
             */
            var MatCardHeader = /** @class */ (function () {
                function MatCardHeader() {
                }
                return MatCardHeader;
            }());
            MatCardHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card-header',
                            template: "<ng-content select=\"[mat-card-avatar], [matCardAvatar]\"></ng-content><div class=\"mat-card-header-text\"><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content></ng-content>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: { 'class': 'mat-card-header' }
                        },] },
            ];
            /**
             * Component intended to be used within the `<mat-card>` component. It adds styles for a preset
             * layout that groups an image with a title section.
             * \@docs-private
             */
            var MatCardTitleGroup = /** @class */ (function () {
                function MatCardTitleGroup() {
                }
                return MatCardTitleGroup;
            }());
            MatCardTitleGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card-title-group',
                            template: "<div><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content select=\"img\"></ng-content><ng-content></ng-content>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: { 'class': 'mat-card-title-group' }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatCardModule = /** @class */ (function () {
                function MatCardModule() {
                }
                return MatCardModule;
            }());
            MatCardModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"]],
                            exports: [
                                MatCard,
                                MatCardHeader,
                                MatCardTitleGroup,
                                MatCardContent,
                                MatCardTitle,
                                MatCardSubtitle,
                                MatCardActions,
                                MatCardFooter,
                                MatCardSmImage,
                                MatCardMdImage,
                                MatCardLgImage,
                                MatCardImage,
                                MatCardXlImage,
                                MatCardAvatar,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                            ],
                            declarations: [
                                MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,
                                MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,
                                MatCardXlImage, MatCardAvatar,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=card.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/checkbox.js": 
        /*!************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/checkbox.js ***!
          \************************************************************/
        /*! exports provided: MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, TransitionCheckState, MatCheckboxChange, MatCheckbox, MAT_CHECKBOX_CLICK_ACTION, _MatCheckboxRequiredValidatorModule, MatCheckboxModule, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxRequiredValidator */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR", function () { return MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransitionCheckState", function () { return TransitionCheckState; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxChange", function () { return MatCheckboxChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckbox", function () { return MatCheckbox; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CLICK_ACTION", function () { return MAT_CHECKBOX_CLICK_ACTION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatCheckboxRequiredValidatorModule", function () { return _MatCheckboxRequiredValidatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxModule", function () { return MatCheckboxModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_REQUIRED_VALIDATOR", function () { return MAT_CHECKBOX_REQUIRED_VALIDATOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxRequiredValidator", function () { return MatCheckboxRequiredValidator; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify the checkbox click behavior.
             * @type {?}
             */
            var MAT_CHECKBOX_CLICK_ACTION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-checkbox-click-action');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids for checkbox components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)].
             * \@docs-private
             * @type {?}
             */
            var MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatCheckbox; })),
                multi: true
            };
            /** @enum {number} */
            var TransitionCheckState = {
                /** The initial state of the component before any user interaction. */
                Init: 0,
                /** The state representing the component when it's becoming checked. */
                Checked: 1,
                /** The state representing the component when it's becoming unchecked. */
                Unchecked: 2,
                /** The state representing the component when it's becoming indeterminate. */
                Indeterminate: 3,
            };
            TransitionCheckState[TransitionCheckState.Init] = 'Init';
            TransitionCheckState[TransitionCheckState.Checked] = 'Checked';
            TransitionCheckState[TransitionCheckState.Unchecked] = 'Unchecked';
            TransitionCheckState[TransitionCheckState.Indeterminate] = 'Indeterminate';
            /**
             * Change event object emitted by MatCheckbox.
             */
            var MatCheckboxChange = /** @class */ (function () {
                function MatCheckboxChange() {
                }
                return MatCheckboxChange;
            }());
            // Boilerplate for applying mixins to MatCheckbox.
            /**
             * \@docs-private
             */
            var MatCheckboxBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatCheckboxBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatCheckboxBase;
            }());
            /** @type {?} */
            var _MatCheckboxMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisabled"])(MatCheckboxBase)), 'accent'));
            /**
             * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
             * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or
             * disabled. Note that all additional accessibility attributes are taken care of by the component,
             * so there is no need to provide them yourself. However, if you want to omit a label and still
             * have the checkbox be accessible, you may supply an [aria-label] input.
             * See: https://material.io/design/components/selection-controls.html
             */
            var MatCheckbox = /** @class */ (function (_super) {
                __extends(MatCheckbox, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _focusMonitor
                 * @param {?} _ngZone
                 * @param {?} tabIndex
                 * @param {?} _clickAction
                 * @param {?=} _animationMode
                 */
                function MatCheckbox(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _clickAction, _animationMode) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._focusMonitor = _focusMonitor;
                    _this._ngZone = _ngZone;
                    _this._clickAction = _clickAction;
                    _this._animationMode = _animationMode;
                    /**
                     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
                     * take precedence so this may be omitted.
                     */
                    _this.ariaLabel = '';
                    /**
                     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
                     */
                    _this.ariaLabelledby = null;
                    _this._uniqueId = "mat-checkbox-" + ++nextUniqueId;
                    /**
                     * A unique id for the checkbox input. If none is supplied, it will be auto-generated.
                     */
                    _this.id = _this._uniqueId;
                    /**
                     * Whether the label should appear after or before the checkbox. Defaults to 'after'
                     */
                    _this.labelPosition = 'after';
                    /**
                     * Name value will be applied to the input element if present
                     */
                    _this.name = null;
                    /**
                     * Event emitted when the checkbox's `checked` value changes.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the checkbox's `indeterminate` value changes.
                     */
                    _this.indeterminateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
                     * \@docs-private
                     */
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this._currentAnimationClass = '';
                    _this._currentCheckState = TransitionCheckState.Init;
                    _this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    _this._checked = false;
                    _this._disabled = false;
                    _this._indeterminate = false;
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    _this._focusMonitor.monitor(elementRef, true).subscribe(( /**
                     * @param {?} focusOrigin
                     * @return {?}
                     */function (/**
                     * @param {?} focusOrigin
                     * @return {?}
                     */ focusOrigin) {
                        if (!focusOrigin) {
                            // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                            // Angular does not expect events to be raised during change detection, so any state change
                            // (such as a form control's 'ng-touched') will cause a changed-after-checked error.
                            // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                            // telling the form control it has been touched until the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this._onTouched();
                                _changeDetectorRef.markForCheck();
                            }));
                        }
                    }));
                    return _this;
                }
                Object.defineProperty(MatCheckbox.prototype, "inputId", {
                    /**
                     * Returns the unique id for the visual hidden input.
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "required", {
                    /**
                     * Whether the checkbox is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                // TODO: Delete next major revision.
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype.ngAfterViewChecked = function () { };
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                Object.defineProperty(MatCheckbox.prototype, "checked", {
                    /**
                     * Whether the checkbox is checked.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value != this.checked) {
                            this._checked = value;
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "disabled", {
                    /**
                     * Whether the checkbox is disabled. This fully overrides the implementation provided by
                     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        if (newValue !== this.disabled) {
                            this._disabled = newValue;
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "indeterminate", {
                    /**
                     * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
                     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
                     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
                     * set to false.
                     * @return {?}
                     */
                    get: function () { return this._indeterminate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var changed = value != this._indeterminate;
                        this._indeterminate = value;
                        if (changed) {
                            if (this._indeterminate) {
                                this._transitionCheckState(TransitionCheckState.Indeterminate);
                            }
                            else {
                                this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                            }
                            this.indeterminateChange.emit(this._indeterminate);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * Method being called whenever the label text changes.
                 * @return {?}
                 */
                MatCheckbox.prototype._onLabelTextChange = function () {
                    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox
                    // component will be only marked for check, but no actual change detection runs automatically.
                    // Instead of going back into the zone in order to trigger a change detection which causes
                    // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger
                    // an explicit change detection for the checkbox view and its children.
                    this._changeDetectorRef.detectChanges();
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatCheckbox.prototype.writeValue = function (value) {
                    this.checked = !!value;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatCheckbox.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatCheckbox.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatCheckbox.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype._getAriaChecked = function () {
                    return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');
                };
                /**
                 * @private
                 * @param {?} newState
                 * @return {?}
                 */
                MatCheckbox.prototype._transitionCheckState = function (newState) {
                    /** @type {?} */
                    var oldState = this._currentCheckState;
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (oldState === newState) {
                        return;
                    }
                    if (this._currentAnimationClass.length > 0) {
                        element.classList.remove(this._currentAnimationClass);
                    }
                    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
                    this._currentCheckState = newState;
                    if (this._currentAnimationClass.length > 0) {
                        element.classList.add(this._currentAnimationClass);
                        // Remove the animation class to avoid animation when the checkbox is moved between containers
                        /** @type {?} */
                        var animationClass_1 = this._currentAnimationClass;
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                element.classList.remove(animationClass_1);
                            }), 1000);
                        }));
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatCheckbox.prototype._emitChangeEvent = function () {
                    /** @type {?} */
                    var event = new MatCheckboxChange();
                    event.source = this;
                    event.checked = this.checked;
                    this._controlValueAccessorChangeFn(this.checked);
                    this.change.emit(event);
                };
                /**
                 * Toggles the `checked` state of the checkbox.
                 * @return {?}
                 */
                MatCheckbox.prototype.toggle = function () {
                    this.checked = !this.checked;
                };
                /**
                 * Event handler for checkbox input element.
                 * Toggles checked state if element is not disabled.
                 * Do not toggle on (change) event since IE doesn't fire change event when
                 *   indeterminate checkbox is clicked.
                 * @param {?} event
                 * @return {?}
                 */
                MatCheckbox.prototype._onInputClick = function (event) {
                    var _this = this;
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `checkbox` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                    // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click
                    if (!this.disabled && this._clickAction !== 'noop') {
                        // When user manually click on the checkbox, `indeterminate` is set to false.
                        if (this.indeterminate && this._clickAction !== 'check') {
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this._indeterminate = false;
                                _this.indeterminateChange.emit(_this._indeterminate);
                            }));
                        }
                        this.toggle();
                        this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                        // Emit our custom change event if the native input emitted one.
                        // It is important to only emit it, if the native input triggered one, because
                        // we don't want to trigger a change event, when the `checked` variable changes for example.
                        this._emitChangeEvent();
                    }
                    else if (!this.disabled && this._clickAction === 'noop') {
                        // Reset native input when clicked with noop. The native checkbox becomes checked after
                        // click, reset it to be align with `checked` value of `mat-checkbox`.
                        this._inputElement.nativeElement.checked = this.checked;
                        this._inputElement.nativeElement.indeterminate = this.indeterminate;
                    }
                };
                /**
                 * Focuses the checkbox.
                 * @param {?=} origin
                 * @param {?=} options
                 * @return {?}
                 */
                MatCheckbox.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'keyboard'; }
                    this._focusMonitor.focusVia(this._inputElement, origin, options);
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatCheckbox.prototype._onInteractionEvent = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the `change` output.
                    event.stopPropagation();
                };
                /**
                 * @private
                 * @param {?} oldState
                 * @param {?} newState
                 * @return {?}
                 */
                MatCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {
                    // Don't transition if animations are disabled.
                    if (this._animationMode === 'NoopAnimations') {
                        return '';
                    }
                    /** @type {?} */
                    var animSuffix = '';
                    switch (oldState) {
                        case TransitionCheckState.Init:
                            // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or
                            // [checked] bound to it.
                            if (newState === TransitionCheckState.Checked) {
                                animSuffix = 'unchecked-checked';
                            }
                            else if (newState == TransitionCheckState.Indeterminate) {
                                animSuffix = 'unchecked-indeterminate';
                            }
                            else {
                                return '';
                            }
                            break;
                        case TransitionCheckState.Unchecked:
                            animSuffix = newState === TransitionCheckState.Checked ?
                                'unchecked-checked' : 'unchecked-indeterminate';
                            break;
                        case TransitionCheckState.Checked:
                            animSuffix = newState === TransitionCheckState.Unchecked ?
                                'checked-unchecked' : 'checked-indeterminate';
                            break;
                        case TransitionCheckState.Indeterminate:
                            animSuffix = newState === TransitionCheckState.Checked ?
                                'indeterminate-checked' : 'indeterminate-unchecked';
                            break;
                    }
                    return "mat-checkbox-anim-" + animSuffix;
                };
                return MatCheckbox;
            }(_MatCheckboxMixinBase));
            MatCheckbox.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-checkbox',
                            template: "<label [attr.for]=\"inputId\" class=\"mat-checkbox-layout\" #label><div class=\"mat-checkbox-inner-container\" [class.mat-checkbox-inner-container-no-side-margin]=\"!checkboxLabel.textContent || !checkboxLabel.textContent.trim()\"><input #input class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [checked]=\"checked\" [attr.value]=\"value\" [disabled]=\"disabled\" [attr.name]=\"name\" [tabIndex]=\"tabIndex\" [indeterminate]=\"indeterminate\" [attr.aria-label]=\"ariaLabel || null\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-checked]=\"_getAriaChecked()\" (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\"><div matRipple class=\"mat-checkbox-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleRadius]=\"20\" [matRippleCentered]=\"true\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-checkbox-persistent-ripple\"></div></div><div class=\"mat-checkbox-frame\"></div><div class=\"mat-checkbox-background\"><svg version=\"1.1\" focusable=\"false\" class=\"mat-checkbox-checkmark\" viewBox=\"0 0 24 24\" xml:space=\"preserve\"><path class=\"mat-checkbox-checkmark-path\" fill=\"none\" stroke=\"white\" d=\"M4.1,12.7 9,17.6 20.3,6.3\"/></svg><div class=\"mat-checkbox-mixedmark\"></div></div></div><span class=\"mat-checkbox-label\" #checkboxLabel (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                            styles: ["@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}@media (-ms-high-contrast:active){.mat-checkbox.cdk-keyboard-focused .mat-checkbox-frame{border-style:dotted}}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}._mat-animation-noopable .mat-checkbox-background{transition:none}.mat-checkbox-persistent-ripple{width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media (hover:none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.13333px}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0);border-radius:2px}@media (-ms-high-contrast:active){.mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}"],
                            exportAs: 'matCheckbox',
                            host: {
                                'class': 'mat-checkbox',
                                '[id]': 'id',
                                '[attr.tabindex]': 'null',
                                '[class.mat-checkbox-indeterminate]': 'indeterminate',
                                '[class.mat-checkbox-checked]': 'checked',
                                '[class.mat-checkbox-disabled]': 'disabled',
                                '[class.mat-checkbox-label-before]': 'labelPosition == "before"',
                                '[class._mat-animation-noopable]': "_animationMode === 'NoopAnimations'",
                            },
                            providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR],
                            inputs: ['disableRipple', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatCheckbox.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_CHECKBOX_CLICK_ACTION,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatCheckbox.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                indeterminateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['input', { static: false },] }],
                ripple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRipple"], { static: false },] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                indeterminate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_CHECKBOX_REQUIRED_VALIDATOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatCheckboxRequiredValidator; })),
                multi: true
            };
            /**
             * Validator for Material checkbox's required attribute in template-driven checkbox.
             * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not
             * work with `mat-checkbox`.
             */
            var MatCheckboxRequiredValidator = /** @class */ (function (_super) {
                __extends(MatCheckboxRequiredValidator, _super);
                function MatCheckboxRequiredValidator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatCheckboxRequiredValidator;
            }(_angular_forms__WEBPACK_IMPORTED_MODULE_3__["CheckboxRequiredValidator"]));
            MatCheckboxRequiredValidator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-checkbox[required][formControlName],\n             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]",
                            providers: [MAT_CHECKBOX_REQUIRED_VALIDATOR],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This module is used by both original and MDC-based checkbox implementations.
             */
            // tslint:disable-next-line:class-name
            var _MatCheckboxRequiredValidatorModule = /** @class */ (function () {
                function _MatCheckboxRequiredValidatorModule() {
                }
                return _MatCheckboxRequiredValidatorModule;
            }());
            _MatCheckboxRequiredValidatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [MatCheckboxRequiredValidator],
                            declarations: [MatCheckboxRequiredValidator],
                        },] },
            ];
            var MatCheckboxModule = /** @class */ (function () {
                function MatCheckboxModule() {
                }
                return MatCheckboxModule;
            }());
            MatCheckboxModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_6__["ObserversModule"],
                                _MatCheckboxRequiredValidatorModule
                            ],
                            exports: [MatCheckbox, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _MatCheckboxRequiredValidatorModule],
                            declarations: [MatCheckbox],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=checkbox.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/chips.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/chips.js ***!
          \*********************************************************/
        /*! exports provided: MatChipsModule, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipAvatar, MatChipTrailingIcon, MatChip, MatChipRemove, MatChipInput, MAT_CHIPS_DEFAULT_OPTIONS */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipsModule", function () { return MatChipsModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipListChange", function () { return MatChipListChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipList", function () { return MatChipList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipSelectionChange", function () { return MatChipSelectionChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipAvatar", function () { return MatChipAvatar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipTrailingIcon", function () { return MatChipTrailingIcon; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChip", function () { return MatChip; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipRemove", function () { return MatChipRemove; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipInput", function () { return MatChipInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHIPS_DEFAULT_OPTIONS", function () { return MAT_CHIPS_DEFAULT_OPTIONS; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Event object emitted by MatChip when selected or deselected.
             */
            var MatChipSelectionChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} selected
                 * @param {?=} isUserInput
                 */
                function MatChipSelectionChange(source, selected, isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this.source = source;
                    this.selected = selected;
                    this.isUserInput = isUserInput;
                }
                return MatChipSelectionChange;
            }());
            // Boilerplate for applying mixins to MatChip.
            /**
             * \@docs-private
             */
            var MatChipBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatChipBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatChipBase;
            }());
            /** @type {?} */
            var _MatChipMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisabled"])(MatChipBase)), 'primary');
            /**
             * Dummy directive to add CSS class to chip avatar.
             * \@docs-private
             */
            var MatChipAvatar = /** @class */ (function () {
                function MatChipAvatar() {
                }
                return MatChipAvatar;
            }());
            MatChipAvatar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-chip-avatar, [matChipAvatar]',
                            host: { 'class': 'mat-chip-avatar' }
                        },] },
            ];
            /**
             * Dummy directive to add CSS class to chip trailing icon.
             * \@docs-private
             */
            var MatChipTrailingIcon = /** @class */ (function () {
                function MatChipTrailingIcon() {
                }
                return MatChipTrailingIcon;
            }());
            MatChipTrailingIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',
                            host: { 'class': 'mat-chip-trailing-icon' }
                        },] },
            ];
            /**
             * Material design styled Chip component. Used inside the MatChipList component.
             */
            var MatChip = /** @class */ (function (_super) {
                __extends(MatChip, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} platform
                 * @param {?} globalRippleOptions
                 * @param {?=} animationMode
                 * @param {?=} _changeDetectorRef
                 */
                function MatChip(_elementRef, _ngZone, platform, globalRippleOptions, 
                // @breaking-change 8.0.0 `animationMode` parameter to become required.
                animationMode, _changeDetectorRef) {
                    var _this = _super.call(this, _elementRef) || this;
                    _this._elementRef = _elementRef;
                    _this._ngZone = _ngZone;
                    _this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Whether the chip has focus.
                     */
                    _this._hasFocus = false;
                    /**
                     * Whether the chip list is selectable
                     */
                    _this.chipListSelectable = true;
                    /**
                     * Whether the chip list is in multi-selection mode.
                     */
                    _this._chipListMultiple = false;
                    _this._selected = false;
                    _this._selectable = true;
                    _this._removable = true;
                    /**
                     * Emits when the chip is focused.
                     */
                    _this._onFocus = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Emits when the chip is blured.
                     */
                    _this._onBlur = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Emitted when the chip is selected or deselected.
                     */
                    _this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emitted when the chip is destroyed.
                     */
                    _this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emitted when a chip is to be removed.
                     */
                    _this.removed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    _this._addHostClassName();
                    _this._chipRipple = new _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["RippleRenderer"](_this, _ngZone, _elementRef, platform);
                    _this._chipRipple.setupTriggerEvents(_elementRef);
                    _this.rippleConfig = globalRippleOptions || {};
                    _this._animationsDisabled = animationMode === 'NoopAnimations';
                    return _this;
                }
                Object.defineProperty(MatChip.prototype, "rippleDisabled", {
                    /**
                     * Whether ripples are disabled on interaction
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "selected", {
                    /**
                     * Whether the chip is selected.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var coercedValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        if (coercedValue !== this._selected) {
                            this._selected = coercedValue;
                            this._dispatchSelectionChange();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "value", {
                    /**
                     * The value of the chip. Defaults to the content inside `<mat-chip>` tags.
                     * @return {?}
                     */
                    get: function () {
                        return this._value !== undefined
                            ? this._value
                            : this._elementRef.nativeElement.textContent;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._value = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "selectable", {
                    /**
                     * Whether or not the chip is selectable. When a chip is not selectable,
                     * changes to its selected state are always ignored. By default a chip is
                     * selectable, and it becomes non-selectable if its parent chip list is
                     * not selectable.
                     * @return {?}
                     */
                    get: function () { return this._selectable && this.chipListSelectable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "removable", {
                    /**
                     * Determines whether or not the chip displays the remove styling and emits (removed) events.
                     * @return {?}
                     */
                    get: function () { return this._removable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._removable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "ariaSelected", {
                    /**
                     * The ARIA selected applied to the chip.
                     * @return {?}
                     */
                    get: function () {
                        // Remove the `aria-selected` when the chip is deselected in single-selection mode, because
                        // it adds noise to NVDA users where "not selected" will be read out for each chip.
                        return this.selectable && (this._chipListMultiple || this.selected) ?
                            this.selected.toString() : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChip.prototype._addHostClassName = function () {
                    /** @type {?} */
                    var basicChipAttrName = 'mat-basic-chip';
                    /** @type {?} */
                    var element = ( /** @type {?} */(this._elementRef.nativeElement));
                    if (element.hasAttribute(basicChipAttrName) ||
                        element.tagName.toLowerCase() === basicChipAttrName) {
                        element.classList.add(basicChipAttrName);
                        return;
                    }
                    else {
                        element.classList.add('mat-standard-chip');
                    }
                };
                /**
                 * @return {?}
                 */
                MatChip.prototype.ngOnDestroy = function () {
                    this.destroyed.emit({ chip: this });
                    this._chipRipple._removeTriggerEvents();
                };
                /**
                 * Selects the chip.
                 * @return {?}
                 */
                MatChip.prototype.select = function () {
                    if (!this._selected) {
                        this._selected = true;
                        this._dispatchSelectionChange();
                        this._markForCheck();
                    }
                };
                /**
                 * Deselects the chip.
                 * @return {?}
                 */
                MatChip.prototype.deselect = function () {
                    if (this._selected) {
                        this._selected = false;
                        this._dispatchSelectionChange();
                        this._markForCheck();
                    }
                };
                /**
                 * Select this chip and emit selected event
                 * @return {?}
                 */
                MatChip.prototype.selectViaInteraction = function () {
                    if (!this._selected) {
                        this._selected = true;
                        this._dispatchSelectionChange(true);
                        this._markForCheck();
                    }
                };
                /**
                 * Toggles the current selected state of this chip.
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChip.prototype.toggleSelected = function (isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this._selected = !this.selected;
                    this._dispatchSelectionChange(isUserInput);
                    this._markForCheck();
                    return this.selected;
                };
                /**
                 * Allows for programmatic focusing of the chip.
                 * @return {?}
                 */
                MatChip.prototype.focus = function () {
                    if (!this._hasFocus) {
                        this._elementRef.nativeElement.focus();
                        this._onFocus.next({ chip: this });
                    }
                    this._hasFocus = true;
                };
                /**
                 * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
                 * BACKSPACE keys are pressed.
                 *
                 * Informs any listeners of the removal request. Does not remove the chip from the DOM.
                 * @return {?}
                 */
                MatChip.prototype.remove = function () {
                    if (this.removable) {
                        this.removed.emit({ chip: this });
                    }
                };
                /**
                 * Handles click events on the chip.
                 * @param {?} event
                 * @return {?}
                 */
                MatChip.prototype._handleClick = function (event) {
                    if (this.disabled) {
                        event.preventDefault();
                    }
                    else {
                        event.stopPropagation();
                    }
                };
                /**
                 * Handle custom key presses.
                 * @param {?} event
                 * @return {?}
                 */
                MatChip.prototype._handleKeydown = function (event) {
                    if (this.disabled) {
                        return;
                    }
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["DELETE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["BACKSPACE"]:
                            // If we are removable, remove the focused chip
                            this.remove();
                            // Always prevent so page navigation does not occur
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["SPACE"]:
                            // If we are selectable, toggle the focused chip
                            if (this.selectable) {
                                this.toggleSelected(true);
                            }
                            // Always prevent space from scrolling the page since the list has focus
                            event.preventDefault();
                            break;
                    }
                };
                /**
                 * @return {?}
                 */
                MatChip.prototype._blur = function () {
                    var _this = this;
                    // When animations are enabled, Angular may end up removing the chip from the DOM a little
                    // earlier than usual, causing it to be blurred and throwing off the logic in the chip list
                    // that moves focus not the next item. To work around the issue, we defer marking the chip
                    // as not focused until the next time the zone stabilizes.
                    this._ngZone.onStable
                        .asObservable()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            _this._hasFocus = false;
                            _this._onBlur.next({ chip: _this });
                        }));
                    }));
                };
                /**
                 * @private
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChip.prototype._dispatchSelectionChange = function (isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this.selectionChange.emit({
                        source: this,
                        isUserInput: isUserInput,
                        selected: this._selected
                    });
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChip.prototype._markForCheck = function () {
                    // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.
                    if (this._changeDetectorRef) {
                        this._changeDetectorRef.markForCheck();
                    }
                };
                return MatChip;
            }(_MatChipMixinBase));
            MatChip.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
                            inputs: ['color', 'disabled', 'disableRipple'],
                            exportAs: 'matChip',
                            host: {
                                'class': 'mat-chip',
                                '[attr.tabindex]': 'disabled ? null : -1',
                                'role': 'option',
                                '[class.mat-chip-selected]': 'selected',
                                '[class.mat-chip-with-avatar]': 'avatar',
                                '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',
                                '[class.mat-chip-disabled]': 'disabled',
                                '[class._mat-animation-noopable]': '_animationsDisabled',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-selected]': 'ariaSelected',
                                '(click)': '_handleClick($event)',
                                '(keydown)': '_handleKeydown($event)',
                                '(focus)': 'focus()',
                                '(blur)': '_blur()',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatChip.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            MatChip.propDecorators = {
                avatar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatChipAvatar, { static: false },] }],
                trailingIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatChipTrailingIcon, { static: false },] }],
                removeIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatChipRemove; })), { static: false },] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                removable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                removed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * Applies proper (click) support and adds styling for use with the Material Design "cancel" icon
             * available at https://material.io/icons/#ic_cancel.
             *
             * Example:
             *
             *     `<mat-chip>
             *       <mat-icon matChipRemove>cancel</mat-icon>
             *     </mat-chip>`
             *
             * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning
             * styles to properly center the icon within the chip.
             */
            var MatChipRemove = /** @class */ (function () {
                /**
                 * @param {?} _parentChip
                 */
                function MatChipRemove(_parentChip) {
                    this._parentChip = _parentChip;
                }
                /**
                 * Calls the parent chip's public `remove()` method if applicable.
                 * @param {?} event
                 * @return {?}
                 */
                MatChipRemove.prototype._handleClick = function (event) {
                    /** @type {?} */
                    var parentChip = this._parentChip;
                    if (parentChip.removable && !parentChip.disabled) {
                        parentChip.remove();
                    }
                    // We need to stop event propagation because otherwise the event will bubble up to the
                    // form field and cause the `onContainerClick` method to be invoked. This method would then
                    // reset the focused chip that has been focused after chip removal. Usually the parent
                    // the parent click listener of the `MatChip` would prevent propagation, but it can happen
                    // that the chip is being removed before the event bubbles up.
                    event.stopPropagation();
                };
                return MatChipRemove;
            }());
            MatChipRemove.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[matChipRemove]',
                            host: {
                                'class': 'mat-chip-remove mat-chip-trailing-icon',
                                '(click)': '_handleClick($event)',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatChipRemove.ctorParameters = function () { return [
                { type: MatChip }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for the chips module.
             * @type {?}
             */
            var MAT_CHIPS_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-chips-default-options');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatChipList.
            /**
             * \@docs-private
             */
            var MatChipListBase = /** @class */ (function () {
                /**
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} ngControl
                 */
                function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
                    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
                    this._parentForm = _parentForm;
                    this._parentFormGroup = _parentFormGroup;
                    this.ngControl = ngControl;
                }
                return MatChipListBase;
            }());
            /** @type {?} */
            var _MatChipListMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinErrorState"])(MatChipListBase);
            // Increasing integer for generating unique ids for chip-list components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Change event object that is emitted when the chip list value has changed.
             */
            var MatChipListChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatChipListChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatChipListChange;
            }());
            /**
             * A material design chips component (named ChipList for its similarity to the List component).
             */
            var MatChipList = /** @class */ (function (_super) {
                __extends(MatChipList, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _dir
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} ngControl
                 */
                function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {
                    var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
                    _this._elementRef = _elementRef;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._dir = _dir;
                    _this.ngControl = ngControl;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this.controlType = 'mat-chip-list';
                    /**
                     * When a chip is destroyed, we store the index of the destroyed chip until the chips
                     * query list notifies about the update. This is necessary because we cannot determine an
                     * appropriate chip that should receive focus until the array of chips updated completely.
                     */
                    _this._lastDestroyedChipIndex = null;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    _this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Uid of the chip list
                     */
                    _this._uid = "mat-chip-list-" + nextUniqueId++;
                    /**
                     * Tab index for the chip list.
                     */
                    _this._tabIndex = 0;
                    /**
                     * User defined tab index.
                     * When it is not null, use user defined tab index. Otherwise use _tabIndex
                     */
                    _this._userTabIndex = null;
                    /**
                     * Function when touched
                     */
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Function when changed
                     */
                    _this._onChange = ( /**
                     * @return {?}
                     */function () { });
                    _this._multiple = false;
                    _this._compareWith = ( /**
                     * @param {?} o1
                     * @param {?} o2
                     * @return {?}
                     */function (o1, o2) { return o1 === o2; });
                    _this._required = false;
                    _this._disabled = false;
                    /**
                     * Orientation of the chip list.
                     */
                    _this.ariaOrientation = 'horizontal';
                    _this._selectable = true;
                    /**
                     * Event emitted when the selected chip list value has been changed by the user.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event that emits whenever the raw value of the chip-list changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    if (_this.ngControl) {
                        _this.ngControl.valueAccessor = _this;
                    }
                    return _this;
                }
                Object.defineProperty(MatChipList.prototype, "selected", {
                    /**
                     * The array of selected chips inside chip list.
                     * @return {?}
                     */
                    get: function () {
                        return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "role", {
                    /**
                     * The ARIA role applied to the chip list.
                     * @return {?}
                     */
                    get: function () { return this.empty ? null : 'listbox'; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "multiple", {
                    /**
                     * Whether the user should be allowed to select multiple chips.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this._syncChipsState();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "compareWith", {
                    /**
                     * A function to compare the option values with the selected values. The first argument
                     * is a value from an option. The second is a value from the selection. A boolean
                     * should be returned.
                     * @return {?}
                     */
                    get: function () { return this._compareWith; },
                    /**
                     * @param {?} fn
                     * @return {?}
                     */
                    set: function (fn) {
                        this._compareWith = fn;
                        if (this._selectionModel) {
                            // A different comparator means the selection could change.
                            this._initializeSelection();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "value", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.writeValue(value);
                        this._value = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "id", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._chipInput ? this._chipInput.id : this._uid;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "required", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "placeholder", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._chipInput ? this._chipInput.placeholder : this._placeholder;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._placeholder = value;
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "focused", {
                    /**
                     * Whether any chips or the matChipInput inside of this chip-list has focus.
                     * @return {?}
                     */
                    get: function () {
                        return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "empty", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "shouldLabelFloat", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return !this.empty || this.focused; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "disabled", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this._syncChipsState();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "selectable", {
                    /**
                     * Whether or not this chip list is selectable. When a chip list is not selectable,
                     * the selected states for all the chips inside the chip list are always ignored.
                     * @return {?}
                     */
                    get: function () { return this._selectable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        if (this.chips) {
                            this.chips.forEach(( /**
                             * @param {?} chip
                             * @return {?}
                             */function (/**
                             * @param {?} chip
                             * @return {?}
                             */ chip) { return chip.chipListSelectable = _this._selectable; }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "tabIndex", {
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._userTabIndex = value;
                        this._tabIndex = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipSelectionChanges", {
                    /**
                     * Combined stream of all of the child chips' selection change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.selectionChange; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipFocusChanges", {
                    /**
                     * Combined stream of all of the child chips' focus change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip._onFocus; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipBlurChanges", {
                    /**
                     * Combined stream of all of the child chips' blur change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip._onBlur; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipRemoveChanges", {
                    /**
                     * Combined stream of all of the child chips' remove change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.destroyed; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__["FocusKeyManager"](this.chips)
                        .withWrap()
                        .withVerticalOrientation()
                        .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');
                    if (this._dir) {
                        this._dir.change
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed))
                            .subscribe(( /**
                     * @param {?} dir
                     * @return {?}
                     */function (/**
                     * @param {?} dir
                     * @return {?}
                     */ dir) { return _this._keyManager.withHorizontalOrientation(dir); }));
                    }
                    this._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._allowFocusEscape();
                    }));
                    // When the list changes, re-subscribe
                    this.chips.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (_this.disabled) {
                            // Since this happens after the content has been
                            // checked, we need to defer it to the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this._syncChipsState();
                            }));
                        }
                        _this._resetChips();
                        // Reset chips selected/deselected status
                        _this._initializeSelection();
                        // Check to see if we need to update our tab index
                        _this._updateTabIndex();
                        // Check to see if we have a destroyed chip and need to refocus
                        _this._updateFocusForDestroyedChips();
                        _this.stateChanges.next();
                    }));
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngOnInit = function () {
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_10__["SelectionModel"](this.multiple, undefined, false);
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngDoCheck = function () {
                    if (this.ngControl) {
                        // We need to re-evaluate this on every change detection cycle, because there are some
                        // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                        // that whatever logic is in here has to be super lean or we risk destroying the performance.
                        this.updateErrorState();
                    }
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                    this.stateChanges.complete();
                    this._dropSubscriptions();
                };
                /**
                 * Associates an HTML input element with this chip list.
                 * @param {?} inputElement
                 * @return {?}
                 */
                MatChipList.prototype.registerInput = function (inputElement) {
                    this._chipInput = inputElement;
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} ids
                 * @return {?}
                 */
                MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatChipList.prototype.writeValue = function (value) {
                    if (this.chips) {
                        this._setSelectionByValue(value, false);
                    }
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatChipList.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatChipList.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatChipList.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this.stateChanges.next();
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype.onContainerClick = function (event) {
                    if (!this._originatesFromChip(event)) {
                        this.focus();
                    }
                };
                /**
                 * Focuses the first non-disabled chip in this chip list, or the associated input when there
                 * are no eligible chips.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipList.prototype.focus = function (options) {
                    if (this.disabled) {
                        return;
                    }
                    // TODO: ARIA says this should focus the first `selected` chip if any are selected.
                    // Focus on first element if there's no chipInput inside chip-list
                    if (this._chipInput && this._chipInput.focused) {
                        // do nothing
                    }
                    else if (this.chips.length > 0) {
                        this._keyManager.setFirstItemActive();
                        this.stateChanges.next();
                    }
                    else {
                        this._focusInput(options);
                        this.stateChanges.next();
                    }
                };
                /**
                 * Attempt to focus an input if we have one.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipList.prototype._focusInput = function (options) {
                    if (this._chipInput) {
                        this._chipInput.focus(options);
                    }
                };
                /**
                 * Pass events to the keyboard manager. Available here for tests.
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype._keydown = function (event) {
                    /** @type {?} */
                    var target = ( /** @type {?} */(event.target));
                    // If they are on an empty input and hit backspace, focus the last chip
                    if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["BACKSPACE"] && this._isInputEmpty(target)) {
                        this._keyManager.setLastItemActive();
                        event.preventDefault();
                    }
                    else if (target && target.classList.contains('mat-chip')) {
                        if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["HOME"]) {
                            this._keyManager.setFirstItemActive();
                            event.preventDefault();
                        }
                        else if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["END"]) {
                            this._keyManager.setLastItemActive();
                            event.preventDefault();
                        }
                        else {
                            this._keyManager.onKeydown(event);
                        }
                        this.stateChanges.next();
                    }
                };
                /**
                 * Check the tab index as you should not be allowed to focus an empty list.
                 * @protected
                 * @return {?}
                 */
                MatChipList.prototype._updateTabIndex = function () {
                    // If we have 0 chips, we should not allow keyboard focus
                    this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);
                };
                /**
                 * If the amount of chips changed, we need to update the
                 * key manager state and focus the next closest chip.
                 * @protected
                 * @return {?}
                 */
                MatChipList.prototype._updateFocusForDestroyedChips = function () {
                    // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.
                    if (this._lastDestroyedChipIndex != null) {
                        if (this.chips.length) {
                            /** @type {?} */
                            var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);
                            this._keyManager.setActiveItem(newChipIndex);
                        }
                        else {
                            this.focus();
                        }
                    }
                    this._lastDestroyedChipIndex = null;
                };
                /**
                 * Utility to ensure all indexes are valid.
                 *
                 * @private
                 * @param {?} index The index to be checked.
                 * @return {?} True if the index is valid for our list of chips.
                 */
                MatChipList.prototype._isValidIndex = function (index) {
                    return index >= 0 && index < this.chips.length;
                };
                /**
                 * @private
                 * @param {?} element
                 * @return {?}
                 */
                MatChipList.prototype._isInputEmpty = function (element) {
                    if (element && element.nodeName.toLowerCase() === 'input') {
                        /** @type {?} */
                        var input = ( /** @type {?} */(element));
                        return !input.value;
                    }
                    return false;
                };
                /**
                 * @param {?} value
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {
                    var _this = this;
                    if (isUserInput === void 0) { isUserInput = true; }
                    this._clearSelection();
                    this.chips.forEach(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) { return chip.deselect(); }));
                    if (Array.isArray(value)) {
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (/**
                         * @param {?} currentValue
                         * @return {?}
                         */ currentValue) { return _this._selectValue(currentValue, isUserInput); }));
                        this._sortValues();
                    }
                    else {
                        /** @type {?} */
                        var correspondingChip = this._selectValue(value, isUserInput);
                        // Shift focus to the active item. Note that we shouldn't do this in multiple
                        // mode, because we don't know what chip the user interacted with last.
                        if (correspondingChip) {
                            if (isUserInput) {
                                this._keyManager.setActiveItem(correspondingChip);
                            }
                        }
                    }
                };
                /**
                 * Finds and selects the chip based on its value.
                 * @private
                 * @param {?} value
                 * @param {?=} isUserInput
                 * @return {?} Chip that has the corresponding value.
                 */
                MatChipList.prototype._selectValue = function (value, isUserInput) {
                    var _this = this;
                    if (isUserInput === void 0) { isUserInput = true; }
                    /** @type {?} */
                    var correspondingChip = this.chips.find(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) {
                        return chip.value != null && _this._compareWith(chip.value, value);
                    }));
                    if (correspondingChip) {
                        isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
                        this._selectionModel.select(correspondingChip);
                    }
                    return correspondingChip;
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._initializeSelection = function () {
                    var _this = this;
                    // Defer setting the value in order to avoid the "Expression
                    // has changed after it was checked" errors from Angular.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        if (_this.ngControl || _this._value) {
                            _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);
                            _this.stateChanges.next();
                        }
                    }));
                };
                /**
                 * Deselects every chip in the list.
                 * @private
                 * @param {?=} skip Chip that should not be deselected.
                 * @return {?}
                 */
                MatChipList.prototype._clearSelection = function (skip) {
                    this._selectionModel.clear();
                    this.chips.forEach(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) {
                        if (chip !== skip) {
                            chip.deselect();
                        }
                    }));
                    this.stateChanges.next();
                };
                /**
                 * Sorts the model values, ensuring that they keep the same
                 * order that they have in the panel.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._sortValues = function () {
                    var _this = this;
                    if (this._multiple) {
                        this._selectionModel.clear();
                        this.chips.forEach(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) {
                            if (chip.selected) {
                                _this._selectionModel.select(chip);
                            }
                        }));
                        this.stateChanges.next();
                    }
                };
                /**
                 * Emits change event to set the model value.
                 * @private
                 * @param {?=} fallbackValue
                 * @return {?}
                 */
                MatChipList.prototype._propagateChanges = function (fallbackValue) {
                    /** @type {?} */
                    var valueToEmit = null;
                    if (Array.isArray(this.selected)) {
                        valueToEmit = this.selected.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.value; }));
                    }
                    else {
                        valueToEmit = this.selected ? this.selected.value : fallbackValue;
                    }
                    this._value = valueToEmit;
                    this.change.emit(new MatChipListChange(this, valueToEmit));
                    this.valueChange.emit(valueToEmit);
                    this._onChange(valueToEmit);
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * When blurred, mark the field as touched when focus moved outside the chip list.
                 * @return {?}
                 */
                MatChipList.prototype._blur = function () {
                    var _this = this;
                    if (!this._hasFocusedChip()) {
                        this._keyManager.setActiveItem(-1);
                    }
                    if (!this.disabled) {
                        if (this._chipInput) {
                            // If there's a chip input, we should check whether the focus moved to chip input.
                            // If the focus is not moved to chip input, mark the field as touched. If the focus moved
                            // to chip input, do nothing.
                            // Timeout is needed to wait for the focus() event trigger on chip input.
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                if (!_this.focused) {
                                    _this._markAsTouched();
                                }
                            }));
                        }
                        else {
                            // If there's no chip input, then mark the field as touched.
                            this._markAsTouched();
                        }
                    }
                };
                /**
                 * Mark the field as touched
                 * @return {?}
                 */
                MatChipList.prototype._markAsTouched = function () {
                    this._onTouched();
                    this._changeDetectorRef.markForCheck();
                    this.stateChanges.next();
                };
                /**
                 * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the
                 * user to tab out of it. This prevents the list from capturing focus and redirecting
                 * it back to the first chip, creating a focus trap, if it user tries to tab away.
                 * @return {?}
                 */
                MatChipList.prototype._allowFocusEscape = function () {
                    var _this = this;
                    if (this._tabIndex !== -1) {
                        this._tabIndex = -1;
                        setTimeout(( /**
                         * @return {?}
                         */function () {
                            _this._tabIndex = _this._userTabIndex || 0;
                            _this._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._resetChips = function () {
                    this._dropSubscriptions();
                    this._listenToChipsFocus();
                    this._listenToChipsSelection();
                    this._listenToChipsRemoved();
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._dropSubscriptions = function () {
                    if (this._chipFocusSubscription) {
                        this._chipFocusSubscription.unsubscribe();
                        this._chipFocusSubscription = null;
                    }
                    if (this._chipBlurSubscription) {
                        this._chipBlurSubscription.unsubscribe();
                        this._chipBlurSubscription = null;
                    }
                    if (this._chipSelectionSubscription) {
                        this._chipSelectionSubscription.unsubscribe();
                        this._chipSelectionSubscription = null;
                    }
                    if (this._chipRemoveSubscription) {
                        this._chipRemoveSubscription.unsubscribe();
                        this._chipRemoveSubscription = null;
                    }
                };
                /**
                 * Listens to user-generated selection events on each chip.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsSelection = function () {
                    var _this = this;
                    this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        event.source.selected
                            ? _this._selectionModel.select(event.source)
                            : _this._selectionModel.deselect(event.source);
                        // For single selection chip list, make sure the deselected value is unselected.
                        if (!_this.multiple) {
                            _this.chips.forEach(( /**
                             * @param {?} chip
                             * @return {?}
                             */function (/**
                             * @param {?} chip
                             * @return {?}
                             */ chip) {
                                if (!_this._selectionModel.isSelected(chip) && chip.selected) {
                                    chip.deselect();
                                }
                            }));
                        }
                        if (event.isUserInput) {
                            _this._propagateChanges();
                        }
                    }));
                };
                /**
                 * Listens to user-generated selection events on each chip.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsFocus = function () {
                    var _this = this;
                    this._chipFocusSubscription = this.chipFocusChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        /** @type {?} */
                        var chipIndex = _this.chips.toArray().indexOf(event.chip);
                        if (_this._isValidIndex(chipIndex)) {
                            _this._keyManager.updateActiveItemIndex(chipIndex);
                        }
                        _this.stateChanges.next();
                    }));
                    this._chipBlurSubscription = this.chipBlurChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._blur();
                        _this.stateChanges.next();
                    }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsRemoved = function () {
                    var _this = this;
                    this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        /** @type {?} */
                        var chip = event.chip;
                        /** @type {?} */
                        var chipIndex = _this.chips.toArray().indexOf(event.chip);
                        // In case the chip that will be removed is currently focused, we temporarily store
                        // the index in order to be able to determine an appropriate sibling chip that will
                        // receive focus.
                        if (_this._isValidIndex(chipIndex) && chip._hasFocus) {
                            _this._lastDestroyedChipIndex = chipIndex;
                        }
                    }));
                };
                /**
                 * Checks whether an event comes from inside a chip element.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype._originatesFromChip = function (event) {
                    /** @type {?} */
                    var currentElement = ( /** @type {?} */(event.target));
                    while (currentElement && currentElement !== this._elementRef.nativeElement) {
                        if (currentElement.classList.contains('mat-chip')) {
                            return true;
                        }
                        currentElement = currentElement.parentElement;
                    }
                    return false;
                };
                /**
                 * Checks whether any of the chips is focused.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._hasFocusedChip = function () {
                    return this.chips.some(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) { return chip._hasFocus; }));
                };
                /**
                 * Syncs the list's state with the individual chips.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._syncChipsState = function () {
                    var _this = this;
                    if (this.chips) {
                        this.chips.forEach(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) {
                            chip.disabled = _this._disabled;
                            chip._chipListMultiple = _this.multiple;
                        }));
                    }
                };
                return MatChipList;
            }(_MatChipListMixinBase));
            MatChipList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-chip-list',
                            template: "<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>",
                            exportAs: 'matChipList',
                            host: {
                                '[attr.tabindex]': 'disabled ? null : _tabIndex',
                                '[attr.aria-describedby]': '_ariaDescribedby || null',
                                '[attr.aria-required]': 'required.toString()',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-invalid]': 'errorState',
                                '[attr.aria-multiselectable]': 'multiple',
                                '[attr.role]': 'role',
                                '[class.mat-chip-list-disabled]': 'disabled',
                                '[class.mat-chip-list-invalid]': 'errorState',
                                '[class.mat-chip-list-required]': 'required',
                                '[attr.aria-orientation]': 'ariaOrientation',
                                'class': 'mat-chip-list',
                                '(focus)': 'focus()',
                                '(blur)': '_blur()',
                                '(keydown)': '_keydown($event)',
                                '[id]': '_uid',
                            },
                            providers: [{ provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__["MatFormFieldControl"], useExisting: MatChipList }],
                            styles: [".mat-chip{position:relative;overflow:hidden;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0)}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:'';pointer-events:none;transition:opacity .2s cubic-bezier(.35,0,.25,1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:0}.mat-standard-chip:focus::after{opacity:.16}@media (-ms-high-contrast:active){.mat-standard-chip{outline:solid 1px}.mat-standard-chip:focus{outline:dotted 2px}}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper .mat-standard-chip,.mat-chip-list-wrapper input.mat-input-element{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatChipList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_9__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NgForm"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["FormGroupDirective"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["ErrorStateMatcher"] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NgControl"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Self"] }] }
            ]; };
            MatChipList.propDecorators = {
                errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                compareWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                ariaOrientation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-orientation',] }],
                selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                chips: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatChip, {
                                // We need to use `descendants: true`, because Ivy will no longer match
                                // indirect descendants if it's left as false.
                                descendants: true
                            },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids.
            /** @type {?} */
            var nextUniqueId$1 = 0;
            /**
             * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.
             * May be placed inside or outside of an `<mat-chip-list>`.
             */
            var MatChipInput = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _defaultOptions
                 */
                function MatChipInput(_elementRef, _defaultOptions) {
                    this._elementRef = _elementRef;
                    this._defaultOptions = _defaultOptions;
                    /**
                     * Whether the control is focused.
                     */
                    this.focused = false;
                    this._addOnBlur = false;
                    /**
                     * The list of key codes that will trigger a chipEnd event.
                     *
                     * Defaults to `[ENTER]`.
                     */
                    this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;
                    /**
                     * Emitted when a chip is to be added.
                     */
                    this.chipEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * The input's placeholder text.
                     */
                    this.placeholder = '';
                    /**
                     * Unique id for the input.
                     */
                    this.id = "mat-chip-list-input-" + nextUniqueId$1++;
                    this._disabled = false;
                    this._inputElement = ( /** @type {?} */(this._elementRef.nativeElement));
                }
                Object.defineProperty(MatChipInput.prototype, "chipList", {
                    /**
                     * Register input for chip list
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value) {
                            this._chipList = value;
                            this._chipList.registerInput(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "addOnBlur", {
                    /**
                     * Whether or not the chipEnd event will be emitted when the input is blurred.
                     * @return {?}
                     */
                    get: function () { return this._addOnBlur; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._addOnBlur = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "disabled", {
                    /**
                     * Whether the input is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled || (this._chipList && this._chipList.disabled); },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "empty", {
                    /**
                     * Whether the input is empty.
                     * @return {?}
                     */
                    get: function () { return !this._inputElement.value; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChipInput.prototype.ngOnChanges = function () {
                    this._chipList.stateChanges.next();
                };
                /**
                 * Utility method to make host definition/tests more clear.
                 * @param {?=} event
                 * @return {?}
                 */
                MatChipInput.prototype._keydown = function (event) {
                    // Allow the user's focus to escape when they're tabbing forward. Note that we don't
                    // want to do this when going backwards, because focus should go back to the first chip.
                    if (event && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["TAB"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["hasModifierKey"])(event, 'shiftKey')) {
                        this._chipList._allowFocusEscape();
                    }
                    this._emitChipEnd(event);
                };
                /**
                 * Checks to see if the blur should emit the (chipEnd) event.
                 * @return {?}
                 */
                MatChipInput.prototype._blur = function () {
                    if (this.addOnBlur) {
                        this._emitChipEnd();
                    }
                    this.focused = false;
                    // Blur the chip list if it is not focused
                    if (!this._chipList.focused) {
                        this._chipList._blur();
                    }
                    this._chipList.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatChipInput.prototype._focus = function () {
                    this.focused = true;
                    this._chipList.stateChanges.next();
                };
                /**
                 * Checks to see if the (chipEnd) event needs to be emitted.
                 * @param {?=} event
                 * @return {?}
                 */
                MatChipInput.prototype._emitChipEnd = function (event) {
                    if (!this._inputElement.value && !!event) {
                        this._chipList._keydown(event);
                    }
                    if (!event || this._isSeparatorKey(event)) {
                        this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });
                        if (event) {
                            event.preventDefault();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatChipInput.prototype._onInput = function () {
                    // Let chip list know whenever the value changes.
                    this._chipList.stateChanges.next();
                };
                /**
                 * Focuses the input.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipInput.prototype.focus = function (options) {
                    this._inputElement.focus(options);
                };
                /**
                 * Checks whether a keycode is one of the configured separators.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipInput.prototype._isSeparatorKey = function (event) {
                    if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["hasModifierKey"])(event)) {
                        return false;
                    }
                    /** @type {?} */
                    var separators = this.separatorKeyCodes;
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);
                };
                return MatChipInput;
            }());
            MatChipInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'input[matChipInputFor]',
                            exportAs: 'matChipInput, matChipInputFor',
                            host: {
                                'class': 'mat-chip-input mat-input-element',
                                '(keydown)': '_keydown($event)',
                                '(blur)': '_blur()',
                                '(focus)': '_focus()',
                                '(input)': '_onInput()',
                                '[id]': 'id',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.placeholder]': 'placeholder || null',
                                '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatChipInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }
            ]; };
            MatChipInput.propDecorators = {
                chipList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputFor',] }],
                addOnBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputAddOnBlur',] }],
                separatorKeyCodes: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputSeparatorKeyCodes',] }],
                chipEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"], args: ['matChipInputTokenEnd',] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var CHIP_DECLARATIONS = [
                MatChipList,
                MatChip,
                MatChipInput,
                MatChipRemove,
                MatChipAvatar,
                MatChipTrailingIcon,
            ];
            var ɵ0 = ({
                separatorKeyCodes: [_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["ENTER"]]
            });
            var MatChipsModule = /** @class */ (function () {
                function MatChipsModule() {
                }
                return MatChipsModule;
            }());
            MatChipsModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            exports: CHIP_DECLARATIONS,
                            declarations: CHIP_DECLARATIONS,
                            providers: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["ErrorStateMatcher"],
                                {
                                    provide: MAT_CHIPS_DEFAULT_OPTIONS,
                                    useValue: ( /** @type {?} */(ɵ0))
                                }
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=chips.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/datepicker.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/datepicker.js ***!
          \**************************************************************/
        /*! exports provided: MatMultiYearView, yearsPerPage, yearsPerRow, MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMultiYearView", function () { return MatMultiYearView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yearsPerPage", function () { return yearsPerPage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yearsPerRow", function () { return yearsPerRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerModule", function () { return MatDatepickerModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarHeader", function () { return MatCalendarHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendar", function () { return MatCalendar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarCell", function () { return MatCalendarCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarBody", function () { return MatCalendarBody; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY", function () { return MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY", function () { return MAT_DATEPICKER_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerContent", function () { return MatDatepickerContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepicker", function () { return MatDatepicker; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matDatepickerAnimations", function () { return matDatepickerAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALUE_ACCESSOR", function () { return MAT_DATEPICKER_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALIDATORS", function () { return MAT_DATEPICKER_VALIDATORS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInputEvent", function () { return MatDatepickerInputEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInput", function () { return MatDatepickerInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerIntl", function () { return MatDatepickerIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggleIcon", function () { return MatDatepickerToggleIcon; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggle", function () { return MatDatepickerToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMonthView", function () { return MatMonthView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatYearView", function () { return MatYearView; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/dialog */ "./node_modules/@angular/material/esm2015/dialog.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var _angular_material_input__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/material/input */ "./node_modules/@angular/material/esm2015/input.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} provider
             * @return {?}
             */
            function createMissingDateImplError(provider) {
                return Error("MatDatepicker: No provider found for " + provider + ". You must import one of the following " +
                    "modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a " +
                    "custom implementation.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Datepicker data that requires internationalization.
             */
            var MatDatepickerIntl = /** @class */ (function () {
                function MatDatepickerIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * A label for the calendar popup (used by screen readers).
                     */
                    this.calendarLabel = 'Calendar';
                    /**
                     * A label for the button used to open the calendar popup (used by screen readers).
                     */
                    this.openCalendarLabel = 'Open calendar';
                    /**
                     * A label for the previous month button (used by screen readers).
                     */
                    this.prevMonthLabel = 'Previous month';
                    /**
                     * A label for the next month button (used by screen readers).
                     */
                    this.nextMonthLabel = 'Next month';
                    /**
                     * A label for the previous year button (used by screen readers).
                     */
                    this.prevYearLabel = 'Previous year';
                    /**
                     * A label for the next year button (used by screen readers).
                     */
                    this.nextYearLabel = 'Next year';
                    /**
                     * A label for the previous multi-year button (used by screen readers).
                     */
                    this.prevMultiYearLabel = 'Previous 20 years';
                    /**
                     * A label for the next multi-year button (used by screen readers).
                     */
                    this.nextMultiYearLabel = 'Next 20 years';
                    /**
                     * A label for the 'switch to month view' button (used by screen readers).
                     */
                    this.switchToMonthViewLabel = 'Choose date';
                    /**
                     * A label for the 'switch to year view' button (used by screen readers).
                     */
                    this.switchToMultiYearViewLabel = 'Choose month and year';
                }
                /**
                 * Formats a range of years.
                 * @param {?} start
                 * @param {?} end
                 * @return {?}
                 */
                MatDatepickerIntl.prototype.formatYearRange = function (start, end) {
                    return start + " \u2013 " + end;
                };
                return MatDatepickerIntl;
            }());
            MatDatepickerIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatDatepickerIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatDatepickerIntl_Factory() { return new MatDatepickerIntl(); }, token: MatDatepickerIntl, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * An internal class that represents the data corresponding to a single calendar cell.
             * \@docs-private
             */
            var MatCalendarCell = /** @class */ (function () {
                /**
                 * @param {?} value
                 * @param {?} displayValue
                 * @param {?} ariaLabel
                 * @param {?} enabled
                 * @param {?=} cssClasses
                 */
                function MatCalendarCell(value, displayValue, ariaLabel, enabled, cssClasses) {
                    this.value = value;
                    this.displayValue = displayValue;
                    this.ariaLabel = ariaLabel;
                    this.enabled = enabled;
                    this.cssClasses = cssClasses;
                }
                return MatCalendarCell;
            }());
            /**
             * An internal component used to display calendar data in a table.
             * \@docs-private
             */
            var MatCalendarBody = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 */
                function MatCalendarBody(_elementRef, _ngZone) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    /**
                     * The number of columns in the table.
                     */
                    this.numCols = 7;
                    /**
                     * The cell number of the active cell in the table.
                     */
                    this.activeCell = 0;
                    /**
                     * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
                     * maintained even as the table resizes.
                     */
                    this.cellAspectRatio = 1;
                    /**
                     * Emits when a new value is selected.
                     */
                    this.selectedValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                }
                /**
                 * @param {?} cell
                 * @return {?}
                 */
                MatCalendarBody.prototype._cellClicked = function (cell) {
                    if (cell.enabled) {
                        this.selectedValueChange.emit(cell.value);
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatCalendarBody.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var columnChanges = changes['numCols'];
                    var _a = this, rows = _a.rows, numCols = _a.numCols;
                    if (changes['rows'] || columnChanges) {
                        this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;
                    }
                    if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {
                        this._cellPadding = 50 * this.cellAspectRatio / numCols + "%";
                    }
                    if (columnChanges || !this._cellWidth) {
                        this._cellWidth = 100 / numCols + "%";
                    }
                };
                /**
                 * @param {?} rowIndex
                 * @param {?} colIndex
                 * @return {?}
                 */
                MatCalendarBody.prototype._isActiveCell = function (rowIndex, colIndex) {
                    /** @type {?} */
                    var cellNumber = rowIndex * this.numCols + colIndex;
                    // Account for the fact that the first row may not have as many cells.
                    if (rowIndex) {
                        cellNumber -= this._firstRowOffset;
                    }
                    return cellNumber == this.activeCell;
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatCalendarBody.prototype._focusActiveCell = function () {
                    var _this = this;
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        _this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var activeCell = _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');
                            if (activeCell) {
                                activeCell.focus();
                            }
                        }));
                    }));
                };
                return MatCalendarBody;
            }());
            MatCalendarBody.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: '[mat-calendar-body]',
                            template: "<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\"><td class=\"mat-calendar-body-label\" [attr.colspan]=\"numCols\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{label}}</td></tr><tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\"><td *ngIf=\"rowIndex === 0 && _firstRowOffset\" aria-hidden=\"true\" class=\"mat-calendar-body-label\" [attr.colspan]=\"_firstRowOffset\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{_firstRowOffset >= labelMinRequiredCells ? label : ''}}</td><td *ngFor=\"let item of row; let colIndex = index\" role=\"gridcell\" class=\"mat-calendar-body-cell\" [ngClass]=\"item.cssClasses\" [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\" [class.mat-calendar-body-disabled]=\"!item.enabled\" [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\" [attr.aria-label]=\"item.ariaLabel\" [attr.aria-disabled]=\"!item.enabled || null\" [attr.aria-selected]=\"selectedValue === item.value\" (click)=\"_cellClicked(item)\" [style.width]=\"_cellWidth\" [style.paddingTop]=\"_cellPadding\" role=\"button\" [style.paddingBottom]=\"_cellPadding\"><div class=\"mat-calendar-body-cell-content\" [class.mat-calendar-body-selected]=\"selectedValue === item.value\" [class.mat-calendar-body-today]=\"todayValue === item.value\">{{item.displayValue}}</div></td></tr>",
                            styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}}[dir=rtl] .mat-calendar-body-label{text-align:right}"],
                            host: {
                                'class': 'mat-calendar-body',
                                'role': 'grid',
                                'aria-readonly': 'true'
                            },
                            exportAs: 'matCalendarBody',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendarBody.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] }
            ]; };
            MatCalendarBody.propDecorators = {
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                rows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                todayValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelMinRequiredCells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                numCols: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                activeCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                cellAspectRatio: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedValueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DAYS_PER_WEEK = 7;
            /**
             * An internal component used to display a single month in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatMonthView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateFormats
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateFormats = _dateFormats;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new date is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is selected.
                     */
                    this._userSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatMonthView.prototype, "activeDate", {
                    /**
                     * The date to display in this month view (everything other than the month and year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedDate = this._getDateInCurrentMonth(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMonthView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Handles when a new date is selected.
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._dateSelected = function (date) {
                    if (this._selectedDate != date) {
                        /** @type {?} */
                        var selectedYear = this._dateAdapter.getYear(this.activeDate);
                        /** @type {?} */
                        var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                        /** @type {?} */
                        var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                        this.selectedChange.emit(selectedDate);
                    }
                    this._userSelection.emit();
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in month view.
                 * @param {?} event
                 * @return {?}
                 */
                MatMonthView.prototype._handleCalendarBodyKeydown = function (event) {
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -
                                this._dateAdapter.getDate(this._activeDate)));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate = event.altKey ?
                                this._dateAdapter.addCalendarYears(this._activeDate, -1) :
                                this._dateAdapter.addCalendarMonths(this._activeDate, -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate = event.altKey ?
                                this._dateAdapter.addCalendarYears(this._activeDate, 1) :
                                this._dateAdapter.addCalendarMonths(this._activeDate, 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            if (!this.dateFilter || this.dateFilter(this._activeDate)) {
                                this._dateSelected(this._dateAdapter.getDate(this._activeDate));
                                this._userSelection.emit();
                                // Prevent unexpected default actions such as form submission.
                                event.preventDefault();
                            }
                            return;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * Initializes this month view.
                 * @return {?}
                 */
                MatMonthView.prototype._init = function () {
                    this._selectedDate = this._getDateInCurrentMonth(this.selected);
                    this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
                    this._monthLabel =
                        this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]
                            .toLocaleUpperCase();
                    /** @type {?} */
                    var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
                    this._firstWeekOffset =
                        (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -
                            this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
                    this._initWeekdays();
                    this._createWeekCells();
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatMonthView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Initializes the weekdays.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._initWeekdays = function () {
                    /** @type {?} */
                    var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
                    /** @type {?} */
                    var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');
                    /** @type {?} */
                    var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');
                    // Rotate the labels for days of the week based on the configured first day of the week.
                    /** @type {?} */
                    var weekdays = longWeekdays.map(( /**
                     * @param {?} long
                     * @param {?} i
                     * @return {?}
                     */function (long, i) {
                        return { long: long, narrow: narrowWeekdays[i] };
                    }));
                    this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
                };
                /**
                 * Creates MatCalendarCells for the dates in this month.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._createWeekCells = function () {
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
                    /** @type {?} */
                    var dateNames = this._dateAdapter.getDateNames();
                    this._weeks = [[]];
                    for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                        if (cell == DAYS_PER_WEEK) {
                            this._weeks.push([]);
                            cell = 0;
                        }
                        /** @type {?} */
                        var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);
                        /** @type {?} */
                        var enabled = this._shouldEnableDate(date);
                        /** @type {?} */
                        var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);
                        /** @type {?} */
                        var cellClasses = this.dateClass ? this.dateClass(date) : undefined;
                        this._weeks[this._weeks.length - 1]
                            .push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses));
                    }
                };
                /**
                 * Date filter for the month
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._shouldEnableDate = function (date) {
                    return !!date &&
                        (!this.dateFilter || this.dateFilter(date)) &&
                        (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
                        (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);
                };
                /**
                 * Gets the date in this month that the given Date falls on.
                 * Returns null if the given Date is in another month.
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._getDateInCurrentMonth = function (date) {
                    return date && this._hasSameMonthAndYear(date, this.activeDate) ?
                        this._dateAdapter.getDate(date) : null;
                };
                /**
                 * Checks whether the 2 dates are non-null and fall within the same month of the same year.
                 * @private
                 * @param {?} d1
                 * @param {?} d2
                 * @return {?}
                 */
                MatMonthView.prototype._hasSameMonthAndYear = function (d1, d2) {
                    return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&
                        this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatMonthView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatMonthView;
            }());
            MatMonthView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-month-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th scope=\"col\" *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th></tr><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"7\" aria-hidden=\"true\"></th></tr></thead><tbody mat-calendar-body [label]=\"_monthLabel\" [rows]=\"_weeks\" [todayValue]=\"_todayDate\" [selectedValue]=\"_selectedDate\" [labelMinRequiredCells]=\"3\" [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\" (selectedValueChange)=\"_dateSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matMonthView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatMonthView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatMonthView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _userSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var yearsPerPage = 24;
            /** @type {?} */
            var yearsPerRow = 4;
            /**
             * An internal component used to display a year selector in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatMultiYearView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new year is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the selected year. This doesn't imply a change on the selected date
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatMultiYearView.prototype, "activeDate", {
                    /**
                     * The date to display in this multi-year view (everything other than the year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMultiYearView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Initializes this multi-year view.
                 * @return {?}
                 */
                MatMultiYearView.prototype._init = function () {
                    var _this = this;
                    this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
                    // We want a range years such that we maximize the number of
                    // enabled dates visible at once. This prevents issues where the minimum year
                    // is the last item of a page OR the maximum year is the first item of a page.
                    // The offset from the active year to the "slot" for the starting year is the
                    // *actual* first rendered year in the multi-year view.
                    /** @type {?} */
                    var activeYear = this._dateAdapter.getYear(this._activeDate);
                    /** @type {?} */
                    var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                    this._years = [];
                    for (var i = 0, row = []; i < yearsPerPage; i++) {
                        row.push(minYearOfPage + i);
                        if (row.length == yearsPerRow) {
                            this._years.push(row.map(( /**
                             * @param {?} year
                             * @return {?}
                             */function (/**
                             * @param {?} year
                             * @return {?}
                             */ year) { return _this._createCellForYear(year); })));
                            row = [];
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Handles when a new year is selected.
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._yearSelected = function (year) {
                    this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
                    /** @type {?} */
                    var month = this._dateAdapter.getMonth(this.activeDate);
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));
                    this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in multi-year view.
                 * @param {?} event
                 * @return {?}
                 */
                MatMultiYearView.prototype._handleCalendarBodyKeydown = function (event) {
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            this._yearSelected(this._dateAdapter.getYear(this._activeDate));
                            break;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * @return {?}
                 */
                MatMultiYearView.prototype._getActiveCell = function () {
                    return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatMultiYearView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Creates an MatCalendarCell for the given year.
                 * @private
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._createCellForYear = function (year) {
                    /** @type {?} */
                    var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));
                    return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
                };
                /**
                 * Whether the given year is enabled.
                 * @private
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._shouldEnableYear = function (year) {
                    // disable if the year is greater than maxDate lower than minDate
                    if (year === undefined || year === null ||
                        (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
                        (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {
                        return false;
                    }
                    // enable if it reaches here and there's no filter defined
                    if (!this.dateFilter) {
                        return true;
                    }
                    /** @type {?} */
                    var firstOfYear = this._dateAdapter.createDate(year, 0, 1);
                    // If any date in the year is enabled count the year as enabled.
                    for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {
                        if (this.dateFilter(date)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatMultiYearView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatMultiYearView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatMultiYearView;
            }());
            MatMultiYearView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-multi-year-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [rows]=\"_years\" [todayValue]=\"_todayYear\" [selectedValue]=\"_selectedYear\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_getActiveCell()\" (selectedValueChange)=\"_yearSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matMultiYearView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatMultiYearView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatMultiYearView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @template D
             * @param {?} dateAdapter
             * @param {?} date1
             * @param {?} date2
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {
                /** @type {?} */
                var year1 = dateAdapter.getYear(date1);
                /** @type {?} */
                var year2 = dateAdapter.getYear(date2);
                /** @type {?} */
                var startingYear = getStartingYear(dateAdapter, minDate, maxDate);
                return Math.floor((year1 - startingYear) / yearsPerPage) ===
                    Math.floor((year2 - startingYear) / yearsPerPage);
            }
            /**
             * When the multi-year view is first opened, the active year will be in view.
             * So we compute how many years are between the active year and the *slot* where our
             * "startingYear" will render when paged into view.
             * @template D
             * @param {?} dateAdapter
             * @param {?} activeDate
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {
                /** @type {?} */
                var activeYear = dateAdapter.getYear(activeDate);
                return euclideanModulo((activeYear - getStartingYear(dateAdapter, minDate, maxDate)), yearsPerPage);
            }
            /**
             * We pick a "starting" year such that either the maximum year would be at the end
             * or the minimum year would be at the beginning of a page.
             * @template D
             * @param {?} dateAdapter
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function getStartingYear(dateAdapter, minDate, maxDate) {
                /** @type {?} */
                var startingYear = 0;
                if (maxDate) {
                    /** @type {?} */
                    var maxYear = dateAdapter.getYear(maxDate);
                    startingYear = maxYear - yearsPerPage + 1;
                }
                else if (minDate) {
                    startingYear = dateAdapter.getYear(minDate);
                }
                return startingYear;
            }
            /**
             * Gets remainder that is non-negative, even if first number is negative
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function euclideanModulo(a, b) {
                return (a % b + b) % b;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * An internal component used to display a single year in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatYearView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateFormats
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateFormats = _dateFormats;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new month is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the selected month. This doesn't imply a change on the selected date
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatYearView.prototype, "activeDate", {
                    /**
                     * The date to display in this year view (everything other than the year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedMonth = this._getMonthInCurrentYear(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatYearView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Handles when a new month is selected.
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._monthSelected = function (month) {
                    /** @type {?} */
                    var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);
                    this.monthSelected.emit(normalizedDate);
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
                    this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in year view.
                 * @param {?} event
                 * @return {?}
                 */
                MatYearView.prototype._handleCalendarBodyKeydown = function (event) {
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
                            break;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * Initializes this year view.
                 * @return {?}
                 */
                MatYearView.prototype._init = function () {
                    var _this = this;
                    this._selectedMonth = this._getMonthInCurrentYear(this.selected);
                    this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
                    this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
                    /** @type {?} */
                    var monthNames = this._dateAdapter.getMonthNames('short');
                    // First row of months only contains 5 elements so we can fit the year label on the same row.
                    this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(( /**
                     * @param {?} row
                     * @return {?}
                     */function (/**
                     * @param {?} row
                     * @return {?}
                     */ row) { return row.map(( /**
                     * @param {?} month
                     * @return {?}
                     */function (/**
                     * @param {?} month
                     * @return {?}
                     */ month) { return _this._createCellForMonth(month, monthNames[month]); })); }));
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatYearView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Gets the month in this year that the given Date falls on.
                 * Returns null if the given Date is in another year.
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatYearView.prototype._getMonthInCurrentYear = function (date) {
                    return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?
                        this._dateAdapter.getMonth(date) : null;
                };
                /**
                 * Creates an MatCalendarCell for the given month.
                 * @private
                 * @param {?} month
                 * @param {?} monthName
                 * @return {?}
                 */
                MatYearView.prototype._createCellForMonth = function (month, monthName) {
                    /** @type {?} */
                    var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);
                    return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));
                };
                /**
                 * Whether the given month is enabled.
                 * @private
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._shouldEnableMonth = function (month) {
                    /** @type {?} */
                    var activeYear = this._dateAdapter.getYear(this.activeDate);
                    if (month === undefined || month === null ||
                        this._isYearAndMonthAfterMaxDate(activeYear, month) ||
                        this._isYearAndMonthBeforeMinDate(activeYear, month)) {
                        return false;
                    }
                    if (!this.dateFilter) {
                        return true;
                    }
                    /** @type {?} */
                    var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
                    // If any date in the month is enabled count the month as enabled.
                    for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {
                        if (this.dateFilter(date)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Tests whether the combination month/year is after this.maxDate, considering
                 * just the month and year of this.maxDate
                 * @private
                 * @param {?} year
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._isYearAndMonthAfterMaxDate = function (year, month) {
                    if (this.maxDate) {
                        /** @type {?} */
                        var maxYear = this._dateAdapter.getYear(this.maxDate);
                        /** @type {?} */
                        var maxMonth = this._dateAdapter.getMonth(this.maxDate);
                        return year > maxYear || (year === maxYear && month > maxMonth);
                    }
                    return false;
                };
                /**
                 * Tests whether the combination month/year is before this.minDate, considering
                 * just the month and year of this.minDate
                 * @private
                 * @param {?} year
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._isYearAndMonthBeforeMinDate = function (year, month) {
                    if (this.minDate) {
                        /** @type {?} */
                        var minYear = this._dateAdapter.getYear(this.minDate);
                        /** @type {?} */
                        var minMonth = this._dateAdapter.getMonth(this.minDate);
                        return year < minYear || (year === minYear && month < minMonth);
                    }
                    return false;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatYearView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatYearView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatYearView;
            }());
            MatYearView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-year-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [label]=\"_yearLabel\" [rows]=\"_months\" [todayValue]=\"_todayMonth\" [selectedValue]=\"_selectedMonth\" [labelMinRequiredCells]=\"2\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_dateAdapter.getMonth(activeDate)\" (selectedValueChange)=\"_monthSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matYearView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatYearView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatYearView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Default header for MatCalendar
             * @template D
             */
            var MatCalendarHeader = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} calendar
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} changeDetectorRef
                 */
                function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
                    this._intl = _intl;
                    this.calendar = calendar;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this.calendar.stateChanges.subscribe(( /**
                     * @return {?}
                     */function () { return changeDetectorRef.markForCheck(); }));
                }
                Object.defineProperty(MatCalendarHeader.prototype, "periodButtonText", {
                    /**
                     * The label for the current calendar view.
                     * @return {?}
                     */
                    get: function () {
                        if (this.calendar.currentView == 'month') {
                            return this._dateAdapter
                                .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                                .toLocaleUpperCase();
                        }
                        if (this.calendar.currentView == 'year') {
                            return this._dateAdapter.getYearName(this.calendar.activeDate);
                        }
                        // The offset from the active year to the "slot" for the starting year is the
                        // *actual* first rendered year in the multi-year view, and the last year is
                        // just yearsPerPage - 1 away.
                        /** @type {?} */
                        var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
                        /** @type {?} */
                        var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);
                        /** @type {?} */
                        var maxYearOfPage = minYearOfPage + yearsPerPage - 1;
                        /** @type {?} */
                        var minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));
                        /** @type {?} */
                        var maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));
                        return this._intl.formatYearRange(minYearName, maxYearName);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "periodButtonLabel", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this.calendar.currentView == 'month' ?
                            this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "prevButtonLabel", {
                    /**
                     * The label for the previous button.
                     * @return {?}
                     */
                    get: function () {
                        return {
                            'month': this._intl.prevMonthLabel,
                            'year': this._intl.prevYearLabel,
                            'multi-year': this._intl.prevMultiYearLabel
                        }[this.calendar.currentView];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "nextButtonLabel", {
                    /**
                     * The label for the next button.
                     * @return {?}
                     */
                    get: function () {
                        return {
                            'month': this._intl.nextMonthLabel,
                            'year': this._intl.nextYearLabel,
                            'multi-year': this._intl.nextMultiYearLabel
                        }[this.calendar.currentView];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Handles user clicks on the period label.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.currentPeriodClicked = function () {
                    this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';
                };
                /**
                 * Handles user clicks on the previous button.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.previousClicked = function () {
                    this.calendar.activeDate = this.calendar.currentView == 'month' ?
                        this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :
                        this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
                };
                /**
                 * Handles user clicks on the next button.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.nextClicked = function () {
                    this.calendar.activeDate = this.calendar.currentView == 'month' ?
                        this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :
                        this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
                };
                /**
                 * Whether the previous period button is enabled.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.previousEnabled = function () {
                    if (!this.calendar.minDate) {
                        return true;
                    }
                    return !this.calendar.minDate ||
                        !this._isSameView(this.calendar.activeDate, this.calendar.minDate);
                };
                /**
                 * Whether the next period button is enabled.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.nextEnabled = function () {
                    return !this.calendar.maxDate ||
                        !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);
                };
                /**
                 * Whether the two dates represent the same view in the current view mode (month or year).
                 * @private
                 * @param {?} date1
                 * @param {?} date2
                 * @return {?}
                 */
                MatCalendarHeader.prototype._isSameView = function (date1, date2) {
                    if (this.calendar.currentView == 'month') {
                        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                            this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);
                    }
                    if (this.calendar.currentView == 'year') {
                        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
                    }
                    // Otherwise we are in 'multi-year' view.
                    return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);
                };
                return MatCalendarHeader;
            }());
            MatCalendarHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-calendar-header',
                            template: "<div class=\"mat-calendar-header\"><div class=\"mat-calendar-controls\"><button mat-button type=\"button\" class=\"mat-calendar-period-button\" (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\" cdkAriaLive=\"polite\">{{periodButtonText}}<div class=\"mat-calendar-arrow\" [class.mat-calendar-invert]=\"calendar.currentView != 'month'\"></div></button><div class=\"mat-calendar-spacer\"></div><ng-content></ng-content><button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\" [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\" [attr.aria-label]=\"prevButtonLabel\"></button> <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\" [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\" [attr.aria-label]=\"nextButtonLabel\"></button></div></div>",
                            exportAs: 'matCalendarHeader',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendarHeader.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: MatCalendar, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatCalendar; })),] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            /**
             * A calendar that is used as part of the datepicker.
             * \@docs-private
             * @template D
             */
            var MatCalendar = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} _changeDetectorRef
                 */
                function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
                    var _this = this;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Used for scheduling that focus should be moved to the active cell on the next tick.
                     * We need to schedule it, rather than do it immediately, because we have to wait
                     * for Angular to re-evaluate the view children.
                     */
                    this._moveFocusOnNextTick = false;
                    /**
                     * Whether the calendar should be started in month or year view.
                     */
                    this.startView = 'month';
                    /**
                     * Emits when the currently selected date changes.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the year chosen in multiyear view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the month chosen in year view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is selected.
                     */
                    this._userSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits whenever there is a state change that the header may need to respond to.
                     */
                    this.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._intlChanges = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () {
                        _changeDetectorRef.markForCheck();
                        _this.stateChanges.next();
                    }));
                }
                Object.defineProperty(MatCalendar.prototype, "startAt", {
                    /**
                     * A date representing the period (month or year) to start the calendar in.
                     * @return {?}
                     */
                    get: function () { return this._startAt; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "activeDate", {
                    /**
                     * The current active date. This determines which time period is shown and which date is
                     * highlighted when using keyboard navigation.
                     * @return {?}
                     */
                    get: function () { return this._clampedActiveDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
                        this.stateChanges.next();
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "currentView", {
                    /**
                     * Whether the calendar is in month view.
                     * @return {?}
                     */
                    get: function () { return this._currentView; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._currentView = value;
                        this._moveFocusOnNextTick = true;
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngAfterContentInit = function () {
                    this._calendarHeaderPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["ComponentPortal"](this.headerComponent || MatCalendarHeader);
                    this.activeDate = this.startAt || this._dateAdapter.today();
                    // Assign to the private property since we don't want to move focus on init.
                    this._currentView = this.startView;
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngAfterViewChecked = function () {
                    if (this._moveFocusOnNextTick) {
                        this._moveFocusOnNextTick = false;
                        this.focusActiveCell();
                    }
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngOnDestroy = function () {
                    this._intlChanges.unsubscribe();
                    this.stateChanges.complete();
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatCalendar.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];
                    if (change && !change.firstChange) {
                        /** @type {?} */
                        var view = this._getCurrentViewComponent();
                        if (view) {
                            // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                            // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                            this._changeDetectorRef.detectChanges();
                            view._init();
                        }
                    }
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.focusActiveCell = function () {
                    this._getCurrentViewComponent()._focusActiveCell();
                };
                /**
                 * Updates today's date after an update of the active date
                 * @return {?}
                 */
                MatCalendar.prototype.updateTodaysDate = function () {
                    /** @type {?} */
                    var view = this.currentView == 'month' ? this.monthView :
                        (this.currentView == 'year' ? this.yearView : this.multiYearView);
                    view.ngAfterContentInit();
                };
                /**
                 * Handles date selection in the month view.
                 * @param {?} date
                 * @return {?}
                 */
                MatCalendar.prototype._dateSelected = function (date) {
                    if (!this._dateAdapter.sameDate(date, this.selected)) {
                        this.selectedChange.emit(date);
                    }
                };
                /**
                 * Handles year selection in the multiyear view.
                 * @param {?} normalizedYear
                 * @return {?}
                 */
                MatCalendar.prototype._yearSelectedInMultiYearView = function (normalizedYear) {
                    this.yearSelected.emit(normalizedYear);
                };
                /**
                 * Handles month selection in the year view.
                 * @param {?} normalizedMonth
                 * @return {?}
                 */
                MatCalendar.prototype._monthSelectedInYearView = function (normalizedMonth) {
                    this.monthSelected.emit(normalizedMonth);
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype._userSelected = function () {
                    this._userSelection.emit();
                };
                /**
                 * Handles year/month selection in the multi-year/year views.
                 * @param {?} date
                 * @param {?} view
                 * @return {?}
                 */
                MatCalendar.prototype._goToDateInView = function (date, view) {
                    this.activeDate = date;
                    this.currentView = view;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatCalendar.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Returns the component instance that corresponds to the current calendar view.
                 * @private
                 * @return {?}
                 */
                MatCalendar.prototype._getCurrentViewComponent = function () {
                    return this.monthView || this.yearView || this.multiYearView;
                };
                return MatCalendar;
            }());
            MatCalendar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-calendar',
                            template: "<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template><div class=\"mat-calendar-content\" [ngSwitch]=\"currentView\" cdkMonitorSubtreeFocus tabindex=\"-1\"><mat-month-view *ngSwitchCase=\"'month'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" [dateClass]=\"dateClass\" (selectedChange)=\"_dateSelected($event)\" (_userSelection)=\"_userSelected()\"></mat-month-view><mat-year-view *ngSwitchCase=\"'year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (monthSelected)=\"_monthSelectedInYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'month')\"></mat-year-view><mat-multi-year-view *ngSwitchCase=\"'multi-year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (yearSelected)=\"_yearSelectedInMultiYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'year')\"></mat-multi-year-view></div>",
                            styles: [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}"],
                            host: {
                                'class': 'mat-calendar',
                            },
                            exportAs: 'matCalendar',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendar.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatCalendar.propDecorators = {
                headerComponent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startAt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _userSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatMonthView, { static: false },] }],
                yearView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatYearView, { static: false },] }],
                multiYearView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatMultiYearView, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material datepicker.
             * \@docs-private
             * @type {?}
             */
            var matDatepickerAnimations = {
                /**
                 * Transforms the height of the datepicker's calendar.
                 */
                transformPanel: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["trigger"])('transformPanel', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({
                        opacity: 0,
                        transform: 'scale(1, 0.8)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('void => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('120ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({
                        opacity: 1,
                        transform: 'scale(1, 1)'
                    }))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('100ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 0 })))
                ]),
                /**
                 * Fades in the content of the calendar.
                 */
                fadeInCalendar: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["trigger"])('fadeInCalendar', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 0 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 1 })),
                    // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we
                    // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate a unique ID for each datepicker instance.
             * @type {?}
             */
            var datepickerUid = 0;
            /**
             * Injection token that determines the scroll handling while the calendar is open.
             * @type {?}
             */
            var MAT_DATEPICKER_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-datepicker-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_DATEPICKER_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"]],
                useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,
            };
            // Boilerplate for applying mixins to MatDatepickerContent.
            /**
             * \@docs-private
             */
            var MatDatepickerContentBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatDatepickerContentBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatDatepickerContentBase;
            }());
            /** @type {?} */
            var _MatDatepickerContentMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(MatDatepickerContentBase);
            /**
             * Component used as the content for the datepicker dialog and popup. We use this instead of using
             * MatCalendar directly as the content so we can control the initial focus. This also gives us a
             * place to put additional features of the popup that are not part of the calendar itself in the
             * future. (e.g. confirmation buttons).
             * \@docs-private
             * @template D
             */
            var MatDatepickerContent = /** @class */ (function (_super) {
                __extends(MatDatepickerContent, _super);
                /**
                 * @param {?} elementRef
                 */
                function MatDatepickerContent(elementRef) {
                    return _super.call(this, elementRef) || this;
                }
                /**
                 * @return {?}
                 */
                MatDatepickerContent.prototype.ngAfterViewInit = function () {
                    this._calendar.focusActiveCell();
                };
                return MatDatepickerContent;
            }(_MatDatepickerContentMixinBase));
            MatDatepickerContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker-content',
                            template: "<mat-calendar cdkTrapFocus [id]=\"datepicker.id\" [ngClass]=\"datepicker.panelClass\" [startAt]=\"datepicker.startAt\" [startView]=\"datepicker.startView\" [minDate]=\"datepicker._minDate\" [maxDate]=\"datepicker._maxDate\" [dateFilter]=\"datepicker._dateFilter\" [headerComponent]=\"datepicker.calendarHeaderComponent\" [selected]=\"datepicker._selected\" [dateClass]=\"datepicker.dateClass\" [@fadeInCalendar]=\"'enter'\" (selectedChange)=\"datepicker.select($event)\" (yearSelected)=\"datepicker._selectYear($event)\" (monthSelected)=\"datepicker._selectMonth($event)\" (_userSelection)=\"datepicker.close()\"></mat-calendar>",
                            styles: [".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"],
                            host: {
                                'class': 'mat-datepicker-content',
                                '[@transformPanel]': '"enter"',
                                '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                            },
                            animations: [
                                matDatepickerAnimations.transformPanel,
                                matDatepickerAnimations.fadeInCalendar,
                            ],
                            exportAs: 'matDatepickerContent',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['color'],
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            MatDatepickerContent.propDecorators = {
                _calendar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendar, { static: false },] }]
            };
            // TODO(mmalerba): We use a component instead of a directive here so the user can use implicit
            // template reference variables (e.g. #d vs #d="matDatepicker"). We can change this to a directive
            // if angular adds support for `exportAs: '$implicit'` on directives.
            /**
             * Component responsible for managing the datepicker popup/dialog.
             * @template D
             */
            var MatDatepicker = /** @class */ (function () {
                /**
                 * @param {?} _dialog
                 * @param {?} _overlay
                 * @param {?} _ngZone
                 * @param {?} _viewContainerRef
                 * @param {?} scrollStrategy
                 * @param {?} _dateAdapter
                 * @param {?} _dir
                 * @param {?} _document
                 */
                function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {
                    this._dialog = _dialog;
                    this._overlay = _overlay;
                    this._ngZone = _ngZone;
                    this._viewContainerRef = _viewContainerRef;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    this._document = _document;
                    /**
                     * The view that the calendar should start in.
                     */
                    this.startView = 'month';
                    this._touchUi = false;
                    /**
                     * Emits selected year in multiyear view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits selected month in year view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the datepicker has been opened.
                     */
                    this.openedStream = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the datepicker has been closed.
                     */
                    this.closedStream = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._opened = false;
                    /**
                     * The id for the datepicker calendar.
                     */
                    this.id = "mat-datepicker-" + datepickerUid++;
                    this._validSelected = null;
                    /**
                     * The element that was focused before the datepicker was opened.
                     */
                    this._focusedElementBeforeOpen = null;
                    /**
                     * Subscription to value changes in the associated input element.
                     */
                    this._inputSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * Emits when the datepicker is disabled.
                     */
                    this._disabledChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * Emits new selected date when selected date changes.
                     */
                    this._selectedChanged = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatDatepicker.prototype, "startAt", {
                    /**
                     * The date to open the calendar to initially.
                     * @return {?}
                     */
                    get: function () {
                        // If an explicit startAt is set we start there, otherwise we start at whatever the currently
                        // selected value is.
                        return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "color", {
                    /**
                     * Color palette to use on the datepicker's calendar.
                     * @return {?}
                     */
                    get: function () {
                        return this._color ||
                            (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "touchUi", {
                    /**
                     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
                     * than a popup and elements have more padding to allow for bigger touch targets.
                     * @return {?}
                     */
                    get: function () { return this._touchUi; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._touchUi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "disabled", {
                    /**
                     * Whether the datepicker pop-up should be disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled === undefined && this._datepickerInput ?
                            this._datepickerInput.disabled : !!this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                        if (newValue !== this._disabled) {
                            this._disabled = newValue;
                            this._disabledChange.next(newValue);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "opened", {
                    /**
                     * Whether the calendar is open.
                     * @return {?}
                     */
                    get: function () { return this._opened; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { value ? this.open() : this.close(); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._validSelected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._validSelected = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput.min;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput.max;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_dateFilter", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput._dateFilter;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDatepicker.prototype.ngOnDestroy = function () {
                    this.close();
                    this._inputSubscription.unsubscribe();
                    this._disabledChange.complete();
                    if (this._popupRef) {
                        this._popupRef.dispose();
                        this._popupComponentRef = null;
                    }
                };
                /**
                 * Selects the given date
                 * @param {?} date
                 * @return {?}
                 */
                MatDatepicker.prototype.select = function (date) {
                    /** @type {?} */
                    var oldValue = this._selected;
                    this._selected = date;
                    if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
                        this._selectedChanged.next(date);
                    }
                };
                /**
                 * Emits the selected year in multiyear view
                 * @param {?} normalizedYear
                 * @return {?}
                 */
                MatDatepicker.prototype._selectYear = function (normalizedYear) {
                    this.yearSelected.emit(normalizedYear);
                };
                /**
                 * Emits selected month in year view
                 * @param {?} normalizedMonth
                 * @return {?}
                 */
                MatDatepicker.prototype._selectMonth = function (normalizedMonth) {
                    this.monthSelected.emit(normalizedMonth);
                };
                /**
                 * Register an input with this datepicker.
                 * @param {?} input The datepicker input to register with this datepicker.
                 * @return {?}
                 */
                MatDatepicker.prototype._registerInput = function (input) {
                    var _this = this;
                    if (this._datepickerInput) {
                        throw Error('A MatDatepicker can only be associated with a single input.');
                    }
                    this._datepickerInput = input;
                    this._inputSubscription =
                        this._datepickerInput._valueChange.subscribe(( /**
                         * @param {?} value
                         * @return {?}
                         */function (value) { return _this._selected = value; }));
                };
                /**
                 * Open the calendar.
                 * @return {?}
                 */
                MatDatepicker.prototype.open = function () {
                    if (this._opened || this.disabled) {
                        return;
                    }
                    if (!this._datepickerInput) {
                        throw Error('Attempted to open an MatDatepicker with no associated input.');
                    }
                    if (this._document) {
                        this._focusedElementBeforeOpen = this._document.activeElement;
                    }
                    this.touchUi ? this._openAsDialog() : this._openAsPopup();
                    this._opened = true;
                    this.openedStream.emit();
                };
                /**
                 * Close the calendar.
                 * @return {?}
                 */
                MatDatepicker.prototype.close = function () {
                    var _this = this;
                    if (!this._opened) {
                        return;
                    }
                    if (this._popupRef && this._popupRef.hasAttached()) {
                        this._popupRef.detach();
                    }
                    if (this._dialogRef) {
                        this._dialogRef.close();
                        this._dialogRef = null;
                    }
                    if (this._calendarPortal && this._calendarPortal.isAttached) {
                        this._calendarPortal.detach();
                    }
                    /** @type {?} */
                    var completeClose = ( /**
                     * @return {?}
                     */function () {
                        // The `_opened` could've been reset already if
                        // we got two events in quick succession.
                        if (_this._opened) {
                            _this._opened = false;
                            _this.closedStream.emit();
                            _this._focusedElementBeforeOpen = null;
                        }
                    });
                    if (this._focusedElementBeforeOpen &&
                        typeof this._focusedElementBeforeOpen.focus === 'function') {
                        // Because IE moves focus asynchronously, we can't count on it being restored before we've
                        // marked the datepicker as closed. If the event fires out of sequence and the element that
                        // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                        // able to close the calendar at all. We work around it by making the logic, that marks
                        // the datepicker as closed, async as well.
                        this._focusedElementBeforeOpen.focus();
                        setTimeout(completeClose);
                    }
                    else {
                        completeClose();
                    }
                };
                /**
                 * Open the calendar as a dialog.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._openAsDialog = function () {
                    var _this = this;
                    // Usually this would be handled by `open` which ensures that we can only have one overlay
                    // open at a time, however since we reset the variables in async handlers some overlays
                    // may slip through if the user opens and closes multiple times in quick succession (e.g.
                    // by holding down the enter key).
                    if (this._dialogRef) {
                        this._dialogRef.close();
                    }
                    this._dialogRef = this._dialog.open(MatDatepickerContent, {
                        direction: this._dir ? this._dir.value : 'ltr',
                        viewContainerRef: this._viewContainerRef,
                        panelClass: 'mat-datepicker-dialog',
                    });
                    this._dialogRef.afterClosed().subscribe(( /**
                     * @return {?}
                     */function () { return _this.close(); }));
                    this._dialogRef.componentInstance.datepicker = this;
                    this._setColor();
                };
                /**
                 * Open the calendar as a popup.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._openAsPopup = function () {
                    var _this = this;
                    if (!this._calendarPortal) {
                        this._calendarPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["ComponentPortal"](MatDatepickerContent, this._viewContainerRef);
                    }
                    if (!this._popupRef) {
                        this._createPopup();
                    }
                    if (!this._popupRef.hasAttached()) {
                        this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
                        this._popupComponentRef.instance.datepicker = this;
                        this._setColor();
                        // Update the position once the calendar has rendered.
                        this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._popupRef.updatePosition();
                        }));
                    }
                };
                /**
                 * Create the popup.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._createPopup = function () {
                    var _this = this;
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayConfig"]({
                        positionStrategy: this._createPopupPositionStrategy(),
                        hasBackdrop: true,
                        backdropClass: 'mat-overlay-transparent-backdrop',
                        direction: this._dir,
                        scrollStrategy: this._scrollStrategy(),
                        panelClass: 'mat-datepicker-popup',
                    });
                    this._popupRef = this._overlay.create(overlayConfig);
                    this._popupRef.overlayElement.setAttribute('role', 'dialog');
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        // Closing on alt + up is only valid when there's an input associated with the datepicker.
                        return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ESCAPE"] ||
                            (_this._datepickerInput && event.altKey && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]);
                    })))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (event) {
                            event.preventDefault();
                        }
                        _this.close();
                    }));
                };
                /**
                 * Create the popup PositionStrategy.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._createPopupPositionStrategy = function () {
                    return this._overlay.position()
                        .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                        .withTransformOriginOn('.mat-datepicker-content')
                        .withFlexibleDimensions(false)
                        .withViewportMargin(8)
                        .withLockedPosition()
                        .withPositions([
                        {
                            originX: 'start',
                            originY: 'bottom',
                            overlayX: 'start',
                            overlayY: 'top'
                        },
                        {
                            originX: 'start',
                            originY: 'top',
                            overlayX: 'start',
                            overlayY: 'bottom'
                        },
                        {
                            originX: 'end',
                            originY: 'bottom',
                            overlayX: 'end',
                            overlayY: 'top'
                        },
                        {
                            originX: 'end',
                            originY: 'top',
                            overlayX: 'end',
                            overlayY: 'bottom'
                        }
                    ]);
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatDatepicker.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Passes the current theme color along to the calendar overlay.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._setColor = function () {
                    /** @type {?} */
                    var color = this.color;
                    if (this._popupComponentRef) {
                        this._popupComponentRef.instance.color = color;
                    }
                    if (this._dialogRef) {
                        this._dialogRef.componentInstance.color = color;
                    }
                };
                return MatDatepicker;
            }());
            MatDatepicker.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker',
                            template: '',
                            exportAs: 'matDatepicker',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatDatepicker.ctorParameters = function () { return [
                { type: _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__["MatDialog"] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["DOCUMENT"],] }] }
            ]; };
            MatDatepicker.propDecorators = {
                calendarHeaderComponent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startAt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                touchUi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                openedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"], args: ['opened',] }],
                closedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"], args: ['closed',] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_12__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatDatepickerInput; })),
                multi: true
            };
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_VALIDATORS = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_12__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatDatepickerInput; })),
                multi: true
            };
            /**
             * An event used for datepicker input and change events. We don't always have access to a native
             * input or change event because the event may have been triggered by the user clicking on the
             * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.
             * @template D
             */
            var MatDatepickerInputEvent = /** @class */ (function () {
                /**
                 * @param {?} target
                 * @param {?} targetElement
                 */
                function MatDatepickerInputEvent(target, targetElement) {
                    this.target = target;
                    this.targetElement = targetElement;
                    this.value = this.target.value;
                }
                return MatDatepickerInputEvent;
            }());
            /**
             * Directive used to connect an input to a MatDatepicker.
             * @template D
             */
            var MatDatepickerInput = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} _formField
                 */
                function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
                    var _this = this;
                    this._elementRef = _elementRef;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this._formField = _formField;
                    /**
                     * Emits when a `change` event is fired on this `<input>`.
                     */
                    this.dateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when an `input` event is fired on this `<input>`.
                     */
                    this.dateInput = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the value changes (either due to user input or programmatic change).
                     */
                    this._valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the disabled state has changed
                     */
                    this._disabledChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    this._cvaOnChange = ( /**
                     * @return {?}
                     */function () { });
                    this._validatorOnChange = ( /**
                     * @return {?}
                     */function () { });
                    this._datepickerSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    this._localeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * The form control validator for whether the input parses.
                     */
                    this._parseValidator = ( /**
                     * @return {?}
                     */function () {
                        return _this._lastValueValid ?
                            null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };
                    });
                    /**
                     * The form control validator for the min date.
                     */
                    this._minValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                        return (!_this.min || !controlValue ||
                            _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?
                            null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };
                    });
                    /**
                     * The form control validator for the max date.
                     */
                    this._maxValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                        return (!_this.max || !controlValue ||
                            _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?
                            null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };
                    });
                    /**
                     * The form control validator for the date filter.
                     */
                    this._filterValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                        return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?
                            null : { 'matDatepickerFilter': true };
                    });
                    /**
                     * The combined form control validator for this input.
                     */
                    this._validator = _angular_forms__WEBPACK_IMPORTED_MODULE_12__["Validators"].compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);
                    /**
                     * Whether the last value set on the input was valid.
                     */
                    this._lastValueValid = false;
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    // Update the displayed date when the locale changes.
                    this._localeSubscription = _dateAdapter.localeChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this.value = _this.value;
                    }));
                }
                Object.defineProperty(MatDatepickerInput.prototype, "matDatepicker", {
                    /**
                     * The datepicker that this input is associated with.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        if (!value) {
                            return;
                        }
                        this._datepicker = value;
                        this._datepicker._registerInput(this);
                        this._datepickerSubscription.unsubscribe();
                        this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(( /**
                         * @param {?} selected
                         * @return {?}
                         */function (selected) {
                            _this.value = selected;
                            _this._cvaOnChange(selected);
                            _this._onTouched();
                            _this.dateInput.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                            _this.dateChange.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                        }));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "matDatepickerFilter", {
                    /**
                     * Function that can be used to filter out dates within the datepicker.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._dateFilter = value;
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "value", {
                    /**
                     * The value of the input.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = this._dateAdapter.deserialize(value);
                        this._lastValueValid = !value || this._dateAdapter.isValid(value);
                        value = this._getValidDateOrNull(value);
                        /** @type {?} */
                        var oldDate = this.value;
                        this._value = value;
                        this._formatValue(value);
                        if (!this._dateAdapter.sameDate(oldDate, value)) {
                            this._valueChange.emit(value);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "min", {
                    /**
                     * The minimum valid date.
                     * @return {?}
                     */
                    get: function () { return this._min; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "max", {
                    /**
                     * The maximum valid date.
                     * @return {?}
                     */
                    get: function () { return this._max; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "disabled", {
                    /**
                     * Whether the datepicker-input is disabled.
                     * @return {?}
                     */
                    get: function () { return !!this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                        /** @type {?} */
                        var element = this._elementRef.nativeElement;
                        if (this._disabled !== newValue) {
                            this._disabled = newValue;
                            this._disabledChange.emit(newValue);
                        }
                        // We need to null check the `blur` method, because it's undefined during SSR.
                        if (newValue && element.blur) {
                            // Normally, native input elements automatically blur if they turn disabled. This behavior
                            // is problematic, because it would mean that it triggers another change detection cycle,
                            // which then causes a changed after checked error if the input element was focused before.
                            element.blur();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDatepickerInput.prototype.ngOnDestroy = function () {
                    this._datepickerSubscription.unsubscribe();
                    this._localeSubscription.unsubscribe();
                    this._valueChange.complete();
                    this._disabledChange.complete();
                };
                /**
                 * \@docs-private
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnValidatorChange = function (fn) {
                    this._validatorOnChange = fn;
                };
                /**
                 * \@docs-private
                 * @param {?} c
                 * @return {?}
                 */
                MatDatepickerInput.prototype.validate = function (c) {
                    return this._validator ? this._validator(c) : null;
                };
                /**
                 * @deprecated
                 * \@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
                 * @return {?}
                 */
                MatDatepickerInput.prototype.getPopupConnectionElementRef = function () {
                    return this.getConnectedOverlayOrigin();
                };
                /**
                 * Gets the element that the datepicker popup should be connected to.
                 * @return {?} The element to connect the popup to.
                 */
                MatDatepickerInput.prototype.getConnectedOverlayOrigin = function () {
                    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype.writeValue = function (value) {
                    this.value = value;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnChange = function (fn) {
                    this._cvaOnChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatDatepickerInput.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onKeydown = function (event) {
                    /** @type {?} */
                    var isAltDownArrow = event.altKey && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"];
                    if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
                        this._datepicker.open();
                        event.preventDefault();
                    }
                };
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onInput = function (value) {
                    /** @type {?} */
                    var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
                    this._lastValueValid = !date || this._dateAdapter.isValid(date);
                    date = this._getValidDateOrNull(date);
                    if (!this._dateAdapter.sameDate(date, this._value)) {
                        this._value = date;
                        this._cvaOnChange(date);
                        this._valueChange.emit(date);
                        this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
                    }
                    else {
                        this._validatorOnChange();
                    }
                };
                /**
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onChange = function () {
                    this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
                };
                /**
                 * Returns the palette used by the input's form field, if any.
                 * @return {?}
                 */
                MatDatepickerInput.prototype._getThemePalette = function () {
                    return this._formField ? this._formField.color : undefined;
                };
                /**
                 * Handles blur events on the input.
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onBlur = function () {
                    // Reformat the input only if we have a valid value.
                    if (this.value) {
                        this._formatValue(this.value);
                    }
                    this._onTouched();
                };
                /**
                 * Formats a value and sets it on the input element.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype._formatValue = function (value) {
                    this._elementRef.nativeElement.value =
                        value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatDatepickerInput.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                return MatDatepickerInput;
            }());
            MatDatepickerInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'input[matDatepicker]',
                            providers: [
                                MAT_DATEPICKER_VALUE_ACCESSOR,
                                MAT_DATEPICKER_VALIDATORS,
                                { provide: _angular_material_input__WEBPACK_IMPORTED_MODULE_14__["MAT_INPUT_VALUE_ACCESSOR"], useExisting: MatDatepickerInput },
                            ],
                            host: {
                                '[attr.aria-haspopup]': '_datepicker ? "dialog" : null',
                                '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                                '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                                '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                                '[disabled]': 'disabled',
                                '(input)': '_onInput($event.target.value)',
                                '(change)': '_onChange()',
                                '(blur)': '_onBlur()',
                                '(keydown)': '_onKeydown($event)',
                            },
                            exportAs: 'matDatepickerInput',
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatDatepickerInput.propDecorators = {
                matDatepicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                matDatepickerFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                min: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                dateInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Can be used to override the icon of a `matDatepickerToggle`.
             */
            var MatDatepickerToggleIcon = /** @class */ (function () {
                function MatDatepickerToggleIcon() {
                }
                return MatDatepickerToggleIcon;
            }());
            MatDatepickerToggleIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matDatepickerToggleIcon]'
                        },] },
            ];
            /**
             * @template D
             */
            var MatDatepickerToggle = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} _changeDetectorRef
                 * @param {?} defaultTabIndex
                 */
                function MatDatepickerToggle(_intl, _changeDetectorRef, defaultTabIndex) {
                    this._intl = _intl;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._stateChanges = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /** @type {?} */
                    var parsedTabIndex = Number(defaultTabIndex);
                    this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
                }
                Object.defineProperty(MatDatepickerToggle.prototype, "disabled", {
                    /**
                     * Whether the toggle button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        if (this._disabled === undefined && this.datepicker) {
                            return this.datepicker.disabled;
                        }
                        return !!this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngOnChanges = function (changes) {
                    if (changes['datepicker']) {
                        this._watchStateChanges();
                    }
                };
                /**
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngOnDestroy = function () {
                    this._stateChanges.unsubscribe();
                };
                /**
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngAfterContentInit = function () {
                    this._watchStateChanges();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDatepickerToggle.prototype._open = function (event) {
                    if (this.datepicker && !this.disabled) {
                        this.datepicker.open();
                        event.stopPropagation();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatDatepickerToggle.prototype._watchStateChanges = function () {
                    var _this = this;
                    /** @type {?} */
                    var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    /** @type {?} */
                    var inputDisabled = this.datepicker && this.datepicker._datepickerInput ?
                        this.datepicker._datepickerInput._disabledChange : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    /** @type {?} */
                    var datepickerToggled = this.datepicker ?
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this.datepicker.openedStream, this.datepicker.closedStream) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    this._stateChanges.unsubscribe();
                    this._stateChanges = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(( /**
                     * @return {?}
                     */function () { return _this._changeDetectorRef.markForCheck(); }));
                };
                return MatDatepickerToggle;
            }());
            MatDatepickerToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker-toggle',
                            template: "<button #button mat-icon-button type=\"button\" [attr.aria-haspopup]=\"datepicker ? 'dialog' : null\" [attr.aria-label]=\"_intl.openCalendarLabel\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [disabled]=\"disabled\" [disableRipple]=\"disableRipple\" (click)=\"_open($event)\"><svg *ngIf=\"!_customIcon\" class=\"mat-datepicker-toggle-default-icon\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" fill=\"currentColor\" focusable=\"false\"><path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/></svg><ng-content select=\"[matDatepickerToggleIcon]\"></ng-content></button>",
                            styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}"],
                            host: {
                                'class': 'mat-datepicker-toggle',
                                // Always set the tabindex to -1 so that it doesn't overlap with any custom tabindex the
                                // consumer may have provided, while still being able to receive focus.
                                '[attr.tabindex]': '-1',
                                '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',
                                '[class.mat-accent]': 'datepicker && datepicker.color === "accent"',
                                '[class.mat-warn]': 'datepicker && datepicker.color === "warn"',
                                '(focus)': '_button.focus()',
                            },
                            exportAs: 'matDatepickerToggle',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerToggle.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] }
            ]; };
            MatDatepickerToggle.propDecorators = {
                datepicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['for',] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _customIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatDatepickerToggleIcon, { static: false },] }],
                _button: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['button', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDatepickerModule = /** @class */ (function () {
                function MatDatepickerModule() {
                }
                return MatDatepickerModule;
            }());
            MatDatepickerModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_15__["MatButtonModule"],
                                _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__["MatDialogModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayModule"],
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_16__["A11yModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["PortalModule"],
                            ],
                            exports: [
                                MatCalendar,
                                MatCalendarBody,
                                MatDatepicker,
                                MatDatepickerContent,
                                MatDatepickerInput,
                                MatDatepickerToggle,
                                MatDatepickerToggleIcon,
                                MatMonthView,
                                MatYearView,
                                MatMultiYearView,
                                MatCalendarHeader,
                            ],
                            declarations: [
                                MatCalendar,
                                MatCalendarBody,
                                MatDatepicker,
                                MatDatepickerContent,
                                MatDatepickerInput,
                                MatDatepickerToggle,
                                MatDatepickerToggleIcon,
                                MatMonthView,
                                MatYearView,
                                MatMultiYearView,
                                MatCalendarHeader,
                            ],
                            providers: [
                                MatDatepickerIntl,
                                MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,
                            ],
                            entryComponents: [
                                MatDatepickerContent,
                                MatCalendarHeader,
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=datepicker.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/expansion.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/expansion.js ***!
          \*************************************************************/
        /*! exports provided: MatExpansionModule, MatAccordion, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelDescription, MatExpansionPanelTitle, MatExpansionPanelContent, EXPANSION_PANEL_ANIMATION_TIMING, matExpansionAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionModule", function () { return MatExpansionModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAccordion", function () { return MatAccordion; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_ACCORDION", function () { return MAT_ACCORDION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_EXPANSION_PANEL_DEFAULT_OPTIONS", function () { return MAT_EXPANSION_PANEL_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanel", function () { return MatExpansionPanel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelActionRow", function () { return MatExpansionPanelActionRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelHeader", function () { return MatExpansionPanelHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelDescription", function () { return MatExpansionPanelDescription; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelTitle", function () { return MatExpansionPanelTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelContent", function () { return MatExpansionPanelContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXPANSION_PANEL_ANIMATION_TIMING", function () { return EXPANSION_PANEL_ANIMATION_TIMING; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matExpansionAnimations", function () { return matExpansionAnimations; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/accordion */ "./node_modules/@angular/cdk/esm2015/accordion.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Token used to provide a `MatAccordion` to `MatExpansionPanel`.
             * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.
             * @type {?}
             */
            var MAT_ACCORDION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_ACCORDION');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Time and timing curve for expansion panel animations.
             * @type {?}
             */
            var EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
            /**
             * Animations used by the Material expansion panel.
             *
             * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()
             * causes the animation state of moved components to become `void` upon exit, and not update again
             * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state
             * of the panel is `expanded` or `collapsed` but the animation state is `void`.
             *
             * To correctly handle animating to the next state, we animate between `void` and `collapsed` which
             * are defined to have the same styles. Since angular animates from the current styles to the
             * destination state's style definition, in situations where we are moving from `void`'s styles to
             * `collapsed` this acts a noop since no style values change.
             *
             * In the case where angular's animation state is out of sync with the expansion panel's state, the
             * expansion panel being `expanded` and angular animations being `void`, the animation from the
             * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will
             * occur as expected.
             *
             * Angular Bug: https://github.com/angular/angular/issues/18847
             *
             * \@docs-private
             * @type {?}
             */
            var matExpansionAnimations = {
                /**
                 * Animation that rotates the indicator arrow.
                 */
                indicatorRotate: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('indicatorRotate', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'rotate(0deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'rotate(180deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING)),
                ]),
                /**
                 * Animation that expands and collapses the panel header height.
                 */
                expansionHeaderHeight: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('expansionHeight', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({
                        height: '{{collapsedHeight}}',
                    }), {
                        params: { collapsedHeight: '48px' },
                    }),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({
                        height: '{{expandedHeight}}'
                    }), {
                        params: { expandedHeight: '64px' }
                    }),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["group"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["query"])('@indicatorRotate', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animateChild"])(), { optional: true }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING),
                    ])),
                ]),
                /**
                 * Animation that expands and collapses the panel content.
                 */
                bodyExpansion: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('bodyExpansion', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ height: '*', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING)),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Expansion panel content that will be rendered lazily
             * after the panel is opened for the first time.
             */
            var MatExpansionPanelContent = /** @class */ (function () {
                /**
                 * @param {?} _template
                 */
                function MatExpansionPanelContent(_template) {
                    this._template = _template;
                }
                return MatExpansionPanelContent;
            }());
            MatExpansionPanelContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'ng-template[matExpansionPanelContent]'
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanelContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Counter for generating unique element ids.
             * @type {?}
             */
            var uniqueId = 0;
            /**
             * Injection token that can be used to configure the defalt
             * options for the expansion panel component.
             * @type {?}
             */
            var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');
            var ɵ0 = undefined;
            /**
             * `<mat-expansion-panel>`
             *
             * This component can be used as a single element to show expandable content, or as one of
             * multiple children of an element with the MatAccordion directive attached.
             */
            var MatExpansionPanel = /** @class */ (function (_super) {
                __extends(MatExpansionPanel, _super);
                /**
                 * @param {?} accordion
                 * @param {?} _changeDetectorRef
                 * @param {?} _uniqueSelectionDispatcher
                 * @param {?} _viewContainerRef
                 * @param {?} _document
                 * @param {?} _animationMode
                 * @param {?=} defaultOptions
                 */
                function MatExpansionPanel(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {
                    var _this = _super.call(this, accordion, _changeDetectorRef, _uniqueSelectionDispatcher) || this;
                    _this._viewContainerRef = _viewContainerRef;
                    _this._animationMode = _animationMode;
                    _this._hideToggle = false;
                    /**
                     * An event emitted after the body's expansion animation happens.
                     */
                    _this.afterExpand = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event emitted after the body's collapse animation happens.
                     */
                    _this.afterCollapse = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Stream that emits for changes in `\@Input` properties.
                     */
                    _this._inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_8__["Subject"]();
                    /**
                     * ID for the associated header element. Used for a11y labelling.
                     */
                    _this._headerId = "mat-expansion-panel-header-" + uniqueId++;
                    /**
                     * Stream of body animation done events.
                     */
                    _this._bodyAnimationDone = new rxjs__WEBPACK_IMPORTED_MODULE_8__["Subject"]();
                    _this.accordion = accordion;
                    _this._document = _document;
                    // We need a Subject with distinctUntilChanged, because the `done` event
                    // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
                    _this._bodyAnimationDone.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) {
                        return x.fromState === y.fromState && x.toState === y.toState;
                    }))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (event.fromState !== 'void') {
                            if (event.toState === 'expanded') {
                                _this.afterExpand.emit();
                            }
                            else if (event.toState === 'collapsed') {
                                _this.afterCollapse.emit();
                            }
                        }
                    }));
                    if (defaultOptions) {
                        _this.hideToggle = defaultOptions.hideToggle;
                    }
                    return _this;
                }
                Object.defineProperty(MatExpansionPanel.prototype, "hideToggle", {
                    /**
                     * Whether the toggle indicator should be hidden.
                     * @return {?}
                     */
                    get: function () {
                        return this._hideToggle || (this.accordion && this.accordion.hideToggle);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._hideToggle = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatExpansionPanel.prototype, "togglePosition", {
                    /**
                     * The position of the expansion indicator.
                     * @return {?}
                     */
                    get: function () {
                        return this._togglePosition || (this.accordion && this.accordion.togglePosition);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._togglePosition = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Determines whether the expansion panel should have spacing between it and its siblings.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._hasSpacing = function () {
                    if (this.accordion) {
                        // We don't need to subscribe to the `stateChanges` of the parent accordion because each time
                        // the [displayMode] input changes, the change detection will also cover the host bindings
                        // of this expansion panel.
                        return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';
                    }
                    return false;
                };
                /**
                 * Gets the expanded state string.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._getExpandedState = function () {
                    return this.expanded ? 'expanded' : 'collapsed';
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    if (this._lazyContent) {
                        // Render the content as soon as the panel becomes open.
                        this.opened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(( /** @type {?} */(null))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @return {?}
                         */function () { return _this.expanded && !_this._portal; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["TemplatePortal"](_this._lazyContent._template, _this._viewContainerRef);
                        }));
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngOnChanges = function (changes) {
                    this._inputChanges.next(changes);
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._bodyAnimationDone.complete();
                    this._inputChanges.complete();
                };
                /**
                 * Checks whether the expansion panel's content contains the currently-focused element.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._containsFocus = function () {
                    if (this._body) {
                        /** @type {?} */
                        var focusedElement = this._document.activeElement;
                        /** @type {?} */
                        var bodyElement = this._body.nativeElement;
                        return focusedElement === bodyElement || bodyElement.contains(focusedElement);
                    }
                    return false;
                };
                return MatExpansionPanel;
            }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordionItem"]));
            MatExpansionPanel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}"],
                            selector: 'mat-expansion-panel',
                            exportAs: 'matExpansionPanel',
                            template: "<ng-content select=\"mat-expansion-panel-header\"></ng-content><div class=\"mat-expansion-panel-content\" role=\"region\" [@bodyExpansion]=\"_getExpandedState()\" (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\" [attr.aria-labelledby]=\"_headerId\" [id]=\"id\" #body><div class=\"mat-expansion-panel-body\"><ng-content></ng-content><ng-template [cdkPortalOutlet]=\"_portal\"></ng-template></div><ng-content select=\"mat-action-row\"></ng-content></div>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disabled', 'expanded'],
                            outputs: ['opened', 'closed', 'expandedChange'],
                            animations: [matExpansionAnimations.bodyExpansion],
                            providers: [
                                // Provide MatAccordion as undefined to prevent nested expansion panels from registering
                                // to the same accordion.
                                { provide: MAT_ACCORDION, useValue: ɵ0 },
                            ],
                            host: {
                                'class': 'mat-expansion-panel',
                                '[class.mat-expanded]': 'expanded',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '[class.mat-expansion-panel-spacing]': '_hasSpacing()',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanel.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_ACCORDION,] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__["UniqueSelectionDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatExpansionPanel.propDecorators = {
                hideToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                togglePosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                afterExpand: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                afterCollapse: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _lazyContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatExpansionPanelContent, { static: false },] }],
                _body: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['body', { static: false },] }]
            };
            var MatExpansionPanelActionRow = /** @class */ (function () {
                function MatExpansionPanelActionRow() {
                }
                return MatExpansionPanelActionRow;
            }());
            MatExpansionPanelActionRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-action-row',
                            host: {
                                class: 'mat-action-row'
                            }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * `<mat-expansion-panel-header>`
             *
             * This component corresponds to the header element of an `<mat-expansion-panel>`.
             */
            var MatExpansionPanelHeader = /** @class */ (function () {
                /**
                 * @param {?} panel
                 * @param {?} _element
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?=} defaultOptions
                 */
                function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {
                    var _this = this;
                    this.panel = panel;
                    this._element = _element;
                    this._focusMonitor = _focusMonitor;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._parentChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__["Subscription"].EMPTY;
                    /**
                     * Whether Angular animations in the panel header should be disabled.
                     */
                    this._animationsDisabled = true;
                    /** @type {?} */
                    var accordionHideToggleChange = panel.accordion ?
                        panel.accordion._stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} changes
                         * @return {?}
                         */function (/**
                         * @param {?} changes
                         * @return {?}
                         */ changes) { return !!(changes['hideToggle'] || changes['togglePosition']); }))) :
                        rxjs__WEBPACK_IMPORTED_MODULE_8__["EMPTY"];
                    // Since the toggle state depends on an @Input on the panel, we
                    // need to subscribe and trigger change detection manually.
                    this._parentChangeSubscription =
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_8__["merge"])(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} changes
                         * @return {?}
                         */function (/**
                         * @param {?} changes
                         * @return {?}
                         */ changes) {
                            return !!(changes['hideToggle'] ||
                                changes['disabled'] ||
                                changes['togglePosition']);
                        }))))
                            .subscribe(( /**
                     * @return {?}
                     */function () { return _this._changeDetectorRef.markForCheck(); }));
                    // Avoids focus being lost if the panel contained the focused element and was closed.
                    panel.closed
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                 * @return {?}
                 */function () { return panel._containsFocus(); })))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _focusMonitor.focusVia(_element, 'program'); }));
                    _focusMonitor.monitor(_element).subscribe(( /**
                     * @param {?} origin
                     * @return {?}
                     */function (/**
                     * @param {?} origin
                     * @return {?}
                     */ origin) {
                        if (origin && panel.accordion) {
                            panel.accordion._handleHeaderFocus(_this);
                        }
                    }));
                    if (defaultOptions) {
                        this.expandedHeight = defaultOptions.expandedHeight;
                        this.collapsedHeight = defaultOptions.collapsedHeight;
                    }
                }
                /**
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._animationStarted = function () {
                    // Currently the `expansionHeight` animation has a `void => collapsed` transition which is
                    // there to work around a bug in Angular (see #13088), however this introduces a different
                    // issue. The new transition will cause the header to animate in on init (see #16067), if the
                    // consumer has set a header height that is different from the default one. We work around it
                    // by disabling animations on the header and re-enabling them after the first animation has run.
                    // Note that Angular dispatches animation events even if animations are disabled. Ideally this
                    // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait
                    // for https://github.com/angular/angular/issues/18847 to be resolved.
                    this._animationsDisabled = false;
                };
                Object.defineProperty(MatExpansionPanelHeader.prototype, "disabled", {
                    /**
                     * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.panel.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Toggles the expanded state of the panel.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._toggle = function () {
                    this.panel.toggle();
                };
                /**
                 * Gets whether the panel is expanded.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._isExpanded = function () {
                    return this.panel.expanded;
                };
                /**
                 * Gets the expanded state string of the panel.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getExpandedState = function () {
                    return this.panel._getExpandedState();
                };
                /**
                 * Gets the panel id.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getPanelId = function () {
                    return this.panel.id;
                };
                /**
                 * Gets the toggle position for the header.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getTogglePosition = function () {
                    return this.panel.togglePosition;
                };
                /**
                 * Gets whether the expand indicator should be shown.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._showToggle = function () {
                    return !this.panel.hideToggle && !this.panel.disabled;
                };
                /**
                 * Handle keydown event calling to toggle() if appropriate.
                 * @param {?} event
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._keydown = function (event) {
                    switch (event.keyCode) {
                        // Toggle for space and enter keys.
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["SPACE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["ENTER"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                                event.preventDefault();
                                this._toggle();
                            }
                            break;
                        default:
                            if (this.panel.accordion) {
                                this.panel.accordion._handleHeaderKeydown(event);
                            }
                            return;
                    }
                };
                /**
                 * Focuses the panel header. Implemented as a part of `FocusableOption`.
                 * \@docs-private
                 * @param {?=} origin Origin of the action that triggered the focus.
                 * @param {?=} options
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    this._focusMonitor.focusVia(this._element, origin, options);
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype.ngOnDestroy = function () {
                    this._parentChangeSubscription.unsubscribe();
                    this._focusMonitor.stopMonitoring(this._element);
                };
                return MatExpansionPanelHeader;
            }());
            MatExpansionPanelHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-expansion-panel-header',
                            styles: [".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}"],
                            template: "<span class=\"mat-content\"><ng-content select=\"mat-panel-title\"></ng-content><ng-content select=\"mat-panel-description\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\" class=\"mat-expansion-indicator\"></span>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            animations: [
                                matExpansionAnimations.indicatorRotate,
                                matExpansionAnimations.expansionHeaderHeight
                            ],
                            host: {
                                'class': 'mat-expansion-panel-header',
                                'role': 'button',
                                '[attr.id]': 'panel._headerId',
                                '[attr.tabindex]': 'disabled ? -1 : 0',
                                '[attr.aria-controls]': '_getPanelId()',
                                '[attr.aria-expanded]': '_isExpanded()',
                                '[attr.aria-disabled]': 'panel.disabled',
                                '[class.mat-expanded]': '_isExpanded()',
                                '[class.mat-expansion-toggle-indicator-after]': "_getTogglePosition() === 'after'",
                                '[class.mat-expansion-toggle-indicator-before]': "_getTogglePosition() === 'before'",
                                '(click)': '_toggle()',
                                '(keydown)': '_keydown($event)',
                                '[@.disabled]': '_animationsDisabled',
                                '(@expansionHeight.start)': '_animationStarted()',
                                '[@expansionHeight]': "{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanelHeader.ctorParameters = function () { return [
                { type: MatExpansionPanel, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatExpansionPanelHeader.propDecorators = {
                expandedHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                collapsedHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * `<mat-panel-description>`
             *
             * This directive is to be used inside of the MatExpansionPanelHeader component.
             */
            var MatExpansionPanelDescription = /** @class */ (function () {
                function MatExpansionPanelDescription() {
                }
                return MatExpansionPanelDescription;
            }());
            MatExpansionPanelDescription.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-panel-description',
                            host: {
                                class: 'mat-expansion-panel-header-description'
                            }
                        },] },
            ];
            /**
             * `<mat-panel-title>`
             *
             * This directive is to be used inside of the MatExpansionPanelHeader component.
             */
            var MatExpansionPanelTitle = /** @class */ (function () {
                function MatExpansionPanelTitle() {
                }
                return MatExpansionPanelTitle;
            }());
            MatExpansionPanelTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-panel-title',
                            host: {
                                class: 'mat-expansion-panel-header-title'
                            }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive for a Material Design Accordion.
             */
            var MatAccordion = /** @class */ (function (_super) {
                __extends(MatAccordion, _super);
                function MatAccordion() {
                    var _this = _super.apply(this, arguments) || this;
                    _this._hideToggle = false;
                    /**
                     * Display mode used for all expansion panels in the accordion. Currently two display
                     * modes exist:
                     *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded
                     *     panel at a different elevation from the rest of the accordion.
                     *  flat - no spacing is placed around expanded panels, showing all panels at the same
                     *     elevation.
                     */
                    _this.displayMode = 'default';
                    /**
                     * The position of the expansion indicator.
                     */
                    _this.togglePosition = 'after';
                    return _this;
                }
                Object.defineProperty(MatAccordion.prototype, "hideToggle", {
                    /**
                     * Whether the expansion indicator should be hidden.
                     * @return {?}
                     */
                    get: function () { return this._hideToggle; },
                    /**
                     * @param {?} show
                     * @return {?}
                     */
                    set: function (show) { this._hideToggle = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(show); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAccordion.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusKeyManager"](this._headers).withWrap();
                };
                /**
                 * Handles keyboard events coming in from the panel headers.
                 * @param {?} event
                 * @return {?}
                 */
                MatAccordion.prototype._handleHeaderKeydown = function (event) {
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["HOME"]) {
                        if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                            manager.setFirstItemActive();
                            event.preventDefault();
                        }
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["END"]) {
                        if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                            manager.setLastItemActive();
                            event.preventDefault();
                        }
                    }
                    else {
                        this._keyManager.onKeydown(event);
                    }
                };
                /**
                 * @param {?} header
                 * @return {?}
                 */
                MatAccordion.prototype._handleHeaderFocus = function (header) {
                    this._keyManager.updateActiveItem(header);
                };
                return MatAccordion;
            }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordion"]));
            MatAccordion.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-accordion',
                            exportAs: 'matAccordion',
                            inputs: ['multi'],
                            providers: [{
                                    provide: MAT_ACCORDION,
                                    useExisting: MatAccordion
                                }],
                            host: {
                                class: 'mat-accordion'
                            }
                        },] },
            ];
            MatAccordion.propDecorators = {
                _headers: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatExpansionPanelHeader, { descendants: true },] }],
                hideToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                displayMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                togglePosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatExpansionModule = /** @class */ (function () {
                function MatExpansionModule() {
                }
                return MatExpansionModule;
            }());
            MatExpansionModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordionModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"]],
                            exports: [
                                MatAccordion,
                                MatExpansionPanel,
                                MatExpansionPanelActionRow,
                                MatExpansionPanelHeader,
                                MatExpansionPanelTitle,
                                MatExpansionPanelDescription,
                                MatExpansionPanelContent,
                            ],
                            declarations: [
                                MatAccordion,
                                MatExpansionPanel,
                                MatExpansionPanelActionRow,
                                MatExpansionPanelHeader,
                                MatExpansionPanelTitle,
                                MatExpansionPanelDescription,
                                MatExpansionPanelContent,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=expansion.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/grid-list.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/grid-list.js ***!
          \*************************************************************/
        /*! exports provided: MatGridListModule, MatGridList, MatGridTile, MatGridTileText, MatGridAvatarCssMatStyler, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, ɵa11 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridListModule", function () { return MatGridListModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridList", function () { return MatGridList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTile", function () { return MatGridTile; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTileText", function () { return MatGridTileText; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridAvatarCssMatStyler", function () { return MatGridAvatarCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTileHeaderCssMatStyler", function () { return MatGridTileHeaderCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTileFooterCssMatStyler", function () { return MatGridTileFooterCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa11", function () { return MAT_GRID_LIST; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token used to provide a grid list to a tile and to avoid circular imports.
             * \@docs-private
             * @type {?}
             */
            var MAT_GRID_LIST = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_GRID_LIST');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatGridTile = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?=} _gridList
                 */
                function MatGridTile(_element, _gridList) {
                    this._element = _element;
                    this._gridList = _gridList;
                    this._rowspan = 1;
                    this._colspan = 1;
                }
                Object.defineProperty(MatGridTile.prototype, "rowspan", {
                    /**
                     * Amount of rows that the grid tile takes up.
                     * @return {?}
                     */
                    get: function () { return this._rowspan; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._rowspan = Math.round(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value)); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatGridTile.prototype, "colspan", {
                    /**
                     * Amount of columns that the grid tile takes up.
                     * @return {?}
                     */
                    get: function () { return this._colspan; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._colspan = Math.round(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value)); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the style of the grid-tile element.  Needs to be set manually to avoid
                 * "Changed after checked" errors that would occur with HostBinding.
                 * @param {?} property
                 * @param {?} value
                 * @return {?}
                 */
                MatGridTile.prototype._setStyle = function (property, value) {
                    (( /** @type {?} */(this._element.nativeElement.style)))[property] = value;
                };
                return MatGridTile;
            }());
            MatGridTile.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-grid-tile',
                            exportAs: 'matGridTile',
                            host: {
                                'class': 'mat-grid-tile',
                            },
                            template: "<figure class=\"mat-figure\"><ng-content></ng-content></figure>",
                            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatGridTile.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_GRID_LIST,] }] }
            ]; };
            MatGridTile.propDecorators = {
                rowspan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                colspan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatGridTileText = /** @class */ (function () {
                /**
                 * @param {?} _element
                 */
                function MatGridTileText(_element) {
                    this._element = _element;
                }
                /**
                 * @return {?}
                 */
                MatGridTileText.prototype.ngAfterContentInit = function () {
                    Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["setLines"])(this._lines, this._element);
                };
                return MatGridTileText;
            }());
            MatGridTileText.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-grid-tile-header, mat-grid-tile-footer',
                            template: "<ng-content select=\"[mat-grid-avatar], [matGridAvatar]\"></ng-content><div class=\"mat-grid-list-text\"><ng-content select=\"[mat-line], [matLine]\"></ng-content></div><ng-content></ng-content>",
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatGridTileText.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            MatGridTileText.propDecorators = {
                _lines: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLine"],] }]
            };
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatGridAvatarCssMatStyler = /** @class */ (function () {
                function MatGridAvatarCssMatStyler() {
                }
                return MatGridAvatarCssMatStyler;
            }());
            MatGridAvatarCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-grid-avatar], [matGridAvatar]',
                            host: { 'class': 'mat-grid-avatar' }
                        },] },
            ];
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatGridTileHeaderCssMatStyler = /** @class */ (function () {
                function MatGridTileHeaderCssMatStyler() {
                }
                return MatGridTileHeaderCssMatStyler;
            }());
            MatGridTileHeaderCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-grid-tile-header',
                            host: { 'class': 'mat-grid-tile-header' }
                        },] },
            ];
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatGridTileFooterCssMatStyler = /** @class */ (function () {
                function MatGridTileFooterCssMatStyler() {
                }
                return MatGridTileFooterCssMatStyler;
            }());
            MatGridTileFooterCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-grid-tile-footer',
                            host: { 'class': 'mat-grid-tile-footer' }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
             * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
             * because the tiles can have a rowspan.
             *
             * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
             * large enough to accommodate it so that the tiles still render in the same order in which they
             * are given.
             *
             * The basis of the algorithm is the use of an array to track the already placed tiles. Each
             * element of the array corresponds to a column, and the value indicates how many cells in that
             * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
             * decrements each value in the tracking array (indicating that the column is one cell closer to
             * being free).
             *
             * \@docs-private
             */
            var TileCoordinator = /** @class */ (function () {
                function TileCoordinator() {
                    /**
                     * Index at which the search for the next gap will start.
                     */
                    this.columnIndex = 0;
                    /**
                     * The current row index.
                     */
                    this.rowIndex = 0;
                }
                Object.defineProperty(TileCoordinator.prototype, "rowCount", {
                    /**
                     * Gets the total number of rows occupied by tiles
                     * @return {?}
                     */
                    get: function () { return this.rowIndex + 1; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TileCoordinator.prototype, "rowspan", {
                    /**
                     * Gets the total span of rows occupied by tiles.
                     * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var lastRowMax = Math.max.apply(Math, this.tracker);
                        // if any of the tiles has a rowspan that pushes it beyond the total row count,
                        // add the difference to the rowcount
                        return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Updates the tile positions.
                 * @param {?} numColumns Amount of columns in the grid.
                 * @param {?} tiles
                 * @return {?}
                 */
                TileCoordinator.prototype.update = function (numColumns, tiles) {
                    var _this = this;
                    this.columnIndex = 0;
                    this.rowIndex = 0;
                    this.tracker = new Array(numColumns);
                    this.tracker.fill(0, 0, this.tracker.length);
                    this.positions = tiles.map(( /**
                     * @param {?} tile
                     * @return {?}
                     */function (/**
                     * @param {?} tile
                     * @return {?}
                     */ tile) { return _this._trackTile(tile); }));
                };
                /**
                 * Calculates the row and col position of a tile.
                 * @private
                 * @param {?} tile
                 * @return {?}
                 */
                TileCoordinator.prototype._trackTile = function (tile) {
                    // Find a gap large enough for this tile.
                    /** @type {?} */
                    var gapStartIndex = this._findMatchingGap(tile.colspan);
                    // Place tile in the resulting gap.
                    this._markTilePosition(gapStartIndex, tile);
                    // The next time we look for a gap, the search will start at columnIndex, which should be
                    // immediately after the tile that has just been placed.
                    this.columnIndex = gapStartIndex + tile.colspan;
                    return new TilePosition(this.rowIndex, gapStartIndex);
                };
                /**
                 * Finds the next available space large enough to fit the tile.
                 * @private
                 * @param {?} tileCols
                 * @return {?}
                 */
                TileCoordinator.prototype._findMatchingGap = function (tileCols) {
                    if (tileCols > this.tracker.length) {
                        throw Error("mat-grid-list: tile with colspan " + tileCols + " is wider than " +
                            ("grid with cols=\"" + this.tracker.length + "\"."));
                    }
                    // Start index is inclusive, end index is exclusive.
                    /** @type {?} */
                    var gapStartIndex = -1;
                    /** @type {?} */
                    var gapEndIndex = -1;
                    // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.
                    do {
                        // If we've reached the end of the row, go to the next row.
                        if (this.columnIndex + tileCols > this.tracker.length) {
                            this._nextRow();
                            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                            gapEndIndex = this._findGapEndIndex(gapStartIndex);
                            continue;
                        }
                        gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                        // If there are no more empty spaces in this row at all, move on to the next row.
                        if (gapStartIndex == -1) {
                            this._nextRow();
                            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                            gapEndIndex = this._findGapEndIndex(gapStartIndex);
                            continue;
                        }
                        gapEndIndex = this._findGapEndIndex(gapStartIndex);
                        // If a gap large enough isn't found, we want to start looking immediately after the current
                        // gap on the next iteration.
                        this.columnIndex = gapStartIndex + 1;
                        // Continue iterating until we find a gap wide enough for this tile. Since gapEndIndex is
                        // exclusive, gapEndIndex is 0 means we didn't find a gap and should continue.
                    } while ((gapEndIndex - gapStartIndex < tileCols) || (gapEndIndex == 0));
                    // If we still didn't manage to find a gap, ensure that the index is
                    // at least zero so the tile doesn't get pulled out of the grid.
                    return Math.max(gapStartIndex, 0);
                };
                /**
                 * Move "down" to the next row.
                 * @private
                 * @return {?}
                 */
                TileCoordinator.prototype._nextRow = function () {
                    this.columnIndex = 0;
                    this.rowIndex++;
                    // Decrement all spaces by one to reflect moving down one row.
                    for (var i = 0; i < this.tracker.length; i++) {
                        this.tracker[i] = Math.max(0, this.tracker[i] - 1);
                    }
                };
                /**
                 * Finds the end index (exclusive) of a gap given the index from which to start looking.
                 * The gap ends when a non-zero value is found.
                 * @private
                 * @param {?} gapStartIndex
                 * @return {?}
                 */
                TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {
                    for (var i = gapStartIndex + 1; i < this.tracker.length; i++) {
                        if (this.tracker[i] != 0) {
                            return i;
                        }
                    }
                    // The gap ends with the end of the row.
                    return this.tracker.length;
                };
                /**
                 * Update the tile tracker to account for the given tile in the given space.
                 * @private
                 * @param {?} start
                 * @param {?} tile
                 * @return {?}
                 */
                TileCoordinator.prototype._markTilePosition = function (start, tile) {
                    for (var i = 0; i < tile.colspan; i++) {
                        this.tracker[start + i] = tile.rowspan;
                    }
                };
                return TileCoordinator;
            }());
            /**
             * Simple data structure for tile position (row, col).
             * \@docs-private
             */
            var TilePosition = /** @class */ (function () {
                /**
                 * @param {?} row
                 * @param {?} col
                 */
                function TilePosition(row, col) {
                    this.row = row;
                    this.col = col;
                }
                return TilePosition;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * RegExp that can be used to check whether a value will
             * be allowed inside a CSS `calc()` expression.
             * @type {?}
             */
            var cssCalcAllowedValue = /^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;
            /**
             * Sets the style properties for an individual tile, given the position calculated by the
             * Tile Coordinator.
             * \@docs-private
             * @abstract
             */
            var TileStyler = /** @class */ (function () {
                function TileStyler() {
                    this._rows = 0;
                    this._rowspan = 0;
                }
                /**
                 * Adds grid-list layout info once it is available. Cannot be processed in the constructor
                 * because these properties haven't been calculated by that point.
                 *
                 * @param {?} gutterSize Size of the grid's gutter.
                 * @param {?} tracker Instance of the TileCoordinator.
                 * @param {?} cols Amount of columns in the grid.
                 * @param {?} direction Layout direction of the grid.
                 * @return {?}
                 */
                TileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
                    this._gutterSize = normalizeUnits(gutterSize);
                    this._rows = tracker.rowCount;
                    this._rowspan = tracker.rowspan;
                    this._cols = cols;
                    this._direction = direction;
                };
                /**
                 * Computes the amount of space a single 1x1 tile would take up (width or height).
                 * Used as a basis for other calculations.
                 * @param {?} sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
                 * @param {?} gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
                 * @return {?} The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
                 */
                TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {
                    // Take the base size percent (as would be if evenly dividing the size between cells),
                    // and then subtracting the size of one gutter. However, since there are no gutters on the
                    // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter
                    // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the
                    // edge evenly among the cells).
                    return "(" + sizePercent + "% - (" + this._gutterSize + " * " + gutterFraction + "))";
                };
                /**
                 * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
                 * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
                 * @param {?} offset Number of tiles that have already been rendered in the row/column.
                 * @return {?} Position of the tile as a CSS calc() expression.
                 */
                TileStyler.prototype.getTilePosition = function (baseSize, offset) {
                    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
                    // row/column (offset).
                    return offset === 0 ? '0' : calc("(" + baseSize + " + " + this._gutterSize + ") * " + offset);
                };
                /**
                 * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
                 * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
                 * @param {?} span The tile's rowspan or colspan.
                 * @return {?} Size of the tile as a CSS calc() expression.
                 */
                TileStyler.prototype.getTileSize = function (baseSize, span) {
                    return "(" + baseSize + " * " + span + ") + (" + (span - 1) + " * " + this._gutterSize + ")";
                };
                /**
                 * Sets the style properties to be applied to a tile for the given row and column index.
                 * @param {?} tile Tile to which to apply the styling.
                 * @param {?} rowIndex Index of the tile's row.
                 * @param {?} colIndex Index of the tile's column.
                 * @return {?}
                 */
                TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {
                    // Percent of the available horizontal space that one column takes up.
                    /** @type {?} */
                    var percentWidthPerTile = 100 / this._cols;
                    // Fraction of the vertical gutter size that each column takes up.
                    // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.
                    /** @type {?} */
                    var gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
                    this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
                    this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
                };
                /**
                 * Sets the horizontal placement of the tile in the list.
                 * @param {?} tile
                 * @param {?} colIndex
                 * @param {?} percentWidth
                 * @param {?} gutterWidth
                 * @return {?}
                 */
                TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {
                    // Base horizontal size of a column.
                    /** @type {?} */
                    var baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
                    // The width and horizontal position of each tile is always calculated the same way, but the
                    // height and vertical position depends on the rowMode.
                    /** @type {?} */
                    var side = this._direction === 'rtl' ? 'right' : 'left';
                    tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
                    tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));
                };
                /**
                 * Calculates the total size taken up by gutters across one axis of a list.
                 * @return {?}
                 */
                TileStyler.prototype.getGutterSpan = function () {
                    return this._gutterSize + " * (" + this._rowspan + " - 1)";
                };
                /**
                 * Calculates the total size taken up by tiles across one axis of a list.
                 * @param {?} tileHeight Height of the tile.
                 * @return {?}
                 */
                TileStyler.prototype.getTileSpan = function (tileHeight) {
                    return this._rowspan + " * " + this.getTileSize(tileHeight, 1);
                };
                /**
                 * Calculates the computed height and returns the correct style property to set.
                 * This method can be implemented by each type of TileStyler.
                 * \@docs-private
                 * @return {?}
                 */
                TileStyler.prototype.getComputedHeight = function () { return null; };
                return TileStyler;
            }());
            /**
             * This type of styler is instantiated when the user passes in a fixed row height.
             * Example `<mat-grid-list cols="3" rowHeight="100px">`
             * \@docs-private
             */
            var FixedTileStyler = /** @class */ (function (_super) {
                __extends(FixedTileStyler, _super);
                /**
                 * @param {?} fixedRowHeight
                 */
                function FixedTileStyler(fixedRowHeight) {
                    var _this = _super.call(this) || this;
                    _this.fixedRowHeight = fixedRowHeight;
                    return _this;
                }
                /**
                 * @param {?} gutterSize
                 * @param {?} tracker
                 * @param {?} cols
                 * @param {?} direction
                 * @return {?}
                 */
                FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
                    _super.prototype.init.call(this, gutterSize, tracker, cols, direction);
                    this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
                    if (!cssCalcAllowedValue.test(this.fixedRowHeight)) {
                        throw Error("Invalid value \"" + this.fixedRowHeight + "\" set as rowHeight.");
                    }
                };
                /**
                 * @param {?} tile
                 * @param {?} rowIndex
                 * @return {?}
                 */
                FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex) {
                    tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));
                    tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
                };
                /**
                 * @return {?}
                 */
                FixedTileStyler.prototype.getComputedHeight = function () {
                    return [
                        'height', calc(this.getTileSpan(this.fixedRowHeight) + " + " + this.getGutterSpan())
                    ];
                };
                /**
                 * @param {?} list
                 * @return {?}
                 */
                FixedTileStyler.prototype.reset = function (list) {
                    list._setListStyle(['height', null]);
                    if (list._tiles) {
                        list._tiles.forEach(( /**
                         * @param {?} tile
                         * @return {?}
                         */function (/**
                         * @param {?} tile
                         * @return {?}
                         */ tile) {
                            tile._setStyle('top', null);
                            tile._setStyle('height', null);
                        }));
                    }
                };
                return FixedTileStyler;
            }(TileStyler));
            /**
             * This type of styler is instantiated when the user passes in a width:height ratio
             * for the row height.  Example `<mat-grid-list cols="3" rowHeight="3:1">`
             * \@docs-private
             */
            var RatioTileStyler = /** @class */ (function (_super) {
                __extends(RatioTileStyler, _super);
                /**
                 * @param {?} value
                 */
                function RatioTileStyler(value) {
                    var _this = _super.call(this) || this;
                    _this._parseRatio(value);
                    return _this;
                }
                /**
                 * @param {?} tile
                 * @param {?} rowIndex
                 * @param {?} percentWidth
                 * @param {?} gutterWidth
                 * @return {?}
                 */
                RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
                    /** @type {?} */
                    var percentHeightPerTile = percentWidth / this.rowHeightRatio;
                    this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
                    // Use padding-top and margin-top to maintain the given aspect ratio, as
                    // a percentage-based value for these properties is applied versus the *width* of the
                    // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
                    tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));
                    tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
                };
                /**
                 * @return {?}
                 */
                RatioTileStyler.prototype.getComputedHeight = function () {
                    return [
                        'paddingBottom', calc(this.getTileSpan(this.baseTileHeight) + " + " + this.getGutterSpan())
                    ];
                };
                /**
                 * @param {?} list
                 * @return {?}
                 */
                RatioTileStyler.prototype.reset = function (list) {
                    list._setListStyle(['paddingBottom', null]);
                    list._tiles.forEach(( /**
                     * @param {?} tile
                     * @return {?}
                     */function (/**
                     * @param {?} tile
                     * @return {?}
                     */ tile) {
                        tile._setStyle('marginTop', null);
                        tile._setStyle('paddingTop', null);
                    }));
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                RatioTileStyler.prototype._parseRatio = function (value) {
                    /** @type {?} */
                    var ratioParts = value.split(':');
                    if (ratioParts.length !== 2) {
                        throw Error("mat-grid-list: invalid ratio given for row-height: \"" + value + "\"");
                    }
                    this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
                };
                return RatioTileStyler;
            }(TileStyler));
            /**
             * This type of styler is instantiated when the user selects a "fit" row height mode.
             * In other words, the row height will reflect the total height of the container divided
             * by the number of rows.  Example `<mat-grid-list cols="3" rowHeight="fit">`
             *
             * \@docs-private
             */
            var FitTileStyler = /** @class */ (function (_super) {
                __extends(FitTileStyler, _super);
                function FitTileStyler() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} tile
                 * @param {?} rowIndex
                 * @return {?}
                 */
                FitTileStyler.prototype.setRowStyles = function (tile, rowIndex) {
                    // Percent of the available vertical space that one row takes up.
                    /** @type {?} */
                    var percentHeightPerTile = 100 / this._rowspan;
                    // Fraction of the horizontal gutter size that each column takes up.
                    /** @type {?} */
                    var gutterHeightPerTile = (this._rows - 1) / this._rows;
                    // Base vertical size of a column.
                    /** @type {?} */
                    var baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
                    tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));
                    tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));
                };
                /**
                 * @param {?} list
                 * @return {?}
                 */
                FitTileStyler.prototype.reset = function (list) {
                    if (list._tiles) {
                        list._tiles.forEach(( /**
                         * @param {?} tile
                         * @return {?}
                         */function (/**
                         * @param {?} tile
                         * @return {?}
                         */ tile) {
                            tile._setStyle('top', null);
                            tile._setStyle('height', null);
                        }));
                    }
                };
                return FitTileStyler;
            }(TileStyler));
            /**
             * Wraps a CSS string in a calc function
             * @param {?} exp
             * @return {?}
             */
            function calc(exp) {
                return "calc(" + exp + ")";
            }
            /**
             * Appends pixels to a CSS string if no units are given.
             * @param {?} value
             * @return {?}
             */
            function normalizeUnits(value) {
                return value.match(/([A-Za-z%]+)$/) ? value : value + "px";
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(kara): Conditional (responsive) column count / row size.
            // TODO(kara): Re-layout on window resize / media change (debounced).
            // TODO(kara): gridTileHeader and gridTileFooter.
            /** @type {?} */
            var MAT_FIT_MODE = 'fit';
            var MatGridList = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?} _dir
                 */
                function MatGridList(_element, _dir) {
                    this._element = _element;
                    this._dir = _dir;
                    /**
                     * The amount of space between tiles. This will be something like '5px' or '2em'.
                     */
                    this._gutter = '1px';
                }
                Object.defineProperty(MatGridList.prototype, "cols", {
                    /**
                     * Amount of columns in the grid list.
                     * @return {?}
                     */
                    get: function () { return this._cols; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._cols = Math.max(1, Math.round(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value)));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatGridList.prototype, "gutterSize", {
                    /**
                     * Size of the grid list's gutter in pixels.
                     * @return {?}
                     */
                    get: function () { return this._gutter; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._gutter = "" + (value == null ? '' : value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatGridList.prototype, "rowHeight", {
                    /**
                     * Set internal representation of row height from the user-provided value.
                     * @return {?}
                     */
                    get: function () { return this._rowHeight; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = "" + (value == null ? '' : value);
                        if (newValue !== this._rowHeight) {
                            this._rowHeight = newValue;
                            this._setTileStyler(this._rowHeight);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatGridList.prototype.ngOnInit = function () {
                    this._checkCols();
                    this._checkRowHeight();
                };
                /**
                 * The layout calculation is fairly cheap if nothing changes, so there's little cost
                 * to run it frequently.
                 * @return {?}
                 */
                MatGridList.prototype.ngAfterContentChecked = function () {
                    this._layoutTiles();
                };
                /**
                 * Throw a friendly error if cols property is missing
                 * @private
                 * @return {?}
                 */
                MatGridList.prototype._checkCols = function () {
                    if (!this.cols) {
                        throw Error("mat-grid-list: must pass in number of columns. " +
                            "Example: <mat-grid-list cols=\"3\">");
                    }
                };
                /**
                 * Default to equal width:height if rowHeight property is missing
                 * @private
                 * @return {?}
                 */
                MatGridList.prototype._checkRowHeight = function () {
                    if (!this._rowHeight) {
                        this._setTileStyler('1:1');
                    }
                };
                /**
                 * Creates correct Tile Styler subtype based on rowHeight passed in by user
                 * @private
                 * @param {?} rowHeight
                 * @return {?}
                 */
                MatGridList.prototype._setTileStyler = function (rowHeight) {
                    if (this._tileStyler) {
                        this._tileStyler.reset(this);
                    }
                    if (rowHeight === MAT_FIT_MODE) {
                        this._tileStyler = new FitTileStyler();
                    }
                    else if (rowHeight && rowHeight.indexOf(':') > -1) {
                        this._tileStyler = new RatioTileStyler(rowHeight);
                    }
                    else {
                        this._tileStyler = new FixedTileStyler(rowHeight);
                    }
                };
                /**
                 * Computes and applies the size and position for all children grid tiles.
                 * @private
                 * @return {?}
                 */
                MatGridList.prototype._layoutTiles = function () {
                    var _this = this;
                    if (!this._tileCoordinator) {
                        this._tileCoordinator = new TileCoordinator();
                    }
                    /** @type {?} */
                    var tracker = this._tileCoordinator;
                    /** @type {?} */
                    var tiles = this._tiles.filter(( /**
                     * @param {?} tile
                     * @return {?}
                     */function (/**
                     * @param {?} tile
                     * @return {?}
                     */ tile) { return !tile._gridList || tile._gridList === _this; }));
                    /** @type {?} */
                    var direction = this._dir ? this._dir.value : 'ltr';
                    this._tileCoordinator.update(this.cols, tiles);
                    this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
                    tiles.forEach(( /**
                     * @param {?} tile
                     * @param {?} index
                     * @return {?}
                     */function (tile, index) {
                        /** @type {?} */
                        var pos = tracker.positions[index];
                        _this._tileStyler.setStyle(tile, pos.row, pos.col);
                    }));
                    this._setListStyle(this._tileStyler.getComputedHeight());
                };
                /**
                 * Sets style on the main grid-list element, given the style name and value.
                 * @param {?} style
                 * @return {?}
                 */
                MatGridList.prototype._setListStyle = function (style) {
                    if (style) {
                        (( /** @type {?} */(this._element.nativeElement.style)))[style[0]] = style[1];
                    }
                };
                return MatGridList;
            }());
            MatGridList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-grid-list',
                            exportAs: 'matGridList',
                            template: "<div><ng-content></ng-content></div>",
                            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}"],
                            host: {
                                'class': 'mat-grid-list',
                            },
                            providers: [{
                                    provide: MAT_GRID_LIST,
                                    useExisting: MatGridList
                                }],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatGridList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatGridList.propDecorators = {
                _tiles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatGridTile, { descendants: true },] }],
                cols: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                gutterSize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                rowHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatGridListModule = /** @class */ (function () {
                function MatGridListModule() {
                }
                return MatGridListModule;
            }());
            MatGridListModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLineModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatCommonModule"]],
                            exports: [
                                MatGridList,
                                MatGridTile,
                                MatGridTileText,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLineModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatCommonModule"],
                                MatGridTileHeaderCssMatStyler,
                                MatGridTileFooterCssMatStyler,
                                MatGridAvatarCssMatStyler
                            ],
                            declarations: [
                                MatGridList,
                                MatGridTile,
                                MatGridTileText,
                                MatGridTileHeaderCssMatStyler,
                                MatGridTileFooterCssMatStyler,
                                MatGridAvatarCssMatStyler
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=grid-list.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/input.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/input.js ***!
          \*********************************************************/
        /*! exports provided: MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTextareaAutosize", function () { return MatTextareaAutosize; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatInput", function () { return MatInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatInputUnsupportedTypeError", function () { return getMatInputUnsupportedTypeError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatInputModule", function () { return MatInputModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_INPUT_VALUE_ACCESSOR", function () { return MAT_INPUT_VALUE_ACCESSOR; });
            /* harmony import */ var _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/text-field */ "./node_modules/@angular/cdk/esm2015/text-field.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive to automatically resize a textarea to fit its content.
             * @deprecated Use `cdkTextareaAutosize` from `\@angular/cdk/text-field` instead.
             * \@breaking-change 8.0.0
             */
            var MatTextareaAutosize = /** @class */ (function (_super) {
                __extends(MatTextareaAutosize, _super);
                function MatTextareaAutosize() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Object.defineProperty(MatTextareaAutosize.prototype, "matAutosizeMinRows", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.minRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.minRows = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTextareaAutosize.prototype, "matAutosizeMaxRows", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.maxRows; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.maxRows = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTextareaAutosize.prototype, "matAutosize", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.enabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.enabled = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTextareaAutosize.prototype, "matTextareaAutosize", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this.enabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.enabled = value; },
                    enumerable: true,
                    configurable: true
                });
                return MatTextareaAutosize;
            }(_angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["CdkTextareaAutosize"]));
            MatTextareaAutosize.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',
                            exportAs: 'matTextareaAutosize',
                            inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],
                            host: {
                                'class': 'cdk-textarea-autosize mat-autosize',
                                // Textarea elements that have the directive applied should have a single row by default.
                                // Browsers normally show two rows by default and therefore this limits the minRows binding.
                                'rows': '1',
                                '(input)': '_noopInputHandler()',
                            },
                        },] },
            ];
            MatTextareaAutosize.propDecorators = {
                matAutosizeMinRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                matAutosizeMaxRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                matAutosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['mat-autosize',] }],
                matTextareaAutosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} type
             * @return {?}
             */
            function getMatInputUnsupportedTypeError(type) {
                return Error("Input type \"" + type + "\" isn't supported by matInput.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This token is used to inject the object whose value should be set into `MatInput`. If none is
             * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide
             * themselves for this token, in order to make `MatInput` delegate the getting and setting of the
             * value to them.
             * @type {?}
             */
            var MAT_INPUT_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('MAT_INPUT_VALUE_ACCESSOR');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.
            /** @type {?} */
            var MAT_INPUT_INVALID_TYPES = [
                'button',
                'checkbox',
                'file',
                'hidden',
                'image',
                'radio',
                'range',
                'reset',
                'submit'
            ];
            /** @type {?} */
            var nextUniqueId = 0;
            // Boilerplate for applying mixins to MatInput.
            /**
             * \@docs-private
             */
            var MatInputBase = /** @class */ (function () {
                /**
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} ngControl
                 */
                function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
                    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
                    this._parentForm = _parentForm;
                    this._parentFormGroup = _parentFormGroup;
                    this.ngControl = ngControl;
                }
                return MatInputBase;
            }());
            /** @type {?} */
            var _MatInputMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinErrorState"])(MatInputBase);
            /**
             * Directive that allows a native input to work inside a `MatFormField`.
             */
            var MatInput = /** @class */ (function (_super) {
                __extends(MatInput, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _platform
                 * @param {?} ngControl
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} inputValueAccessor
                 * @param {?} _autofillMonitor
                 * @param {?} ngZone
                 */
                function MatInput(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {
                    var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
                    _this._elementRef = _elementRef;
                    _this._platform = _platform;
                    _this.ngControl = ngControl;
                    _this._autofillMonitor = _autofillMonitor;
                    _this._uid = "mat-input-" + nextUniqueId++;
                    /**
                     * Whether the component is being rendered on the server.
                     */
                    _this._isServer = false;
                    /**
                     * Whether the component is a native html select.
                     */
                    _this._isNativeSelect = false;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this.focused = false;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__["Subject"]();
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this.controlType = 'mat-input';
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this.autofilled = false;
                    _this._disabled = false;
                    _this._required = false;
                    _this._type = 'text';
                    _this._readonly = false;
                    _this._neverEmptyInputTypes = [
                        'date',
                        'datetime',
                        'datetime-local',
                        'month',
                        'time',
                        'week'
                    ].filter(( /**
                     * @param {?} t
                     * @return {?}
                     */function (/**
                     * @param {?} t
                     * @return {?}
                     */ t) { return Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__["getSupportedInputTypes"])().has(t); }));
                    /** @type {?} */
                    var element = _this._elementRef.nativeElement;
                    // If no input value accessor was explicitly specified, use the element as the input value
                    // accessor.
                    _this._inputValueAccessor = inputValueAccessor || element;
                    _this._previousNativeValue = _this.value;
                    // Force setter to be called in case id was not specified.
                    _this.id = _this.id;
                    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete
                    // key. In order to get around this we need to "jiggle" the caret loose. Since this bug only
                    // exists on iOS, we only bother to install the listener on iOS.
                    if (_platform.IOS) {
                        ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            _elementRef.nativeElement.addEventListener('keyup', ( /**
                             * @param {?} event
                             * @return {?}
                             */function (event) {
                                /** @type {?} */
                                var el = ( /** @type {?} */(event.target));
                                if (!el.value && !el.selectionStart && !el.selectionEnd) {
                                    // Note: Just setting `0, 0` doesn't fix the issue. Setting
                                    // `1, 1` fixes it for the first time that you type text and
                                    // then hold delete. Toggling to `1, 1` and then back to
                                    // `0, 0` seems to completely fix it.
                                    el.setSelectionRange(1, 1);
                                    el.setSelectionRange(0, 0);
                                }
                            }));
                        }));
                    }
                    _this._isServer = !_this._platform.isBrowser;
                    _this._isNativeSelect = element.nodeName.toLowerCase() === 'select';
                    if (_this._isNativeSelect) {
                        _this.controlType = (( /** @type {?} */(element))).multiple ? 'mat-native-select-multiple' :
                            'mat-native-select';
                    }
                    return _this;
                }
                Object.defineProperty(MatInput.prototype, "disabled", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        if (this.ngControl && this.ngControl.disabled !== null) {
                            return this.ngControl.disabled;
                        }
                        return this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        // Browsers may not fire the blur event if the input is disabled too quickly.
                        // Reset from here to ensure that the element doesn't become stuck.
                        if (this.focused) {
                            this.focused = false;
                            this.stateChanges.next();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "id", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._id; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._id = value || this._uid; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "required", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "type", {
                    /**
                     * Input type of the element.
                     * @return {?}
                     */
                    get: function () { return this._type; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._type = value || 'text';
                        this._validateType();
                        // When using Angular inputs, developers are no longer able to set the properties on the native
                        // input element. To ensure that bindings for `type` work, we need to sync the setter
                        // with the native property. Textarea elements don't support the type property or attribute.
                        if (!this._isTextarea() && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__["getSupportedInputTypes"])().has(this._type)) {
                            (( /** @type {?} */(this._elementRef.nativeElement))).type = this._type;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "value", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._inputValueAccessor.value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this.value) {
                            this._inputValueAccessor.value = value;
                            this.stateChanges.next();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "readonly", {
                    /**
                     * Whether the element is readonly.
                     * @return {?}
                     */
                    get: function () { return this._readonly; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._readonly = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngOnInit = function () {
                    var _this = this;
                    if (this._platform.isBrowser) {
                        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            _this.autofilled = event.isAutofilled;
                            _this.stateChanges.next();
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngOnChanges = function () {
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngOnDestroy = function () {
                    this.stateChanges.complete();
                    if (this._platform.isBrowser) {
                        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
                    }
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype.ngDoCheck = function () {
                    if (this.ngControl) {
                        // We need to re-evaluate this on every change detection cycle, because there are some
                        // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                        // that whatever logic is in here has to be super lean or we risk destroying the performance.
                        this.updateErrorState();
                    }
                    // We need to dirty-check the native element's value, because there are some cases where
                    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
                    // updating the value using `emitEvent: false`).
                    this._dirtyCheckNativeValue();
                };
                /**
                 * Focuses the input.
                 * @param {?=} options
                 * @return {?}
                 */
                MatInput.prototype.focus = function (options) {
                    this._elementRef.nativeElement.focus(options);
                };
                /**
                 * Callback for the cases where the focused state of the input changes.
                 * @param {?} isFocused
                 * @return {?}
                 */
                MatInput.prototype._focusChanged = function (isFocused) {
                    if (isFocused !== this.focused && (!this.readonly || !isFocused)) {
                        this.focused = isFocused;
                        this.stateChanges.next();
                    }
                };
                /**
                 * @return {?}
                 */
                MatInput.prototype._onInput = function () {
                    // This is a noop function and is used to let Angular know whenever the value changes.
                    // Angular will run a new change detection each time the `input` event has been dispatched.
                    // It's necessary that Angular recognizes the value change, because when floatingLabel
                    // is set to false and Angular forms aren't used, the placeholder won't recognize the
                    // value changes and will not disappear.
                    // Listening to the input event wouldn't be necessary when the input is using the
                    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
                };
                /**
                 * Does some manual dirty checking on the native input `value` property.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._dirtyCheckNativeValue = function () {
                    /** @type {?} */
                    var newValue = this._elementRef.nativeElement.value;
                    if (this._previousNativeValue !== newValue) {
                        this._previousNativeValue = newValue;
                        this.stateChanges.next();
                    }
                };
                /**
                 * Make sure the input is a supported type.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._validateType = function () {
                    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {
                        throw getMatInputUnsupportedTypeError(this._type);
                    }
                };
                /**
                 * Checks whether the input type is one of the types that are never empty.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._isNeverEmpty = function () {
                    return this._neverEmptyInputTypes.indexOf(this._type) > -1;
                };
                /**
                 * Checks whether the input is invalid based on the native validation.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._isBadInput = function () {
                    // The `validity` property won't be present on platform-server.
                    /** @type {?} */
                    var validity = (( /** @type {?} */(this._elementRef.nativeElement))).validity;
                    return validity && validity.badInput;
                };
                /**
                 * Determines if the component host is a textarea.
                 * @protected
                 * @return {?}
                 */
                MatInput.prototype._isTextarea = function () {
                    return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';
                };
                Object.defineProperty(MatInput.prototype, "empty", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&
                            !this.autofilled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatInput.prototype, "shouldLabelFloat", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        if (this._isNativeSelect) {
                            // For a single-selection `<select>`, the label should float when the selected option has
                            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid
                            // overlapping the label with the options.
                            /** @type {?} */
                            var selectElement = ( /** @type {?} */(this._elementRef.nativeElement));
                            /** @type {?} */
                            var firstOption = selectElement.options[0];
                            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be
                            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.
                            return this.focused || selectElement.multiple || !this.empty ||
                                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);
                        }
                        else {
                            return this.focused || !this.empty;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} ids
                 * @return {?}
                 */
                MatInput.prototype.setDescribedByIds = function (ids) {
                    this._ariaDescribedby = ids.join(' ');
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @return {?}
                 */
                MatInput.prototype.onContainerClick = function () {
                    // Do not re-focus the input element if the element is already focused. Otherwise it can happen
                    // that someone clicks on a time input and the cursor resets to the "hours" field while the
                    // "minutes" field was actually clicked. See: https://github.com/angular/components/issues/12849
                    if (!this.focused) {
                        this.focus();
                    }
                };
                return MatInput;
            }(_MatInputMixinBase));
            MatInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: "input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]",
                            exportAs: 'matInput',
                            host: {
                                /**
                                 * \@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.
                                 */
                                'class': 'mat-input-element mat-form-field-autofill-control',
                                '[class.mat-input-server]': '_isServer',
                                // Native input properties that are overwritten by Angular inputs need to be synced with
                                // the native input element. Otherwise property bindings for those don't work.
                                '[attr.id]': 'id',
                                '[attr.placeholder]': 'placeholder',
                                '[disabled]': 'disabled',
                                '[required]': 'required',
                                '[attr.readonly]': 'readonly && !_isNativeSelect || null',
                                '[attr.aria-describedby]': '_ariaDescribedby || null',
                                '[attr.aria-invalid]': 'errorState',
                                '[attr.aria-required]': 'required.toString()',
                                '(blur)': '_focusChanged(false)',
                                '(focus)': '_focusChanged(true)',
                                '(input)': '_onInput()',
                            },
                            providers: [{ provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__["MatFormFieldControl"], useExisting: MatInput }],
                        },] },
            ];
            /** @nocollapse */
            MatInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__["Platform"] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgControl"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgForm"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["FormGroupDirective"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["ErrorStateMatcher"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_INPUT_VALUE_ACCESSOR,] }] },
                { type: _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["AutofillMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
            ]; };
            MatInput.propDecorators = {
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                readonly: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatInputModule = /** @class */ (function () {
                function MatInputModule() {
                }
                return MatInputModule;
            }());
            MatInputModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            declarations: [MatInput, MatTextareaAutosize],
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_8__["CommonModule"],
                                _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["TextFieldModule"],
                                _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__["MatFormFieldModule"],
                            ],
                            exports: [
                                _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__["TextFieldModule"],
                                // We re-export the `MatFormFieldModule` since `MatInput` will almost always
                                // be used together with `MatFormField`.
                                _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__["MatFormFieldModule"],
                                MatInput,
                                MatTextareaAutosize,
                            ],
                            providers: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["ErrorStateMatcher"]],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=input.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/menu.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/menu.js ***!
          \********************************************************/
        /*! exports provided: MatMenu, MAT_MENU_DEFAULT_OPTIONS, _MatMenu, _MatMenuBase, MatMenuItem, MatMenuTrigger, MAT_MENU_SCROLL_STRATEGY, MAT_MENU_PANEL, _MatMenuDirectivesModule, MatMenuModule, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, ɵa22, ɵb22, ɵc22 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenu", function () { return MatMenu; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_DEFAULT_OPTIONS", function () { return MAT_MENU_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatMenu", function () { return _MatMenu; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatMenuBase", function () { return _MatMenuBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuItem", function () { return MatMenuItem; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuTrigger", function () { return MatMenuTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_SCROLL_STRATEGY", function () { return MAT_MENU_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_PANEL", function () { return MAT_MENU_PANEL; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatMenuDirectivesModule", function () { return _MatMenuDirectivesModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuModule", function () { return MatMenuModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMenuAnimations", function () { return matMenuAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fadeInItems", function () { return fadeInItems; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMenu", function () { return transformMenu; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuContent", function () { return MatMenuContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa22", function () { return MAT_MENU_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb22", function () { return MAT_MENU_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc22", function () { return MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the mat-menu component.
             * Animation duration and timing values are based on:
             * https://material.io/guidelines/components/menus.html#menus-usage
             * \@docs-private
             * @type {?}
             */
            var matMenuAnimations = {
                /**
                 * This animation controls the menu panel's entry and exit from the page.
                 *
                 * When the menu panel is added to the DOM, it scales in and fades in its border.
                 *
                 * When the menu panel is removed from the DOM, it simply fades out after a brief
                 * delay to display the ripple.
                 */
                transformMenu: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('transformMenu', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        opacity: 0,
                        transform: 'scale(0.8)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["group"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["query"])('.mat-menu-content, .mat-mdc-menu-content', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                            opacity: 1
                        }))),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('120ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'scale(1)' })),
                    ])),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms 25ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 })))
                ]),
                /**
                 * This animation fades in the background color and content of the menu panel
                 * after its containing element is scaled in.
                 */
                fadeInItems: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('fadeInItems', [
                    // TODO(crisbeto): this is inside the `transformMenu`
                    // now. Remove next time we do breaking changes.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('showing', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 1 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                    ])
                ])
            };
            /**
             * @deprecated
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var fadeInItems = matMenuAnimations.fadeInItems;
            /**
             * @deprecated
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var transformMenu = matMenuAnimations.transformMenu;
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Menu content that will be rendered lazily once the menu is opened.
             */
            var MatMenuContent = /** @class */ (function () {
                /**
                 * @param {?} _template
                 * @param {?} _componentFactoryResolver
                 * @param {?} _appRef
                 * @param {?} _injector
                 * @param {?} _viewContainerRef
                 * @param {?} _document
                 * @param {?=} _changeDetectorRef
                 */
                function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document, _changeDetectorRef) {
                    this._template = _template;
                    this._componentFactoryResolver = _componentFactoryResolver;
                    this._appRef = _appRef;
                    this._injector = _injector;
                    this._viewContainerRef = _viewContainerRef;
                    this._document = _document;
                    this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Emits when the menu content has been attached.
                     */
                    this._attached = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                }
                /**
                 * Attaches the content with a particular context.
                 * \@docs-private
                 * @param {?=} context
                 * @return {?}
                 */
                MatMenuContent.prototype.attach = function (context) {
                    if (context === void 0) { context = {}; }
                    if (!this._portal) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["TemplatePortal"](this._template, this._viewContainerRef);
                    }
                    this.detach();
                    if (!this._outlet) {
                        this._outlet = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["DomPortalOutlet"](this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
                    }
                    /** @type {?} */
                    var element = this._template.elementRef.nativeElement;
                    // Because we support opening the same menu from different triggers (which in turn have their
                    // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
                    // risk it staying attached to a pane that's no longer in the DOM.
                    ( /** @type {?} */(element.parentNode)).insertBefore(this._outlet.outletElement, element);
                    // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu
                    // content via `createEmbeddedView` does not cause the content to be seen as "dirty"
                    // by Angular. This causes the `@ContentChildren` for menu items within the menu to
                    // not be updated by Angular. By explicitly marking for check here, we tell Angular that
                    // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.
                    // @breaking-change 9.0.0 Make change detector ref required
                    if (this._changeDetectorRef) {
                        this._changeDetectorRef.markForCheck();
                    }
                    this._portal.attach(this._outlet, context);
                    this._attached.next();
                };
                /**
                 * Detaches the content.
                 * \@docs-private
                 * @return {?}
                 */
                MatMenuContent.prototype.detach = function () {
                    if (this._portal.isAttached) {
                        this._portal.detach();
                    }
                };
                /**
                 * @return {?}
                 */
                MatMenuContent.prototype.ngOnDestroy = function () {
                    if (this._outlet) {
                        this._outlet.dispose();
                    }
                };
                return MatMenuContent;
            }());
            MatMenuContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'ng-template[matMenuContent]'
                        },] },
            ];
            /** @nocollapse */
            MatMenuContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ComponentFactoryResolver"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ApplicationRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injector"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance
             * \@docs-private
             * @return {?}
             */
            function throwMatMenuMissingError() {
                throw Error("matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>");
            }
            /**
             * Throws an exception for the case when menu's x-position value isn't valid.
             * In other words, it doesn't match 'before' or 'after'.
             * \@docs-private
             * @return {?}
             */
            function throwMatMenuInvalidPositionX() {
                throw Error("xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>");
            }
            /**
             * Throws an exception for the case when menu's y-position value isn't valid.
             * In other words, it doesn't match 'above' or 'below'.
             * \@docs-private
             * @return {?}
             */
            function throwMatMenuInvalidPositionY() {
                throw Error("yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token used to provide the parent menu to menu-specific components.
             * \@docs-private
             * @type {?}
             */
            var MAT_MENU_PANEL = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('MAT_MENU_PANEL');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatMenuItem.
            /**
             * \@docs-private
             */
            var MatMenuItemBase = /** @class */ (function () {
                function MatMenuItemBase() {
                }
                return MatMenuItemBase;
            }());
            /** @type {?} */
            var _MatMenuItemMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisabled"])(MatMenuItemBase));
            /**
             * This directive is intended to be used inside an mat-menu tag.
             * It exists mostly to set the role attribute.
             */
            var MatMenuItem = /** @class */ (function (_super) {
                __extends(MatMenuItem, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?=} document
                 * @param {?=} _focusMonitor
                 * @param {?=} _parentMenu
                 */
                function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {
                    var _this = 
                    // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.
                    _super.call(this) || this;
                    _this._elementRef = _elementRef;
                    _this._focusMonitor = _focusMonitor;
                    _this._parentMenu = _parentMenu;
                    /**
                     * ARIA role for the menu item.
                     */
                    _this.role = 'menuitem';
                    /**
                     * Stream that emits when the menu item is hovered.
                     */
                    _this._hovered = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Whether the menu item is highlighted.
                     */
                    _this._highlighted = false;
                    /**
                     * Whether the menu item acts as a trigger for a sub-menu.
                     */
                    _this._triggersSubmenu = false;
                    if (_focusMonitor) {
                        // Start monitoring the element so it gets the appropriate focused classes. We want
                        // to show the focus style for menu items only when the focus was not caused by a
                        // mouse or touch interaction.
                        _focusMonitor.monitor(_this._elementRef, false);
                    }
                    if (_parentMenu && _parentMenu.addItem) {
                        _parentMenu.addItem(_this);
                    }
                    _this._document = document;
                    return _this;
                }
                /**
                 * Focuses the menu item.
                 * @param {?=} origin
                 * @param {?=} options
                 * @return {?}
                 */
                MatMenuItem.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    if (this._focusMonitor) {
                        this._focusMonitor.focusVia(this._getHostElement(), origin, options);
                    }
                    else {
                        this._getHostElement().focus(options);
                    }
                };
                /**
                 * @return {?}
                 */
                MatMenuItem.prototype.ngOnDestroy = function () {
                    if (this._focusMonitor) {
                        this._focusMonitor.stopMonitoring(this._elementRef);
                    }
                    if (this._parentMenu && this._parentMenu.removeItem) {
                        this._parentMenu.removeItem(this);
                    }
                    this._hovered.complete();
                };
                /**
                 * Used to set the `tabindex`.
                 * @return {?}
                 */
                MatMenuItem.prototype._getTabIndex = function () {
                    return this.disabled ? '-1' : '0';
                };
                /**
                 * Returns the host DOM element.
                 * @return {?}
                 */
                MatMenuItem.prototype._getHostElement = function () {
                    return this._elementRef.nativeElement;
                };
                /**
                 * Prevents the default element actions if it is disabled.
                 * @param {?} event
                 * @return {?}
                 */
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                MatMenuItem.prototype._checkDisabled = function (event) {
                    if (this.disabled) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                };
                /**
                 * Emits to the hover stream.
                 * @return {?}
                 */
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                MatMenuItem.prototype._handleMouseEnter = function () {
                    this._hovered.next(this);
                };
                /**
                 * Gets the label to be used when determining whether the option should be focused.
                 * @return {?}
                 */
                MatMenuItem.prototype.getLabel = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var textNodeType = this._document ? this._document.TEXT_NODE : 3;
                    /** @type {?} */
                    var output = '';
                    if (element.childNodes) {
                        /** @type {?} */
                        var length = element.childNodes.length;
                        // Go through all the top-level text nodes and extract their text.
                        // We skip anything that's not a text node to prevent the text from
                        // being thrown off by something like an icon.
                        for (var i = 0; i < length; i++) {
                            if (element.childNodes[i].nodeType === textNodeType) {
                                output += element.childNodes[i].textContent;
                            }
                        }
                    }
                    return output.trim();
                };
                return MatMenuItem;
            }(_MatMenuItemMixinBase));
            MatMenuItem.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: '[mat-menu-item]',
                            exportAs: 'matMenuItem',
                            inputs: ['disabled', 'disableRipple'],
                            host: {
                                '[attr.role]': 'role',
                                'class': 'mat-menu-item',
                                '[class.mat-menu-item-highlighted]': '_highlighted',
                                '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',
                                '[attr.tabindex]': '_getTabIndex()',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.disabled]': 'disabled || null',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            template: "<ng-content></ng-content><div class=\"mat-menu-ripple\" matRipple [matRippleDisabled]=\"disableRipple || disabled\" [matRippleTrigger]=\"_getHostElement()\"></div>",
                        },] },
            ];
            /** @nocollapse */
            MatMenuItem.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["FocusMonitor"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_PANEL,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            MatMenuItem.propDecorators = {
                role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                _checkDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["HostListener"], args: ['click', ['$event'],] }],
                _handleMouseEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["HostListener"], args: ['mouseenter',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for `mat-menu`.
             * @type {?}
             */
            var MAT_MENU_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-menu-default-options', {
                providedIn: 'root',
                factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_MENU_DEFAULT_OPTIONS_FACTORY() {
                return {
                    overlapTrigger: false,
                    xPosition: 'after',
                    yPosition: 'below',
                    backdropClass: 'cdk-overlay-transparent-backdrop',
                };
            }
            /**
             * Start elevation for the menu panel.
             * \@docs-private
             * @type {?}
             */
            var MAT_MENU_BASE_ELEVATION = 4;
            /**
             * Base class with all of the `MatMenu` functionality.
             */
            // tslint:disable-next-line:class-name
            var _MatMenuBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} _defaultOptions
                 */
                function _MatMenuBase(_elementRef, _ngZone, _defaultOptions) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    this._defaultOptions = _defaultOptions;
                    this._xPosition = this._defaultOptions.xPosition;
                    this._yPosition = this._defaultOptions.yPosition;
                    /**
                     * Only the direct descendant menu items.
                     */
                    this._directDescendantItems = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["QueryList"]();
                    /**
                     * Subscription to tab events on the menu panel
                     */
                    this._tabSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Config object to be passed into the menu's ngClass
                     */
                    this._classList = {};
                    /**
                     * Current state of the panel animation.
                     */
                    this._panelAnimationState = 'void';
                    /**
                     * Emits whenever an animation on the menu completes.
                     */
                    this._animationDone = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Class to be added to the backdrop element.
                     */
                    this.backdropClass = this._defaultOptions.backdropClass;
                    this._overlapTrigger = this._defaultOptions.overlapTrigger;
                    this._hasBackdrop = this._defaultOptions.hasBackdrop;
                    /**
                     * Event emitted when the menu is closed.
                     */
                    this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the menu is closed.
                     * @deprecated Switch to `closed` instead
                     * \@breaking-change 8.0.0
                     */
                    this.close = this.closed;
                }
                Object.defineProperty(_MatMenuBase.prototype, "xPosition", {
                    /**
                     * Position of the menu in the X axis.
                     * @return {?}
                     */
                    get: function () { return this._xPosition; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== 'before' && value !== 'after') {
                            throwMatMenuInvalidPositionX();
                        }
                        this._xPosition = value;
                        this.setPositionClasses();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "yPosition", {
                    /**
                     * Position of the menu in the Y axis.
                     * @return {?}
                     */
                    get: function () { return this._yPosition; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== 'above' && value !== 'below') {
                            throwMatMenuInvalidPositionY();
                        }
                        this._yPosition = value;
                        this.setPositionClasses();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "overlapTrigger", {
                    /**
                     * Whether the menu should overlap its trigger.
                     * @return {?}
                     */
                    get: function () { return this._overlapTrigger; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._overlapTrigger = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "hasBackdrop", {
                    /**
                     * Whether the menu has a backdrop.
                     * @return {?}
                     */
                    get: function () { return this._hasBackdrop; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._hasBackdrop = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "panelClass", {
                    /**
                     * This method takes classes set on the host mat-menu element and applies them on the
                     * menu template that displays in the overlay container.  Otherwise, it's difficult
                     * to style the containing menu from outside the component.
                     * @param {?} classes list of class names
                     * @return {?}
                     */
                    set: function (classes) {
                        var _this = this;
                        /** @type {?} */
                        var previousPanelClass = this._previousPanelClass;
                        if (previousPanelClass && previousPanelClass.length) {
                            previousPanelClass.split(' ').forEach(( /**
                             * @param {?} className
                             * @return {?}
                             */function (className) {
                                _this._classList[className] = false;
                            }));
                        }
                        this._previousPanelClass = classes;
                        if (classes && classes.length) {
                            classes.split(' ').forEach(( /**
                             * @param {?} className
                             * @return {?}
                             */function (className) {
                                _this._classList[className] = true;
                            }));
                            this._elementRef.nativeElement.className = '';
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "classList", {
                    /**
                     * This method takes classes set on the host mat-menu element and applies them on the
                     * menu template that displays in the overlay container.  Otherwise, it's difficult
                     * to style the containing menu from outside the component.
                     * @deprecated Use `panelClass` instead.
                     * \@breaking-change 8.0.0
                     * @return {?}
                     */
                    get: function () { return this.panelClass; },
                    /**
                     * @param {?} classes
                     * @return {?}
                     */
                    set: function (classes) { this.panelClass = classes; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                _MatMenuBase.prototype.ngOnInit = function () {
                    this.setPositionClasses();
                };
                /**
                 * @return {?}
                 */
                _MatMenuBase.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._updateDirectDescendants();
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["FocusKeyManager"](this._directDescendantItems).withWrap().withTypeAhead();
                    this._tabSubscription = this._keyManager.tabOut.subscribe(( /**
                     * @return {?}
                     */function () { return _this.closed.emit('tab'); }));
                };
                /**
                 * @return {?}
                 */
                _MatMenuBase.prototype.ngOnDestroy = function () {
                    this._directDescendantItems.destroy();
                    this._tabSubscription.unsubscribe();
                    this.closed.complete();
                };
                /**
                 * Stream that emits whenever the hovered menu item changes.
                 * @return {?}
                 */
                _MatMenuBase.prototype._hovered = function () {
                    // Coerce the `changes` property because Angular types it as `Observable<any>`
                    /** @type {?} */
                    var itemChanges = ( /** @type {?} */(this._directDescendantItems.changes));
                    return itemChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(this._directDescendantItems), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["switchMap"])(( /**
                     * @param {?} items
                     * @return {?}
                     */function (/**
                     * @param {?} items
                     * @return {?}
                     */ items) { return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"]).apply(void 0, items.map(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) { return item._hovered; }))); })));
                };
                /*
                   * Registers a menu item with the menu.
                   * @docs-private
                   * @deprecated No longer being used. To be removed.
                   * @breaking-change 9.0.0
                   */
                /**
                 * @param {?} _item
                 * @return {?}
                 */
                _MatMenuBase.prototype.addItem = function (_item) { };
                /**
                 * Removes an item from the menu.
                 * \@docs-private
                 * @deprecated No longer being used. To be removed.
                 * \@breaking-change 9.0.0
                 * @param {?} _item
                 * @return {?}
                 */
                _MatMenuBase.prototype.removeItem = function (_item) { };
                /**
                 * Handle a keyboard event from the menu, delegating to the appropriate action.
                 * @param {?} event
                 * @return {?}
                 */
                _MatMenuBase.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    switch (keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["ESCAPE"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["hasModifierKey"])(event)) {
                                event.preventDefault();
                                this.closed.emit('keydown');
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["LEFT_ARROW"]:
                            if (this.parentMenu && this.direction === 'ltr') {
                                this.closed.emit('keydown');
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["RIGHT_ARROW"]:
                            if (this.parentMenu && this.direction === 'rtl') {
                                this.closed.emit('keydown');
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["HOME"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["END"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["hasModifierKey"])(event)) {
                                keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
                                event.preventDefault();
                            }
                            break;
                        default:
                            if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["DOWN_ARROW"]) {
                                manager.setFocusOrigin('keyboard');
                            }
                            manager.onKeydown(event);
                    }
                };
                /**
                 * Focus the first item in the menu.
                 * @param {?=} origin Action from which the focus originated. Used to set the correct styling.
                 * @return {?}
                 */
                _MatMenuBase.prototype.focusFirstItem = function (origin) {
                    if (origin === void 0) { origin = 'program'; }
                    /** @type {?} */
                    var manager = this._keyManager;
                    // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
                    if (this.lazyContent) {
                        this._ngZone.onStable.asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1))
                            .subscribe(( /**
                     * @return {?}
                     */function () { return manager.setFocusOrigin(origin).setFirstItemActive(); }));
                    }
                    else {
                        manager.setFocusOrigin(origin).setFirstItemActive();
                    }
                    // If there's no active item at this point, it means that all the items are disabled.
                    // Move focus to the menu panel so keyboard events like Escape still work. Also this will
                    // give _some_ feedback to screen readers.
                    if (!manager.activeItem && this._directDescendantItems.length) {
                        /** @type {?} */
                        var element = this._directDescendantItems.first._getHostElement().parentElement;
                        // Because the `mat-menu` is at the DOM insertion point, not inside the overlay, we don't
                        // have a nice way of getting a hold of the menu panel. We can't use a `ViewChild` either
                        // because the panel is inside an `ng-template`. We work around it by starting from one of
                        // the items and walking up the DOM.
                        while (element) {
                            if (element.getAttribute('role') === 'menu') {
                                element.focus();
                                break;
                            }
                            else {
                                element = element.parentElement;
                            }
                        }
                    }
                };
                /**
                 * Resets the active item in the menu. This is used when the menu is opened, allowing
                 * the user to start from the first option when pressing the down arrow.
                 * @return {?}
                 */
                _MatMenuBase.prototype.resetActiveItem = function () {
                    this._keyManager.setActiveItem(-1);
                };
                /**
                 * Sets the menu panel elevation.
                 * @param {?} depth Number of parent menus that come before the menu.
                 * @return {?}
                 */
                _MatMenuBase.prototype.setElevation = function (depth) {
                    // The elevation starts at the base and increases by one for each level.
                    /** @type {?} */
                    var newElevation = "mat-elevation-z" + (MAT_MENU_BASE_ELEVATION + depth);
                    /** @type {?} */
                    var customElevation = Object.keys(this._classList).find(( /**
                     * @param {?} c
                     * @return {?}
                     */function (/**
                     * @param {?} c
                     * @return {?}
                     */ c) { return c.startsWith('mat-elevation-z'); }));
                    if (!customElevation || customElevation === this._previousElevation) {
                        if (this._previousElevation) {
                            this._classList[this._previousElevation] = false;
                        }
                        this._classList[newElevation] = true;
                        this._previousElevation = newElevation;
                    }
                };
                /**
                 * Adds classes to the menu panel based on its position. Can be used by
                 * consumers to add specific styling based on the position.
                 * \@docs-private
                 * @param {?=} posX Position of the menu along the x axis.
                 * @param {?=} posY Position of the menu along the y axis.
                 * @return {?}
                 */
                _MatMenuBase.prototype.setPositionClasses = function (posX, posY) {
                    if (posX === void 0) { posX = this.xPosition; }
                    if (posY === void 0) { posY = this.yPosition; }
                    /** @type {?} */
                    var classes = this._classList;
                    classes['mat-menu-before'] = posX === 'before';
                    classes['mat-menu-after'] = posX === 'after';
                    classes['mat-menu-above'] = posY === 'above';
                    classes['mat-menu-below'] = posY === 'below';
                };
                /**
                 * Starts the enter animation.
                 * @return {?}
                 */
                _MatMenuBase.prototype._startAnimation = function () {
                    // @breaking-change 8.0.0 Combine with _resetAnimation.
                    this._panelAnimationState = 'enter';
                };
                /**
                 * Resets the panel animation to its initial state.
                 * @return {?}
                 */
                _MatMenuBase.prototype._resetAnimation = function () {
                    // @breaking-change 8.0.0 Combine with _startAnimation.
                    this._panelAnimationState = 'void';
                };
                /**
                 * Callback that is invoked when the panel animation completes.
                 * @param {?} event
                 * @return {?}
                 */
                _MatMenuBase.prototype._onAnimationDone = function (event) {
                    this._animationDone.next(event);
                    this._isAnimating = false;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                _MatMenuBase.prototype._onAnimationStart = function (event) {
                    this._isAnimating = true;
                    // Scroll the content element to the top as soon as the animation starts. This is necessary,
                    // because we move focus to the first item while it's still being animated, which can throw
                    // the browser off when it determines the scroll position. Alternatively we can move focus
                    // when the animation is done, however moving focus asynchronously will interrupt screen
                    // readers which are in the process of reading out the menu already. We take the `element`
                    // from the `event` since we can't use a `ViewChild` to access the pane.
                    if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
                        event.element.scrollTop = 0;
                    }
                };
                /**
                 * Sets up a stream that will keep track of any newly-added menu items and will update the list
                 * of direct descendants. We collect the descendants this way, because `_allItems` can include
                 * items that are part of child menus, and using a custom way of registering items is unreliable
                 * when it comes to maintaining the item order.
                 * @private
                 * @return {?}
                 */
                _MatMenuBase.prototype._updateDirectDescendants = function () {
                    var _this = this;
                    this._allItems.changes
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(this._allItems))
                        .subscribe(( /**
                 * @param {?} items
                 * @return {?}
                 */function (items) {
                        _this._directDescendantItems.reset(items.filter(( /**
                         * @param {?} item
                         * @return {?}
                         */function (/**
                         * @param {?} item
                         * @return {?}
                         */ item) { return item._parentMenu === _this; })));
                        _this._directDescendantItems.notifyOnChanges();
                    }));
                };
                return _MatMenuBase;
            }());
            /** @nocollapse */
            _MatMenuBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_DEFAULT_OPTIONS,] }] }
            ]; };
            _MatMenuBase.propDecorators = {
                _allItems: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatMenuItem, { descendants: true },] }],
                backdropClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                xPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                yPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                templateRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"], { static: false },] }],
                items: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatMenuItem,] }],
                lazyContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatMenuContent, { static: false },] }],
                overlapTrigger: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                hasBackdrop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['class',] }],
                classList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                close: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * \@docs-private We show the "_MatMenu" class as "MatMenu" in the docs.
             */
            var MatMenu = /** @class */ (function (_super) {
                __extends(MatMenu, _super);
                function MatMenu() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatMenu;
            }(_MatMenuBase));
            // Note on the weird inheritance setup: we need three classes, because the MDC-based menu has to
            // extend `MatMenu`, however keeping a reference to it will cause the inlined template and styles
            // to be retained as well. The MDC menu also has to provide itself as a `MatMenu` in order for
            // queries and DI to work correctly, while still not referencing the actual menu class.
            // Class responsibility is split up as follows:
            // * _MatMenuBase - provides all the functionality without any of the Angular metadata.
            // * MatMenu - keeps the same name symbol name as the current menu and
            // is used as a provider for DI and query purposes.
            // * _MatMenu - the actual menu component implementation with the Angular metadata that should
            // be tree shaken away for MDC.
            /**
             * \@docs-public MatMenu
             */
            // tslint:disable-next-line:class-name
            var _MatMenu = /** @class */ (function (_super) {
                __extends(_MatMenu, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} ngZone
                 * @param {?} defaultOptions
                 */
                function _MatMenu(elementRef, ngZone, defaultOptions) {
                    return _super.call(this, elementRef, ngZone, defaultOptions) || this;
                }
                return _MatMenu;
            }(MatMenu));
            _MatMenu.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-menu',
                            template: "<ng-template><div class=\"mat-menu-panel\" [ngClass]=\"_classList\" (keydown)=\"_handleKeydown($event)\" (click)=\"closed.emit('click')\" [@transformMenu]=\"_panelAnimationState\" (@transformMenu.start)=\"_onAnimationStart($event)\" (@transformMenu.done)=\"_onAnimationDone($event)\" tabindex=\"-1\" role=\"menu\"><div class=\"mat-menu-content\"><ng-content></ng-content></div></div></ng-template>",
                            styles: [".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matMenu',
                            animations: [
                                matMenuAnimations.transformMenu,
                                matMenuAnimations.fadeInItems
                            ],
                            providers: [
                                { provide: MAT_MENU_PANEL, useExisting: MatMenu },
                                { provide: MatMenu, useExisting: _MatMenu }
                            ]
                        },] },
            ];
            /** @nocollapse */
            _MatMenu.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_DEFAULT_OPTIONS,] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that determines the scroll handling while the menu is open.
             * @type {?}
             */
            var MAT_MENU_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-menu-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_MENU_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["Overlay"]],
                useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Default top padding of the menu panel.
             * @type {?}
             */
            var MENU_PANEL_TOP_PADDING = 8;
            /**
             * Options for binding a passive event listener.
             * @type {?}
             */
            var passiveEventListenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["normalizePassiveListenerOptions"])({ passive: true });
            // TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors
            /**
             * This directive is intended to be used in conjunction with an mat-menu tag.  It is
             * responsible for toggling the display of the provided menu instance.
             */
            var MatMenuTrigger = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _element
                 * @param {?} _viewContainerRef
                 * @param {?} scrollStrategy
                 * @param {?} _parentMenu
                 * @param {?} _menuItemInstance
                 * @param {?} _dir
                 * @param {?=} _focusMonitor
                 */
                function MatMenuTrigger(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {
                    var _this = this;
                    this._overlay = _overlay;
                    this._element = _element;
                    this._viewContainerRef = _viewContainerRef;
                    this._parentMenu = _parentMenu;
                    this._menuItemInstance = _menuItemInstance;
                    this._dir = _dir;
                    this._focusMonitor = _focusMonitor;
                    this._overlayRef = null;
                    this._menuOpen = false;
                    this._closingActionsSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    this._hoverSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    this._menuCloseSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Handles touch start events on the trigger.
                     * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.
                     */
                    this._handleTouchStart = ( /**
                     * @return {?}
                     */function () { return _this._openedBy = 'touch'; });
                    // Tracking input type is necessary so it's possible to only auto-focus
                    // the first item of the list when the menu is opened via the keyboard
                    this._openedBy = null;
                    /**
                     * Whether focus should be restored when the menu is closed.
                     * Note that disabling this option can have accessibility implications
                     * and it's up to you to manage focus, if you decide to turn it off.
                     */
                    this.restoreFocus = true;
                    /**
                     * Event emitted when the associated menu is opened.
                     */
                    this.menuOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the associated menu is opened.
                     * @deprecated Switch to `menuOpened` instead
                     * \@breaking-change 8.0.0
                     */
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onMenuOpen = this.menuOpened;
                    /**
                     * Event emitted when the associated menu is closed.
                     */
                    this.menuClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the associated menu is closed.
                     * @deprecated Switch to `menuClosed` instead
                     * \@breaking-change 8.0.0
                     */
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onMenuClose = this.menuClosed;
                    _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);
                    if (_menuItemInstance) {
                        _menuItemInstance._triggersSubmenu = this.triggersSubmenu();
                    }
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", {
                    /**
                     * @deprecated
                     * \@breaking-change 8.0.0
                     * @return {?}
                     */
                    get: function () { return this.menu; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this.menu = v;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMenuTrigger.prototype, "menu", {
                    /**
                     * References the menu instance that the trigger is associated with.
                     * @return {?}
                     */
                    get: function () { return this._menu; },
                    /**
                     * @param {?} menu
                     * @return {?}
                     */
                    set: function (menu) {
                        var _this = this;
                        if (menu === this._menu) {
                            return;
                        }
                        this._menu = menu;
                        this._menuCloseSubscription.unsubscribe();
                        if (menu) {
                            this._menuCloseSubscription = menu.close.asObservable().subscribe(( /**
                             * @param {?} reason
                             * @return {?}
                             */function (/**
                             * @param {?} reason
                             * @return {?}
                             */ reason) {
                                _this._destroyMenu();
                                // If a click closed the menu, we should close the entire chain of nested menus.
                                if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {
                                    _this._parentMenu.closed.emit(reason);
                                }
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMenuTrigger.prototype.ngAfterContentInit = function () {
                    this._checkMenu();
                    this._handleHover();
                };
                /**
                 * @return {?}
                 */
                MatMenuTrigger.prototype.ngOnDestroy = function () {
                    if (this._overlayRef) {
                        this._overlayRef.dispose();
                        this._overlayRef = null;
                    }
                    this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);
                    this._menuCloseSubscription.unsubscribe();
                    this._closingActionsSubscription.unsubscribe();
                    this._hoverSubscription.unsubscribe();
                };
                Object.defineProperty(MatMenuTrigger.prototype, "menuOpen", {
                    /**
                     * Whether the menu is open.
                     * @return {?}
                     */
                    get: function () {
                        return this._menuOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMenuTrigger.prototype, "dir", {
                    /**
                     * The text direction of the containing app.
                     * @return {?}
                     */
                    get: function () {
                        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether the menu triggers a sub-menu or a top-level one.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.triggersSubmenu = function () {
                    return !!(this._menuItemInstance && this._parentMenu);
                };
                /**
                 * Toggles the menu between the open and closed states.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.toggleMenu = function () {
                    return this._menuOpen ? this.closeMenu() : this.openMenu();
                };
                /**
                 * Opens the menu.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.openMenu = function () {
                    var _this = this;
                    if (this._menuOpen) {
                        return;
                    }
                    this._checkMenu();
                    /** @type {?} */
                    var overlayRef = this._createOverlay();
                    /** @type {?} */
                    var overlayConfig = overlayRef.getConfig();
                    this._setPosition(( /** @type {?} */(overlayConfig.positionStrategy)));
                    overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :
                        this.menu.hasBackdrop;
                    overlayRef.attach(this._getPortal());
                    if (this.menu.lazyContent) {
                        this.menu.lazyContent.attach(this.menuData);
                    }
                    this._closingActionsSubscription = this._menuClosingActions().subscribe(( /**
                     * @return {?}
                     */function () { return _this.closeMenu(); }));
                    this._initMenu();
                    if (this.menu instanceof MatMenu) {
                        this.menu._startAnimation();
                    }
                };
                /**
                 * Closes the menu.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.closeMenu = function () {
                    this.menu.close.emit();
                };
                /**
                 * Focuses the menu trigger.
                 * @param {?=} origin Source of the menu trigger's focus.
                 * @param {?=} options
                 * @return {?}
                 */
                MatMenuTrigger.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    if (this._focusMonitor) {
                        this._focusMonitor.focusVia(this._element, origin, options);
                    }
                    else {
                        this._element.nativeElement.focus(options);
                    }
                };
                /**
                 * Closes the menu and does the necessary cleanup.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._destroyMenu = function () {
                    var _this = this;
                    if (!this._overlayRef || !this.menuOpen) {
                        return;
                    }
                    /** @type {?} */
                    var menu = this.menu;
                    this._closingActionsSubscription.unsubscribe();
                    this._overlayRef.detach();
                    if (menu instanceof MatMenu) {
                        menu._resetAnimation();
                        if (menu.lazyContent) {
                            // Wait for the exit animation to finish before detaching the content.
                            menu._animationDone
                                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event.toState === 'void'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1), 
                            // Interrupt if the content got re-attached.
                            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["takeUntil"])(menu.lazyContent._attached))
                                .subscribe({
                                next: ( /**
                                 * @return {?}
                                 */function () { return ( /** @type {?} */(menu.lazyContent)).detach(); }),
                                // No matter whether the content got re-attached, reset the menu.
                                complete: ( /**
                                 * @return {?}
                                 */function () { return _this._setIsMenuOpen(false); })
                            });
                        }
                        else {
                            this._setIsMenuOpen(false);
                        }
                    }
                    else {
                        this._setIsMenuOpen(false);
                        if (menu.lazyContent) {
                            menu.lazyContent.detach();
                        }
                    }
                    this._restoreFocus();
                };
                /**
                 * This method sets the menu state to open and focuses the first item if
                 * the menu was opened via the keyboard.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._initMenu = function () {
                    this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;
                    this.menu.direction = this.dir;
                    this._setMenuElevation();
                    this._setIsMenuOpen(true);
                    this.menu.focusFirstItem(this._openedBy || 'program');
                };
                /**
                 * Updates the menu elevation based on the amount of parent menus that it has.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._setMenuElevation = function () {
                    if (this.menu.setElevation) {
                        /** @type {?} */
                        var depth = 0;
                        /** @type {?} */
                        var parentMenu = this.menu.parentMenu;
                        while (parentMenu) {
                            depth++;
                            parentMenu = parentMenu.parentMenu;
                        }
                        this.menu.setElevation(depth);
                    }
                };
                /**
                 * Restores focus to the element that was focused before the menu was open.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._restoreFocus = function () {
                    // We should reset focus if the user is navigating using a keyboard or
                    // if we have a top-level trigger which might cause focus to be lost
                    // when clicking on the backdrop.
                    if (this.restoreFocus) {
                        if (!this._openedBy) {
                            // Note that the focus style will show up both for `program` and
                            // `keyboard` so we don't have to specify which one it is.
                            this.focus();
                        }
                        else if (!this.triggersSubmenu()) {
                            this.focus(this._openedBy);
                        }
                    }
                    this._openedBy = null;
                };
                // set state rather than toggle to support triggers sharing a menu
                /**
                 * @private
                 * @param {?} isOpen
                 * @return {?}
                 */
                MatMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {
                    this._menuOpen = isOpen;
                    this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
                    if (this.triggersSubmenu()) {
                        this._menuItemInstance._highlighted = isOpen;
                    }
                };
                /**
                 * This method checks that a valid instance of MatMenu has been passed into
                 * matMenuTriggerFor. If not, an exception is thrown.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._checkMenu = function () {
                    if (!this.menu) {
                        throwMatMenuMissingError();
                    }
                };
                /**
                 * This method creates the overlay from the provided menu's template and saves its
                 * OverlayRef so that it can be attached to the DOM when openMenu is called.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._createOverlay = function () {
                    if (!this._overlayRef) {
                        /** @type {?} */
                        var config = this._getOverlayConfig();
                        this._subscribeToPositions(( /** @type {?} */(config.positionStrategy)));
                        this._overlayRef = this._overlay.create(config);
                        // Consume the `keydownEvents` in order to prevent them from going to another overlay.
                        // Ideally we'd also have our keyboard event logic in here, however doing so will
                        // break anybody that may have implemented the `MatMenuPanel` themselves.
                        this._overlayRef.keydownEvents().subscribe();
                    }
                    return this._overlayRef;
                };
                /**
                 * This method builds the configuration object needed to create the overlay, the OverlayState.
                 * @private
                 * @return {?} OverlayConfig
                 */
                MatMenuTrigger.prototype._getOverlayConfig = function () {
                    return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["OverlayConfig"]({
                        positionStrategy: this._overlay.position()
                            .flexibleConnectedTo(this._element)
                            .withLockedPosition()
                            .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),
                        backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',
                        scrollStrategy: this._scrollStrategy(),
                        direction: this._dir
                    });
                };
                /**
                 * Listens to changes in the position of the overlay and sets the correct classes
                 * on the menu based on the new position. This ensures the animation origin is always
                 * correct, even if a fallback position is used for the overlay.
                 * @private
                 * @param {?} position
                 * @return {?}
                 */
                MatMenuTrigger.prototype._subscribeToPositions = function (position) {
                    var _this = this;
                    if (this.menu.setPositionClasses) {
                        position.positionChanges.subscribe(( /**
                         * @param {?} change
                         * @return {?}
                         */function (/**
                         * @param {?} change
                         * @return {?}
                         */ change) {
                            /** @type {?} */
                            var posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
                            /** @type {?} */
                            var posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
                            ( /** @type {?} */(_this.menu.setPositionClasses))(posX, posY);
                        }));
                    }
                };
                /**
                 * Sets the appropriate positions on a position strategy
                 * so the overlay connects with the trigger correctly.
                 * @private
                 * @param {?} positionStrategy Strategy whose position to update.
                 * @return {?}
                 */
                MatMenuTrigger.prototype._setPosition = function (positionStrategy) {
                    var _a = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], originX = _a[0], originFallbackX = _a[1];
                    var _b = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], overlayFallbackY = _b[1];
                    var _c = [overlayY, overlayFallbackY], originY = _c[0], originFallbackY = _c[1];
                    var _d = [originX, originFallbackX], overlayX = _d[0], overlayFallbackX = _d[1];
                    /** @type {?} */
                    var offsetY = 0;
                    if (this.triggersSubmenu()) {
                        // When the menu is a sub-menu, it should always align itself
                        // to the edges of the trigger, instead of overlapping it.
                        overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';
                        originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';
                        offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;
                    }
                    else if (!this.menu.overlapTrigger) {
                        originY = overlayY === 'top' ? 'bottom' : 'top';
                        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
                    }
                    positionStrategy.withPositions([
                        { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
                        { originX: originFallbackX, originY: originY, overlayX: overlayFallbackX, overlayY: overlayY, offsetY: offsetY },
                        {
                            originX: originX,
                            originY: originFallbackY,
                            overlayX: overlayX,
                            overlayY: overlayFallbackY,
                            offsetY: -offsetY
                        },
                        {
                            originX: originFallbackX,
                            originY: originFallbackY,
                            overlayX: overlayFallbackX,
                            overlayY: overlayFallbackY,
                            offsetY: -offsetY
                        }
                    ]);
                };
                /**
                 * Returns a stream that emits whenever an action that should close the menu occurs.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._menuClosingActions = function () {
                    var _this = this;
                    /** @type {?} */
                    var backdrop = ( /** @type {?} */(this._overlayRef)).backdropClick();
                    /** @type {?} */
                    var detachments = ( /** @type {?} */(this._overlayRef)).detachments();
                    /** @type {?} */
                    var parentClose = this._parentMenu ? this._parentMenu.closed : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])();
                    /** @type {?} */
                    var hover = this._parentMenu ? this._parentMenu._hovered().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                     * @param {?} active
                     * @return {?}
                     */function (/**
                     * @param {?} active
                     * @return {?}
                     */ active) { return active !== _this._menuItemInstance; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                     * @return {?}
                     */function () { return _this._menuOpen; }))) : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])();
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(backdrop, parentClose, hover, detachments);
                };
                /**
                 * Handles mouse presses on the trigger.
                 * @param {?} event
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleMousedown = function (event) {
                    if (!Object(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["isFakeMousedownFromScreenReader"])(event)) {
                        // Since right or middle button clicks won't trigger the `click` event,
                        // we shouldn't consider the menu as opened by mouse in those cases.
                        this._openedBy = event.button === 0 ? 'mouse' : null;
                        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
                        // we should prevent focus from moving onto it via click to avoid the
                        // highlight from lingering on the menu item.
                        if (this.triggersSubmenu()) {
                            event.preventDefault();
                        }
                    }
                };
                /**
                 * Handles key presses on the trigger.
                 * @param {?} event
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    if (this.triggersSubmenu() && ((keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["RIGHT_ARROW"] && this.dir === 'ltr') ||
                        (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["LEFT_ARROW"] && this.dir === 'rtl'))) {
                        this.openMenu();
                    }
                };
                /**
                 * Handles click events on the trigger.
                 * @param {?} event
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleClick = function (event) {
                    if (this.triggersSubmenu()) {
                        // Stop event propagation to avoid closing the parent menu.
                        event.stopPropagation();
                        this.openMenu();
                    }
                    else {
                        this.toggleMenu();
                    }
                };
                /**
                 * Handles the cases where the user hovers over the trigger.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleHover = function () {
                    var _this = this;
                    // Subscribe to changes in the hovered item in order to toggle the panel.
                    if (!this.triggersSubmenu()) {
                        return;
                    }
                    this._hoverSubscription = this._parentMenu._hovered()
                        // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
                        // with different data and triggers), we have to delay it by a tick to ensure that
                        // it won't be closed immediately after it is opened.
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                 * @param {?} active
                 * @return {?}
                 */function (/**
                 * @param {?} active
                 * @return {?}
                 */ active) { return active === _this._menuItemInstance && !active.disabled; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["delay"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["asapScheduler"]))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._openedBy = 'mouse';
                        // If the same menu is used between multiple triggers, it might still be animating
                        // while the new trigger tries to re-open it. Wait for the animation to finish
                        // before doing so. Also interrupt if the user moves to another item.
                        if (_this.menu instanceof MatMenu && _this.menu._isAnimating) {
                            // We need the `delay(0)` here in order to avoid
                            // 'changed after checked' errors in some cases. See #12194.
                            _this.menu._animationDone
                                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["delay"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["asapScheduler"]), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["takeUntil"])(_this._parentMenu._hovered()))
                                .subscribe(( /**
                         * @return {?}
                         */function () { return _this.openMenu(); }));
                        }
                        else {
                            _this.openMenu();
                        }
                    }));
                };
                /**
                 * Gets the portal that should be attached to the overlay.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._getPortal = function () {
                    // Note that we can avoid this check by keeping the portal on the menu panel.
                    // While it would be cleaner, we'd have to introduce another required method on
                    // `MatMenuPanel`, making it harder to consume.
                    if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["TemplatePortal"](this.menu.templateRef, this._viewContainerRef);
                    }
                    return this._portal;
                };
                return MatMenuTrigger;
            }());
            MatMenuTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: "[mat-menu-trigger-for], [matMenuTriggerFor]",
                            host: {
                                'class': 'mat-menu-trigger',
                                'aria-haspopup': 'true',
                                '[attr.aria-expanded]': 'menuOpen || null',
                                '(mousedown)': '_handleMousedown($event)',
                                '(keydown)': '_handleKeydown($event)',
                                '(click)': '_handleClick($event)',
                            },
                            exportAs: 'matMenuTrigger'
                        },] },
            ];
            /** @nocollapse */
            MatMenuTrigger.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_SCROLL_STRATEGY,] }] },
                { type: MatMenu, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: MatMenuItem, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Self"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_10__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["FocusMonitor"] }
            ]; };
            MatMenuTrigger.propDecorators = {
                _deprecatedMatMenuTriggerFor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['mat-menu-trigger-for',] }],
                menu: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matMenuTriggerFor',] }],
                menuData: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matMenuTriggerData',] }],
                restoreFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matMenuTriggerRestoreFocus',] }],
                menuOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                onMenuOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                menuClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                onMenuClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used by both the current `MatMenuModule` and the MDC `MatMenuModule`
             * to declare the menu-related directives.
             */
            // tslint:disable-next-line:class-name
            var _MatMenuDirectivesModule = /** @class */ (function () {
                function _MatMenuDirectivesModule() {
                }
                return _MatMenuDirectivesModule;
            }());
            _MatMenuDirectivesModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            exports: [MatMenuTrigger, MatMenuContent, _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            declarations: [MatMenuTrigger, MatMenuContent],
                            providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]
                        },] },
            ];
            var MatMenuModule = /** @class */ (function () {
                function MatMenuModule() {
                }
                return MatMenuModule;
            }());
            MatMenuModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatRippleModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["OverlayModule"],
                                _MatMenuDirectivesModule,
                            ],
                            exports: [_MatMenu, MatMenuItem, _MatMenuDirectivesModule],
                            declarations: [_MatMenu, MatMenuItem],
                            providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=menu.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/paginator.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/paginator.js ***!
          \*************************************************************/
        /*! exports provided: MatPaginatorModule, PageEvent, MatPaginator, MAT_PAGINATOR_INTL_PROVIDER_FACTORY, MatPaginatorIntl, MAT_PAGINATOR_INTL_PROVIDER */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatPaginatorModule", function () { return MatPaginatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PageEvent", function () { return PageEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatPaginator", function () { return MatPaginator; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_PAGINATOR_INTL_PROVIDER_FACTORY", function () { return MAT_PAGINATOR_INTL_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatPaginatorIntl", function () { return MatPaginatorIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_PAGINATOR_INTL_PROVIDER", function () { return MAT_PAGINATOR_INTL_PROVIDER; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_material_select__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/select */ "./node_modules/@angular/material/esm2015/select.js");
            /* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm2015/tooltip.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * To modify the labels and text displayed, create a new instance of MatPaginatorIntl and
             * include it in a custom provider
             */
            var MatPaginatorIntl = /** @class */ (function () {
                function MatPaginatorIntl() {
                    /**
                     * Stream to emit from when labels are changed. Use this to notify components when the labels have
                     * changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * A label for the page size selector.
                     */
                    this.itemsPerPageLabel = 'Items per page:';
                    /**
                     * A label for the button that increments the current page.
                     */
                    this.nextPageLabel = 'Next page';
                    /**
                     * A label for the button that decrements the current page.
                     */
                    this.previousPageLabel = 'Previous page';
                    /**
                     * A label for the button that moves to the first page.
                     */
                    this.firstPageLabel = 'First page';
                    /**
                     * A label for the button that moves to the last page.
                     */
                    this.lastPageLabel = 'Last page';
                    /**
                     * A label for the range of items within the current page and the length of the whole list.
                     */
                    this.getRangeLabel = ( /**
                     * @param {?} page
                     * @param {?} pageSize
                     * @param {?} length
                     * @return {?}
                     */function (page, pageSize, length) {
                        if (length == 0 || pageSize == 0) {
                            return "0 of " + length;
                        }
                        length = Math.max(length, 0);
                        /** @type {?} */
                        var startIndex = page * pageSize;
                        // If the start index exceeds the list length, do not try and fix the end index to the end.
                        /** @type {?} */
                        var endIndex = startIndex < length ?
                            Math.min(startIndex + pageSize, length) :
                            startIndex + pageSize;
                        return startIndex + 1 + " \u2013 " + endIndex + " of " + length;
                    });
                }
                return MatPaginatorIntl;
            }());
            MatPaginatorIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatPaginatorIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatPaginatorIntl_Factory() { return new MatPaginatorIntl(); }, token: MatPaginatorIntl, providedIn: "root" });
            /**
             * \@docs-private
             * @param {?} parentIntl
             * @return {?}
             */
            function MAT_PAGINATOR_INTL_PROVIDER_FACTORY(parentIntl) {
                return parentIntl || new MatPaginatorIntl();
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_PAGINATOR_INTL_PROVIDER = {
                // If there is already an MatPaginatorIntl available, use that. Otherwise, provide a new one.
                provide: MatPaginatorIntl,
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"](), MatPaginatorIntl]],
                useFactory: MAT_PAGINATOR_INTL_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The default page size if there is no page size and there are no provided page size options.
             * @type {?}
             */
            var DEFAULT_PAGE_SIZE = 50;
            /**
             * Change event object that is emitted when the user selects a
             * different page size or navigates to another page.
             */
            var PageEvent = /** @class */ (function () {
                function PageEvent() {
                }
                return PageEvent;
            }());
            // Boilerplate for applying mixins to MatPaginator.
            /**
             * \@docs-private
             */
            var MatPaginatorBase = /** @class */ (function () {
                function MatPaginatorBase() {
                }
                return MatPaginatorBase;
            }());
            /** @type {?} */
            var _MatPaginatorBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinInitialized"])(MatPaginatorBase));
            /**
             * Component to provide navigation between paged information. Displays the size of the current
             * page, user-selectable options to change that size, what items are being shown, and
             * navigational button to go to the previous or next page.
             */
            var MatPaginator = /** @class */ (function (_super) {
                __extends(MatPaginator, _super);
                /**
                 * @param {?} _intl
                 * @param {?} _changeDetectorRef
                 */
                function MatPaginator(_intl, _changeDetectorRef) {
                    var _this = _super.call(this) || this;
                    _this._intl = _intl;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._pageIndex = 0;
                    _this._length = 0;
                    _this._pageSizeOptions = [];
                    _this._hidePageSize = false;
                    _this._showFirstLastButtons = false;
                    /**
                     * Event emitted when the paginator changes the page size or page index.
                     */
                    _this.page = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    _this._intlChanges = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () { return _this._changeDetectorRef.markForCheck(); }));
                    return _this;
                }
                Object.defineProperty(MatPaginator.prototype, "pageIndex", {
                    /**
                     * The zero-based page index of the displayed list of items. Defaulted to 0.
                     * @return {?}
                     */
                    get: function () { return this._pageIndex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._pageIndex = Math.max(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value), 0);
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatPaginator.prototype, "length", {
                    /**
                     * The length of the total number of items that are being paginated. Defaulted to 0.
                     * @return {?}
                     */
                    get: function () { return this._length; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._length = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value);
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatPaginator.prototype, "pageSize", {
                    /**
                     * Number of items to display on a page. By default set to 50.
                     * @return {?}
                     */
                    get: function () { return this._pageSize; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._pageSize = Math.max(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value), 0);
                        this._updateDisplayedPageSizeOptions();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatPaginator.prototype, "pageSizeOptions", {
                    /**
                     * The set of provided page size options to display to the user.
                     * @return {?}
                     */
                    get: function () { return this._pageSizeOptions; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._pageSizeOptions = (value || []).map(( /**
                         * @param {?} p
                         * @return {?}
                         */function (/**
                         * @param {?} p
                         * @return {?}
                         */ p) { return Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(p); }));
                        this._updateDisplayedPageSizeOptions();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatPaginator.prototype, "hidePageSize", {
                    /**
                     * Whether to hide the page size selection UI from the user.
                     * @return {?}
                     */
                    get: function () { return this._hidePageSize; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._hidePageSize = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatPaginator.prototype, "showFirstLastButtons", {
                    /**
                     * Whether to show the first/last buttons UI to the user.
                     * @return {?}
                     */
                    get: function () { return this._showFirstLastButtons; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._showFirstLastButtons = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatPaginator.prototype.ngOnInit = function () {
                    this._initialized = true;
                    this._updateDisplayedPageSizeOptions();
                    this._markInitialized();
                };
                /**
                 * @return {?}
                 */
                MatPaginator.prototype.ngOnDestroy = function () {
                    this._intlChanges.unsubscribe();
                };
                /**
                 * Advances to the next page if it exists.
                 * @return {?}
                 */
                MatPaginator.prototype.nextPage = function () {
                    if (!this.hasNextPage()) {
                        return;
                    }
                    /** @type {?} */
                    var previousPageIndex = this.pageIndex;
                    this.pageIndex++;
                    this._emitPageEvent(previousPageIndex);
                };
                /**
                 * Move back to the previous page if it exists.
                 * @return {?}
                 */
                MatPaginator.prototype.previousPage = function () {
                    if (!this.hasPreviousPage()) {
                        return;
                    }
                    /** @type {?} */
                    var previousPageIndex = this.pageIndex;
                    this.pageIndex--;
                    this._emitPageEvent(previousPageIndex);
                };
                /**
                 * Move to the first page if not already there.
                 * @return {?}
                 */
                MatPaginator.prototype.firstPage = function () {
                    // hasPreviousPage being false implies at the start
                    if (!this.hasPreviousPage()) {
                        return;
                    }
                    /** @type {?} */
                    var previousPageIndex = this.pageIndex;
                    this.pageIndex = 0;
                    this._emitPageEvent(previousPageIndex);
                };
                /**
                 * Move to the last page if not already there.
                 * @return {?}
                 */
                MatPaginator.prototype.lastPage = function () {
                    // hasNextPage being false implies at the end
                    if (!this.hasNextPage()) {
                        return;
                    }
                    /** @type {?} */
                    var previousPageIndex = this.pageIndex;
                    this.pageIndex = this.getNumberOfPages() - 1;
                    this._emitPageEvent(previousPageIndex);
                };
                /**
                 * Whether there is a previous page.
                 * @return {?}
                 */
                MatPaginator.prototype.hasPreviousPage = function () {
                    return this.pageIndex >= 1 && this.pageSize != 0;
                };
                /**
                 * Whether there is a next page.
                 * @return {?}
                 */
                MatPaginator.prototype.hasNextPage = function () {
                    /** @type {?} */
                    var maxPageIndex = this.getNumberOfPages() - 1;
                    return this.pageIndex < maxPageIndex && this.pageSize != 0;
                };
                /**
                 * Calculate the number of pages
                 * @return {?}
                 */
                MatPaginator.prototype.getNumberOfPages = function () {
                    if (!this.pageSize) {
                        return 0;
                    }
                    return Math.ceil(this.length / this.pageSize);
                };
                /**
                 * Changes the page size so that the first item displayed on the page will still be
                 * displayed using the new page size.
                 *
                 * For example, if the page size is 10 and on the second page (items indexed 10-19) then
                 * switching so that the page size is 5 will set the third page as the current page so
                 * that the 10th item will still be displayed.
                 * @param {?} pageSize
                 * @return {?}
                 */
                MatPaginator.prototype._changePageSize = function (pageSize) {
                    // Current page needs to be updated to reflect the new page size. Navigate to the page
                    // containing the previous page's first item.
                    /** @type {?} */
                    var startIndex = this.pageIndex * this.pageSize;
                    /** @type {?} */
                    var previousPageIndex = this.pageIndex;
                    this.pageIndex = Math.floor(startIndex / pageSize) || 0;
                    this.pageSize = pageSize;
                    this._emitPageEvent(previousPageIndex);
                };
                /**
                 * Checks whether the buttons for going forwards should be disabled.
                 * @return {?}
                 */
                MatPaginator.prototype._nextButtonsDisabled = function () {
                    return this.disabled || !this.hasNextPage();
                };
                /**
                 * Checks whether the buttons for going backwards should be disabled.
                 * @return {?}
                 */
                MatPaginator.prototype._previousButtonsDisabled = function () {
                    return this.disabled || !this.hasPreviousPage();
                };
                /**
                 * Updates the list of page size options to display to the user. Includes making sure that
                 * the page size is an option and that the list is sorted.
                 * @private
                 * @return {?}
                 */
                MatPaginator.prototype._updateDisplayedPageSizeOptions = function () {
                    if (!this._initialized) {
                        return;
                    }
                    // If no page size is provided, use the first page size option or the default page size.
                    if (!this.pageSize) {
                        this._pageSize = this.pageSizeOptions.length != 0 ?
                            this.pageSizeOptions[0] :
                            DEFAULT_PAGE_SIZE;
                    }
                    this._displayedPageSizeOptions = this.pageSizeOptions.slice();
                    if (this._displayedPageSizeOptions.indexOf(this.pageSize) === -1) {
                        this._displayedPageSizeOptions.push(this.pageSize);
                    }
                    // Sort the numbers using a number-specific sort function.
                    this._displayedPageSizeOptions.sort(( /**
                     * @param {?} a
                     * @param {?} b
                     * @return {?}
                     */function (a, b) { return a - b; }));
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Emits an event notifying that a change of the paginator's properties has been triggered.
                 * @private
                 * @param {?} previousPageIndex
                 * @return {?}
                 */
                MatPaginator.prototype._emitPageEvent = function (previousPageIndex) {
                    this.page.emit({
                        previousPageIndex: previousPageIndex,
                        pageIndex: this.pageIndex,
                        pageSize: this.pageSize,
                        length: this.length
                    });
                };
                return MatPaginator;
            }(_MatPaginatorBase));
            MatPaginator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-paginator',
                            exportAs: 'matPaginator',
                            template: "<div class=\"mat-paginator-outer-container\"><div class=\"mat-paginator-container\"><div class=\"mat-paginator-page-size\" *ngIf=\"!hidePageSize\"><div class=\"mat-paginator-page-size-label\">{{_intl.itemsPerPageLabel}}</div><mat-form-field *ngIf=\"_displayedPageSizeOptions.length > 1\" [color]=\"color\" class=\"mat-paginator-page-size-select\"><mat-select [value]=\"pageSize\" [disabled]=\"disabled\" [aria-label]=\"_intl.itemsPerPageLabel\" (selectionChange)=\"_changePageSize($event.value)\"><mat-option *ngFor=\"let pageSizeOption of _displayedPageSizeOptions\" [value]=\"pageSizeOption\">{{pageSizeOption}}</mat-option></mat-select></mat-form-field><div *ngIf=\"_displayedPageSizeOptions.length <= 1\">{{pageSize}}</div></div><div class=\"mat-paginator-range-actions\"><div class=\"mat-paginator-range-label\">{{_intl.getRangeLabel(pageIndex, pageSize, length)}}</div><button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-first\" (click)=\"firstPage()\" [attr.aria-label]=\"_intl.firstPageLabel\" [matTooltip]=\"_intl.firstPageLabel\" [matTooltipDisabled]=\"_previousButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_previousButtonsDisabled()\" *ngIf=\"showFirstLastButtons\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z\"/></svg></button> <button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-previous\" (click)=\"previousPage()\" [attr.aria-label]=\"_intl.previousPageLabel\" [matTooltip]=\"_intl.previousPageLabel\" [matTooltipDisabled]=\"_previousButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_previousButtonsDisabled()\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/></svg></button> <button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-next\" (click)=\"nextPage()\" [attr.aria-label]=\"_intl.nextPageLabel\" [matTooltip]=\"_intl.nextPageLabel\" [matTooltipDisabled]=\"_nextButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_nextButtonsDisabled()\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/></svg></button> <button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-last\" (click)=\"lastPage()\" [attr.aria-label]=\"_intl.lastPageLabel\" [matTooltip]=\"_intl.lastPageLabel\" [matTooltipDisabled]=\"_nextButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_nextButtonsDisabled()\" *ngIf=\"showFirstLastButtons\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z\"/></svg></button></div></div></div>",
                            styles: [".mat-paginator{display:block}.mat-paginator-outer-container{display:flex}.mat-paginator-container{display:flex;align-items:center;justify-content:flex-end;min-height:56px;padding:0 8px;flex-wrap:wrap-reverse;width:100%}.mat-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-paginator-page-size{margin-right:0;margin-left:8px}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:6px 4px 0 4px;width:56px}.mat-paginator-page-size-select.mat-form-field-appearance-outline{width:64px}.mat-paginator-page-size-select.mat-form-field-appearance-fill{width:64px}.mat-paginator-range-label{margin:0 32px 0 24px}.mat-paginator-range-actions{display:flex;align-items:center}.mat-paginator-icon{width:28px;fill:currentColor}[dir=rtl] .mat-paginator-icon{transform:rotate(180deg)}"],
                            inputs: ['disabled'],
                            host: {
                                'class': 'mat-paginator',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatPaginator.ctorParameters = function () { return [
                { type: MatPaginatorIntl },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatPaginator.propDecorators = {
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                pageIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                length: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                pageSize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                pageSizeOptions: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                hidePageSize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                showFirstLastButtons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                page: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatPaginatorModule = /** @class */ (function () {
                function MatPaginatorModule() {
                }
                return MatPaginatorModule;
            }());
            MatPaginatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_4__["CommonModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_5__["MatButtonModule"],
                                _angular_material_select__WEBPACK_IMPORTED_MODULE_6__["MatSelectModule"],
                                _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_7__["MatTooltipModule"],
                            ],
                            exports: [MatPaginator],
                            declarations: [MatPaginator],
                            providers: [MAT_PAGINATOR_INTL_PROVIDER],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=paginator.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/progress-bar.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/progress-bar.js ***!
          \****************************************************************/
        /*! exports provided: MatProgressBarModule, MAT_PROGRESS_BAR_LOCATION_FACTORY, MAT_PROGRESS_BAR_LOCATION, MatProgressBar */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatProgressBarModule", function () { return MatProgressBarModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_BAR_LOCATION_FACTORY", function () { return MAT_PROGRESS_BAR_LOCATION_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_BAR_LOCATION", function () { return MAT_PROGRESS_BAR_LOCATION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatProgressBar", function () { return MatProgressBar; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatProgressBar.
            /**
             * \@docs-private
             */
            var MatProgressBarBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatProgressBarBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatProgressBarBase;
            }());
            /** @type {?} */
            var _MatProgressBarMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(MatProgressBarBase, 'primary');
            /**
             * Injection token used to provide the current location to `MatProgressBar`.
             * Used to handle server-side rendering and to stub out during unit tests.
             * \@docs-private
             * @type {?}
             */
            var MAT_PROGRESS_BAR_LOCATION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-progress-bar-location', { providedIn: 'root', factory: MAT_PROGRESS_BAR_LOCATION_FACTORY });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_PROGRESS_BAR_LOCATION_FACTORY() {
                /** @type {?} */
                var _document = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["inject"])(_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"]);
                /** @type {?} */
                var _location = _document ? _document.location : null;
                return {
                    // Note that this needs to be a function, rather than a property, because Angular
                    // will only resolve it once, but we want the current path on each call.
                    getPathname: ( /**
                     * @return {?}
                     */function () { return _location ? (_location.pathname + _location.search) : ''; })
                };
            }
            /**
             * Counter used to generate unique IDs for progress bars.
             * @type {?}
             */
            var progressbarId = 0;
            /**
             * `<mat-progress-bar>` component.
             */
            var MatProgressBar = /** @class */ (function (_super) {
                __extends(MatProgressBar, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?=} _animationMode
                 * @param {?=} location
                 */
                function MatProgressBar(_elementRef, _ngZone, _animationMode, 
                /**
                 * @deprecated `location` parameter to be made required.
                 * @breaking-change 8.0.0
                 */
                location) {
                    var _this = _super.call(this, _elementRef) || this;
                    _this._elementRef = _elementRef;
                    _this._ngZone = _ngZone;
                    _this._animationMode = _animationMode;
                    /**
                     * Flag that indicates whether NoopAnimations mode is set to true.
                     */
                    _this._isNoopAnimation = false;
                    _this._value = 0;
                    _this._bufferValue = 0;
                    /**
                     * Event emitted when animation of the primary progress bar completes. This event will not
                     * be emitted when animations are disabled, nor will it be emitted for modes with continuous
                     * animations (indeterminate and query).
                     */
                    _this.animationEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Reference to animation end subscription to be unsubscribed on destroy.
                     */
                    _this._animationEndSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * Mode of the progress bar.
                     *
                     * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
                     * 'determinate'.
                     * Mirrored to mode attribute.
                     */
                    _this.mode = 'determinate';
                    /**
                     * ID of the progress bar.
                     */
                    _this.progressbarId = "mat-progress-bar-" + progressbarId++;
                    // We need to prefix the SVG reference with the current path, otherwise they won't work
                    // in Safari if the page has a `<base>` tag. Note that we need quotes inside the `url()`,
                    // because named route URLs can contain parentheses (see #12338). Also we don't use since
                    // we can't tell the difference between whether
                    // the consumer is using the hash location strategy or not, because `Location` normalizes
                    // both `/#/foo/bar` and `/foo/bar` to the same thing.
                    /** @type {?} */
                    var path = location ? location.getPathname().split('#')[0] : '';
                    _this._rectangleFillValue = "url('" + path + "#" + _this.progressbarId + "')";
                    _this._isNoopAnimation = _animationMode === 'NoopAnimations';
                    return _this;
                }
                Object.defineProperty(MatProgressBar.prototype, "value", {
                    /**
                     * Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._value = clamp(v || 0);
                        // When noop animation is set to true, trigger animationEnd directly.
                        if (this._isNoopAnimation) {
                            this._emitAnimationEnd();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressBar.prototype, "bufferValue", {
                    /**
                     * Buffer value of the progress bar. Defaults to zero.
                     * @return {?}
                     */
                    get: function () { return this._bufferValue; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) { this._bufferValue = clamp(v || 0); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets the current transform value for the progress bar's primary indicator.
                 * @return {?}
                 */
                MatProgressBar.prototype._primaryTransform = function () {
                    /** @type {?} */
                    var scale = this.value / 100;
                    return { transform: "scaleX(" + scale + ")" };
                };
                /**
                 * Gets the current transform value for the progress bar's buffer indicator. Only used if the
                 * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
                 * @return {?}
                 */
                MatProgressBar.prototype._bufferTransform = function () {
                    if (this.mode === 'buffer') {
                        /** @type {?} */
                        var scale = this.bufferValue / 100;
                        return { transform: "scaleX(" + scale + ")" };
                    }
                    return undefined;
                };
                /**
                 * @return {?}
                 */
                MatProgressBar.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    if (!this._isNoopAnimation) {
                        // Run outside angular so change detection didn't get triggered on every transition end
                        // instead only on the animation that we care about (primary value bar's transitionend)
                        this._ngZone.runOutsideAngular((( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var element = _this._primaryValueBar.nativeElement;
                            _this._animationEndSubscription =
                                (( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["fromEvent"])(element, 'transitionend'))))
                                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["filter"])((( /**
                             * @param {?} e
                             * @return {?}
                             */function (e) { return e.target === element; }))))
                                    .subscribe(( /**
                             * @return {?}
                             */function () { return _this._ngZone.run(( /**
                                 * @return {?}
                                 */function () { return _this._emitAnimationEnd(); })); }));
                        })));
                    }
                };
                /**
                 * @return {?}
                 */
                MatProgressBar.prototype.ngOnDestroy = function () {
                    this._animationEndSubscription.unsubscribe();
                };
                /**
                 * Emit an animationEnd event if in determinate or buffer mode.
                 * @private
                 * @return {?}
                 */
                MatProgressBar.prototype._emitAnimationEnd = function () {
                    if (this.mode === 'determinate' || this.mode === 'buffer') {
                        this.animationEnd.next({ value: this.value });
                    }
                };
                return MatProgressBar;
            }(_MatProgressBarMixinBase));
            MatProgressBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-progress-bar',
                            exportAs: 'matProgressBar',
                            host: {
                                'role': 'progressbar',
                                'aria-valuemin': '0',
                                'aria-valuemax': '100',
                                '[attr.aria-valuenow]': '(mode === "indeterminate" || mode === "query") ? null : value',
                                '[attr.mode]': 'mode',
                                'class': 'mat-progress-bar',
                                '[class._mat-animation-noopable]': '_isNoopAnimation',
                            },
                            inputs: ['color'],
                            template: "<svg width=\"100%\" height=\"4\" focusable=\"false\" class=\"mat-progress-bar-background mat-progress-bar-element\"><defs><pattern [id]=\"progressbarId\" x=\"4\" y=\"0\" width=\"8\" height=\"4\" patternUnits=\"userSpaceOnUse\"><circle cx=\"2\" cy=\"2\" r=\"2\"/></pattern></defs><rect [attr.fill]=\"_rectangleFillValue\" width=\"100%\" height=\"100%\"/></svg><div class=\"mat-progress-bar-buffer mat-progress-bar-element\" [ngStyle]=\"_bufferTransform()\"></div><div class=\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\" [ngStyle]=\"_primaryTransform()\" #primaryValueBar></div><div class=\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"></div>",
                            styles: [".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatProgressBar.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_3__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_PROGRESS_BAR_LOCATION,] }] }
            ]; };
            MatProgressBar.propDecorators = {
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                bufferValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _primaryValueBar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['primaryValueBar', { static: false },] }],
                animationEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                mode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Clamps a value to be between two numbers, by default 0 and 100.
             * @param {?} v
             * @param {?=} min
             * @param {?=} max
             * @return {?}
             */
            function clamp(v, min, max) {
                if (min === void 0) { min = 0; }
                if (max === void 0) { max = 100; }
                return Math.max(min, Math.min(max, v));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatProgressBarModule = /** @class */ (function () {
                function MatProgressBarModule() {
                }
                return MatProgressBarModule;
            }());
            MatProgressBarModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"]],
                            exports: [MatProgressBar, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"]],
                            declarations: [MatProgressBar],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=progress-bar.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/progress-spinner.js": 
        /*!********************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/progress-spinner.js ***!
          \********************************************************************/
        /*! exports provided: MatProgressSpinner, MatSpinner, MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS, MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY, MatProgressSpinnerModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatProgressSpinner", function () { return MatProgressSpinner; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSpinner", function () { return MatSpinner; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS", function () { return MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY", function () { return MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatProgressSpinnerModule", function () { return MatProgressSpinnerModule; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Base reference size of the spinner.
             * \@docs-private
             * @type {?}
             */
            var BASE_SIZE = 100;
            /**
             * Base reference stroke width of the spinner.
             * \@docs-private
             * @type {?}
             */
            var BASE_STROKE_WIDTH = 10;
            // Boilerplate for applying mixins to MatProgressSpinner.
            /**
             * \@docs-private
             */
            var MatProgressSpinnerBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatProgressSpinnerBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatProgressSpinnerBase;
            }());
            /** @type {?} */
            var _MatProgressSpinnerMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(MatProgressSpinnerBase, 'primary');
            /**
             * Injection token to be used to override the default options for `mat-progress-spinner`.
             * @type {?}
             */
            var MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-progress-spinner-default-options', {
                providedIn: 'root',
                factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {
                return { diameter: BASE_SIZE };
            }
            // .0001 percentage difference is necessary in order to avoid unwanted animation frames
            // for example because the animation duration is 4 seconds, .1% accounts to 4ms
            // which are enough to see the flicker described in
            // https://github.com/angular/components/issues/8984
            /** @type {?} */
            var INDETERMINATE_ANIMATION_TEMPLATE = "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n";
            /**
             * `<mat-progress-spinner>` component.
             */
            var MatProgressSpinner = /** @class */ (function (_super) {
                __extends(MatProgressSpinner, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} platform
                 * @param {?} _document
                 * @param {?} animationMode
                 * @param {?=} defaults
                 */
                function MatProgressSpinner(_elementRef, platform, _document, animationMode, defaults) {
                    var _this = _super.call(this, _elementRef) || this;
                    _this._elementRef = _elementRef;
                    _this._document = _document;
                    _this._diameter = BASE_SIZE;
                    _this._value = 0;
                    _this._fallbackAnimation = false;
                    /**
                     * Mode of the progress circle
                     */
                    _this.mode = 'determinate';
                    /** @type {?} */
                    var trackedDiameters = MatProgressSpinner._diameters;
                    // The base size is already inserted via the component's structural styles. We still
                    // need to track it so we don't end up adding the same styles again.
                    if (!trackedDiameters.has(_document.head)) {
                        trackedDiameters.set(_document.head, new Set([BASE_SIZE]));
                    }
                    _this._fallbackAnimation = platform.EDGE || platform.TRIDENT;
                    _this._noopAnimations = animationMode === 'NoopAnimations' &&
                        (!!defaults && !defaults._forceAnimations);
                    if (defaults) {
                        if (defaults.diameter) {
                            _this.diameter = defaults.diameter;
                        }
                        if (defaults.strokeWidth) {
                            _this.strokeWidth = defaults.strokeWidth;
                        }
                    }
                    return _this;
                }
                Object.defineProperty(MatProgressSpinner.prototype, "diameter", {
                    /**
                     * The diameter of the progress spinner (will set width and height of svg).
                     * @return {?}
                     */
                    get: function () { return this._diameter; },
                    /**
                     * @param {?} size
                     * @return {?}
                     */
                    set: function (size) {
                        this._diameter = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceNumberProperty"])(size);
                        // If this is set before `ngOnInit`, the style root may not have been resolved yet.
                        if (!this._fallbackAnimation && this._styleRoot) {
                            this._attachStyleNode();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressSpinner.prototype, "strokeWidth", {
                    /**
                     * Stroke width of the progress spinner.
                     * @return {?}
                     */
                    get: function () {
                        return this._strokeWidth || this.diameter / 10;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._strokeWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceNumberProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressSpinner.prototype, "value", {
                    /**
                     * Value of the progress circle.
                     * @return {?}
                     */
                    get: function () {
                        return this.mode === 'determinate' ? this._value : 0;
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        this._value = Math.max(0, Math.min(100, Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceNumberProperty"])(newValue)));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatProgressSpinner.prototype.ngOnInit = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    // Note that we need to look up the root node in ngOnInit, rather than the constructor, because
                    // Angular seems to create the element outside the shadow root and then moves it inside, if the
                    // node is inside an `ngIf` and a ShadowDom-encapsulated component.
                    this._styleRoot = _getShadowRoot(element, this._document) || this._document.head;
                    this._attachStyleNode();
                    // On IE and Edge, we can't animate the `stroke-dashoffset`
                    // reliably so we fall back to a non-spec animation.
                    /** @type {?} */
                    var animationClass = "mat-progress-spinner-indeterminate" + (this._fallbackAnimation ? '-fallback' : '') + "-animation";
                    element.classList.add(animationClass);
                };
                Object.defineProperty(MatProgressSpinner.prototype, "_circleRadius", {
                    /**
                     * The radius of the spinner, adjusted for stroke width.
                     * @return {?}
                     */
                    get: function () {
                        return (this.diameter - BASE_STROKE_WIDTH) / 2;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressSpinner.prototype, "_viewBox", {
                    /**
                     * The view box of the spinner's svg element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var viewBox = this._circleRadius * 2 + this.strokeWidth;
                        return "0 0 " + viewBox + " " + viewBox;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressSpinner.prototype, "_strokeCircumference", {
                    /**
                     * The stroke circumference of the svg circle.
                     * @return {?}
                     */
                    get: function () {
                        return 2 * Math.PI * this._circleRadius;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressSpinner.prototype, "_strokeDashOffset", {
                    /**
                     * The dash offset of the svg circle.
                     * @return {?}
                     */
                    get: function () {
                        if (this.mode === 'determinate') {
                            return this._strokeCircumference * (100 - this._value) / 100;
                        }
                        // In fallback mode set the circle to 80% and rotate it with CSS.
                        if (this._fallbackAnimation && this.mode === 'indeterminate') {
                            return this._strokeCircumference * 0.2;
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatProgressSpinner.prototype, "_circleStrokeWidth", {
                    /**
                     * Stroke width of the circle in percent.
                     * @return {?}
                     */
                    get: function () {
                        return this.strokeWidth / this.diameter * 100;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Dynamically generates a style tag containing the correct animation for this diameter.
                 * @private
                 * @return {?}
                 */
                MatProgressSpinner.prototype._attachStyleNode = function () {
                    /** @type {?} */
                    var styleRoot = this._styleRoot;
                    /** @type {?} */
                    var currentDiameter = this._diameter;
                    /** @type {?} */
                    var diameters = MatProgressSpinner._diameters;
                    /** @type {?} */
                    var diametersForElement = diameters.get(styleRoot);
                    if (!diametersForElement || !diametersForElement.has(currentDiameter)) {
                        /** @type {?} */
                        var styleTag = this._document.createElement('style');
                        styleTag.setAttribute('mat-spinner-animation', currentDiameter + '');
                        styleTag.textContent = this._getAnimationText();
                        styleRoot.appendChild(styleTag);
                        if (!diametersForElement) {
                            diametersForElement = new Set();
                            diameters.set(styleRoot, diametersForElement);
                        }
                        diametersForElement.add(currentDiameter);
                    }
                };
                /**
                 * Generates animation styles adjusted for the spinner's diameter.
                 * @private
                 * @return {?}
                 */
                MatProgressSpinner.prototype._getAnimationText = function () {
                    return INDETERMINATE_ANIMATION_TEMPLATE
                        // Animation should begin at 5% and end at 80%
                        .replace(/START_VALUE/g, "" + 0.95 * this._strokeCircumference)
                        .replace(/END_VALUE/g, "" + 0.2 * this._strokeCircumference)
                        .replace(/DIAMETER/g, "" + this.diameter);
                };
                return MatProgressSpinner;
            }(_MatProgressSpinnerMixinBase));
            /**
             * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).
             * We need to keep track of which elements the diameters were attached to, because for
             * elements in the Shadow DOM the style tags are attached to the shadow root, rather
             * than the document head.
             */
            MatProgressSpinner._diameters = new WeakMap();
            MatProgressSpinner.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-progress-spinner',
                            exportAs: 'matProgressSpinner',
                            host: {
                                'role': 'progressbar',
                                'class': 'mat-progress-spinner',
                                '[class._mat-animation-noopable]': "_noopAnimations",
                                '[style.width.px]': 'diameter',
                                '[style.height.px]': 'diameter',
                                '[attr.aria-valuemin]': 'mode === "determinate" ? 0 : null',
                                '[attr.aria-valuemax]': 'mode === "determinate" ? 100 : null',
                                '[attr.aria-valuenow]': 'mode === "determinate" ? value : null',
                                '[attr.mode]': 'mode',
                            },
                            inputs: ['color'],
                            template: "<svg [style.width.px]=\"diameter\" [style.height.px]=\"diameter\" [attr.viewBox]=\"_viewBox\" preserveAspectRatio=\"xMidYMid meet\" focusable=\"false\" [ngSwitch]=\"mode === 'indeterminate'\"><circle *ngSwitchCase=\"true\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle><circle *ngSwitchCase=\"false\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle></svg>",
                            styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2s linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4s;animation-timing-function:cubic-bezier(.35,0,.25,1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10s cubic-bezier(.87,.03,.33,1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.60617px;transform:rotate(0)}12.5%{stroke-dashoffset:56.54867px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.60617px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.54867px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.60617px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.54867px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.60617px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.54867px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatProgressSpinner.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
            ]; };
            MatProgressSpinner.propDecorators = {
                diameter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                strokeWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                mode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            /**
             * `<mat-spinner>` component.
             *
             * This is a component definition to be used as a convenience reference to create an
             * indeterminate `<mat-progress-spinner>` instance.
             */
            var MatSpinner = /** @class */ (function (_super) {
                __extends(MatSpinner, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} platform
                 * @param {?} document
                 * @param {?} animationMode
                 * @param {?=} defaults
                 */
                function MatSpinner(elementRef, platform, document, animationMode, defaults) {
                    var _this = _super.call(this, elementRef, platform, document, animationMode, defaults) || this;
                    _this.mode = 'indeterminate';
                    return _this;
                }
                return MatSpinner;
            }(MatProgressSpinner));
            MatSpinner.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-spinner',
                            host: {
                                'role': 'progressbar',
                                'mode': 'indeterminate',
                                'class': 'mat-spinner mat-progress-spinner',
                                '[class._mat-animation-noopable]': "_noopAnimations",
                                '[style.width.px]': 'diameter',
                                '[style.height.px]': 'diameter',
                            },
                            inputs: ['color'],
                            template: "<svg [style.width.px]=\"diameter\" [style.height.px]=\"diameter\" [attr.viewBox]=\"_viewBox\" preserveAspectRatio=\"xMidYMid meet\" focusable=\"false\" [ngSwitch]=\"mode === 'indeterminate'\"><circle *ngSwitchCase=\"true\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle><circle *ngSwitchCase=\"false\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle></svg>",
                            styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2s linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4s;animation-timing-function:cubic-bezier(.35,0,.25,1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10s cubic-bezier(.87,.03,.33,1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.60617px;transform:rotate(0)}12.5%{stroke-dashoffset:56.54867px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.60617px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.54867px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.60617px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.54867px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.60617px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.54867px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatSpinner.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
            ]; };
            /**
             * Gets the shadow root of an element, if supported and the element is inside the Shadow DOM.
             * @param {?} element
             * @param {?} _document
             * @return {?}
             */
            function _getShadowRoot(element, _document) {
                // TODO(crisbeto): see whether we should move this into the CDK
                // feature detection utilities once #15616 gets merged in.
                if (typeof window !== 'undefined') {
                    /** @type {?} */
                    var head = _document.head;
                    // Check whether the browser supports Shadow DOM.
                    if (head && ((( /** @type {?} */(head))).createShadowRoot || head.attachShadow)) {
                        /** @type {?} */
                        var rootNode = element.getRootNode ? element.getRootNode() : null;
                        // We need to take the `ShadowRoot` off of `window`, because the built-in types are
                        // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.
                        if (rootNode instanceof (( /** @type {?} */(window))).ShadowRoot) {
                            return rootNode;
                        }
                    }
                }
                return null;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatProgressSpinnerModule = /** @class */ (function () {
                function MatProgressSpinnerModule() {
                }
                return MatProgressSpinnerModule;
            }());
            MatProgressSpinnerModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"]],
                            exports: [
                                MatProgressSpinner,
                                MatSpinner,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"]
                            ],
                            declarations: [
                                MatProgressSpinner,
                                MatSpinner
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=progress-spinner.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/radio.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/radio.js ***!
          \*********************************************************/
        /*! exports provided: MatRadioModule, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroup, MatRadioButton */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioModule", function () { return MatRadioModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS_FACTORY", function () { return MAT_RADIO_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS", function () { return MAT_RADIO_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR", function () { return MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioChange", function () { return MatRadioChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioGroup", function () { return MatRadioGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioButton", function () { return MatRadioButton; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_RADIO_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-radio-default-options', {
                providedIn: 'root',
                factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * @return {?}
             */
            function MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {
                return {
                    color: 'accent'
                };
            }
            // Increasing integer for generating unique ids for radio components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This
             * allows it to support [(ngModel)] and ngControl.
             * \@docs-private
             * @type {?}
             */
            var MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatRadioGroup; })),
                multi: true
            };
            /**
             * Change event object emitted by MatRadio and MatRadioGroup.
             */
            var MatRadioChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatRadioChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatRadioChange;
            }());
            /**
             * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.
             */
            var MatRadioGroup = /** @class */ (function () {
                /**
                 * @param {?} _changeDetector
                 */
                function MatRadioGroup(_changeDetector) {
                    this._changeDetector = _changeDetector;
                    /**
                     * Selected value for the radio group.
                     */
                    this._value = null;
                    /**
                     * The HTML name attribute applied to radio buttons in this group.
                     */
                    this._name = "mat-radio-group-" + nextUniqueId++;
                    /**
                     * The currently selected radio button. Should match value.
                     */
                    this._selected = null;
                    /**
                     * Whether the `value` has been set to its initial value.
                     */
                    this._isInitialized = false;
                    /**
                     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
                     */
                    this._labelPosition = 'after';
                    /**
                     * Whether the radio group is disabled.
                     */
                    this._disabled = false;
                    /**
                     * Whether the radio group is required.
                     */
                    this._required = false;
                    /**
                     * The method to be called in order to update ngModel
                     */
                    this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     * \@docs-private
                     */
                    this.onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Event emitted when the group value changes.
                     * Change events are only emitted when the value changes due to user interaction with
                     * a radio button (the same behavior as `<input type-"radio">`).
                     */
                    this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                }
                Object.defineProperty(MatRadioGroup.prototype, "name", {
                    /**
                     * Name of the radio button group. All radio buttons inside this group will use this name.
                     * @return {?}
                     */
                    get: function () { return this._name; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._name = value;
                        this._updateRadioButtonNames();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "labelPosition", {
                    /**
                     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
                     * @return {?}
                     */
                    get: function () {
                        return this._labelPosition;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._labelPosition = v === 'before' ? 'before' : 'after';
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "value", {
                    /**
                     * Value for the radio-group. Should equal the value of the selected radio button if there is
                     * a corresponding radio button with a matching value. If there is not such a corresponding
                     * radio button, this value persists to be applied in case a new radio button is added with a
                     * matching value.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        if (this._value !== newValue) {
                            // Set this before proceeding to ensure no circular loop occurs with selection.
                            this._value = newValue;
                            this._updateSelectedRadioFromValue();
                            this._checkSelectedRadioButton();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatRadioGroup.prototype._checkSelectedRadioButton = function () {
                    if (this._selected && !this._selected.checked) {
                        this._selected.checked = true;
                    }
                };
                Object.defineProperty(MatRadioGroup.prototype, "selected", {
                    /**
                     * The currently selected radio button. If set to a new radio button, the radio group value
                     * will be updated to match the new selected button.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} selected
                     * @return {?}
                     */
                    set: function (selected) {
                        this._selected = selected;
                        this.value = selected ? selected.value : null;
                        this._checkSelectedRadioButton();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "disabled", {
                    /**
                     * Whether the radio group is disabled
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "required", {
                    /**
                     * Whether the radio group is required
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Initialize properties once content children are available.
                 * This allows us to propagate relevant attributes to associated buttons.
                 * @return {?}
                 */
                MatRadioGroup.prototype.ngAfterContentInit = function () {
                    // Mark this component as initialized in AfterContentInit because the initial value can
                    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the
                    // NgModel occurs *after* the OnInit of the MatRadioGroup.
                    this._isInitialized = true;
                };
                /**
                 * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
                 * radio buttons upon their blur.
                 * @return {?}
                 */
                MatRadioGroup.prototype._touch = function () {
                    if (this.onTouched) {
                        this.onTouched();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatRadioGroup.prototype._updateRadioButtonNames = function () {
                    var _this = this;
                    if (this._radios) {
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) {
                            radio.name = _this.name;
                            radio._markForCheck();
                        }));
                    }
                };
                /**
                 * Updates the `selected` radio button from the internal _value state.
                 * @private
                 * @return {?}
                 */
                MatRadioGroup.prototype._updateSelectedRadioFromValue = function () {
                    var _this = this;
                    // If the value already matches the selected radio, do nothing.
                    /** @type {?} */
                    var isAlreadySelected = this._selected !== null && this._selected.value === this._value;
                    if (this._radios && !isAlreadySelected) {
                        this._selected = null;
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) {
                            radio.checked = _this.value === radio.value;
                            if (radio.checked) {
                                _this._selected = radio;
                            }
                        }));
                    }
                };
                /**
                 * Dispatch change event with current selection and group value.
                 * @return {?}
                 */
                MatRadioGroup.prototype._emitChangeEvent = function () {
                    if (this._isInitialized) {
                        this.change.emit(new MatRadioChange(( /** @type {?} */(this._selected)), this._value));
                    }
                };
                /**
                 * @return {?}
                 */
                MatRadioGroup.prototype._markRadiosForCheck = function () {
                    if (this._radios) {
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) { return radio._markForCheck(); }));
                    }
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatRadioGroup.prototype.writeValue = function (value) {
                    this.value = value;
                    this._changeDetector.markForCheck();
                };
                /**
                 * Registers a callback to be triggered when the model value changes.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatRadioGroup.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                /**
                 * Registers a callback to be triggered when the control is touched.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatRadioGroup.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                /**
                 * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled Whether the control should be disabled.
                 * @return {?}
                 */
                MatRadioGroup.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetector.markForCheck();
                };
                return MatRadioGroup;
            }());
            MatRadioGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-radio-group',
                            exportAs: 'matRadioGroup',
                            providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
                            host: {
                                'role': 'radiogroup',
                                'class': 'mat-radio-group',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatRadioGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            MatRadioGroup.propDecorators = {
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                _radios: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatRadioButton; })), { descendants: true },] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            // Boilerplate for applying mixins to MatRadioButton.
            /**
             * \@docs-private
             */
            var MatRadioButtonBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatRadioButtonBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatRadioButtonBase;
            }());
            // As per Material design specifications the selection control radio should use the accent color
            // palette by default. https://material.io/guidelines/components/selection-controls.html
            /** @type {?} */
            var _MatRadioButtonMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinTabIndex"])(MatRadioButtonBase));
            /**
             * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.
             */
            var MatRadioButton = /** @class */ (function (_super) {
                __extends(MatRadioButton, _super);
                /**
                 * @param {?} radioGroup
                 * @param {?} elementRef
                 * @param {?} _changeDetector
                 * @param {?} _focusMonitor
                 * @param {?} _radioDispatcher
                 * @param {?=} _animationMode
                 * @param {?=} _providerOverride
                 */
                function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode, _providerOverride) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._changeDetector = _changeDetector;
                    _this._focusMonitor = _focusMonitor;
                    _this._radioDispatcher = _radioDispatcher;
                    _this._animationMode = _animationMode;
                    _this._providerOverride = _providerOverride;
                    _this._uniqueId = "mat-radio-" + ++nextUniqueId;
                    /**
                     * The unique ID for the radio button.
                     */
                    _this.id = _this._uniqueId;
                    /**
                     * Event emitted when the checked state of this radio button changes.
                     * Change events are only emitted when the value changes due to user interaction with
                     * the radio button (the same behavior as `<input type-"radio">`).
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Whether this radio is checked.
                     */
                    _this._checked = false;
                    /**
                     * Value assigned to this radio.
                     */
                    _this._value = null;
                    /**
                     * Unregister function for _radioDispatcher
                     */
                    _this._removeUniqueSelectionListener = ( /**
                     * @return {?}
                     */function () { });
                    // Assertions. Ideally these should be stripped out by the compiler.
                    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.
                    _this.radioGroup = radioGroup;
                    _this._removeUniqueSelectionListener =
                        _radioDispatcher.listen(( /**
                         * @param {?} id
                         * @param {?} name
                         * @return {?}
                         */function (id, name) {
                            if (id !== _this.id && name === _this.name) {
                                _this.checked = false;
                            }
                        }));
                    return _this;
                }
                Object.defineProperty(MatRadioButton.prototype, "checked", {
                    /**
                     * Whether this radio button is checked.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newCheckedState = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._checked !== newCheckedState) {
                            this._checked = newCheckedState;
                            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {
                                this.radioGroup.selected = this;
                            }
                            else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {
                                // When unchecking the selected radio button, update the selected radio
                                // property on the group.
                                this.radioGroup.selected = null;
                            }
                            if (newCheckedState) {
                                // Notify all radio buttons with the same name to un-check.
                                this._radioDispatcher.notify(this.id, this.name);
                            }
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "value", {
                    /**
                     * The value of this radio button.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._value !== value) {
                            this._value = value;
                            if (this.radioGroup !== null) {
                                if (!this.checked) {
                                    // Update checked when the value changed to match the radio group's value
                                    this.checked = this.radioGroup.value === value;
                                }
                                if (this.checked) {
                                    this.radioGroup.selected = this;
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "labelPosition", {
                    /**
                     * Whether the label should appear after or before the radio button. Defaults to 'after'
                     * @return {?}
                     */
                    get: function () {
                        return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._labelPosition = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "disabled", {
                    /**
                     * Whether the radio button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newDisabledState = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._disabled !== newDisabledState) {
                            this._disabled = newDisabledState;
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "required", {
                    /**
                     * Whether the radio button is required.
                     * @return {?}
                     */
                    get: function () {
                        return this._required || (this.radioGroup && this.radioGroup.required);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "color", {
                    /**
                     * Theme color of the radio button.
                     * @return {?}
                     */
                    get: function () {
                        return this._color ||
                            (this.radioGroup && this.radioGroup.color) ||
                            this._providerOverride && this._providerOverride.color || 'accent';
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) { this._color = newValue; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "inputId", {
                    /**
                     * ID of the native input element inside `<mat-radio-button>`
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Focuses the radio button.
                 * @param {?=} options
                 * @return {?}
                 */
                MatRadioButton.prototype.focus = function (options) {
                    this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);
                };
                /**
                 * Marks the radio button as needing checking for change detection.
                 * This method is exposed because the parent radio group will directly
                 * update bound properties of the radio button.
                 * @return {?}
                 */
                MatRadioButton.prototype._markForCheck = function () {
                    // When group value changes, the button will not be notified. Use `markForCheck` to explicit
                    // update radio button's status
                    this._changeDetector.markForCheck();
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngOnInit = function () {
                    if (this.radioGroup) {
                        // If the radio is inside a radio group, determine if it should be checked
                        this.checked = this.radioGroup.value === this._value;
                        // Copy name from parent radio group
                        this.name = this.radioGroup.name;
                    }
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} focusOrigin
                 * @return {?}
                 */function (/**
                 * @param {?} focusOrigin
                 * @return {?}
                 */ focusOrigin) {
                        if (!focusOrigin && _this.radioGroup) {
                            _this.radioGroup._touch();
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    this._removeUniqueSelectionListener();
                };
                /**
                 * Dispatch change event with current value.
                 * @private
                 * @return {?}
                 */
                MatRadioButton.prototype._emitChangeEvent = function () {
                    this.change.emit(new MatRadioChange(this, this._value));
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatRadioButton.prototype._onInputClick = function (event) {
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `radio-button` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                };
                /**
                 * Triggered when the radio button received a click or the input recognized any change.
                 * Clicking on a label element, will trigger a change event on the associated input.
                 * @param {?} event
                 * @return {?}
                 */
                MatRadioButton.prototype._onInputChange = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the `change` output.
                    event.stopPropagation();
                    /** @type {?} */
                    var groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;
                    this.checked = true;
                    this._emitChangeEvent();
                    if (this.radioGroup) {
                        this.radioGroup._controlValueAccessorChangeFn(this.value);
                        if (groupValueChanged) {
                            this.radioGroup._emitChangeEvent();
                        }
                    }
                };
                return MatRadioButton;
            }(_MatRadioButtonMixinBase));
            MatRadioButton.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-radio-button',
                            template: "<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label><div class=\"mat-radio-container\"><div class=\"mat-radio-outer-circle\"></div><div class=\"mat-radio-inner-circle\"></div><div mat-ripple class=\"mat-radio-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div></div><input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [tabIndex]=\"tabIndex\" [attr.name]=\"name\" [attr.value]=\"value\" [required]=\"required\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-describedby]=\"ariaDescribedby\" (change)=\"_onInputChange($event)\" (click)=\"_onInputClick($event)\"></div><div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></div></label>",
                            styles: [".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}@media (-ms-high-contrast:active){.mat-radio-checked .mat-radio-inner-circle{border:solid 10px}}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple,.mat-radio-persistent-ripple{opacity:0}@media (hover:none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}@media (-ms-high-contrast:active){.mat-radio-disabled{opacity:.5}}"],
                            inputs: ['disableRipple', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matRadioButton',
                            host: {
                                'class': 'mat-radio-button',
                                '[class.mat-radio-checked]': 'checked',
                                '[class.mat-radio-disabled]': 'disabled',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '[class.mat-primary]': 'color === "primary"',
                                '[class.mat-accent]': 'color === "accent"',
                                '[class.mat-warn]': 'color === "warn"',
                                // Needs to be -1 so the `focus` event still fires.
                                '[attr.tabindex]': '-1',
                                '[attr.id]': 'id',
                                '[attr.aria-label]': 'null',
                                '[attr.aria-labelledby]': 'null',
                                '[attr.aria-describedby]': 'null',
                                // Note: under normal conditions focus shouldn't land on this element, however it may be
                                // programmatically set, for example inside of a focus trap, in this case we want to forward
                                // the focus to the native element.
                                '(focus)': '_inputElement.nativeElement.focus()',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatRadioButton.ctorParameters = function () { return [
                { type: MatRadioGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__["UniqueSelectionDispatcher"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_RADIO_DEFAULT_OPTIONS,] }] }
            ]; };
            MatRadioButton.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-labelledby',] }],
                ariaDescribedby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-describedby',] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: ['input', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatRadioModule = /** @class */ (function () {
                function MatRadioModule() {
                }
                return MatRadioModule;
            }());
            MatRadioModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]],
                            exports: [MatRadioGroup, MatRadioButton, _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]],
                            declarations: [MatRadioGroup, MatRadioButton],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=radio.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/slide-toggle.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/slide-toggle.js ***!
          \****************************************************************/
        /*! exports provided: _MatSlideToggleRequiredValidatorModule, MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggle, MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS, MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR, MatSlideToggleRequiredValidator */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatSlideToggleRequiredValidatorModule", function () { return _MatSlideToggleRequiredValidatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleModule", function () { return MatSlideToggleModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_VALUE_ACCESSOR", function () { return MAT_SLIDE_TOGGLE_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleChange", function () { return MatSlideToggleChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggle", function () { return MatSlideToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS", function () { return MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR", function () { return MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleRequiredValidator", function () { return MatSlideToggleRequiredValidator; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for `mat-slide-toggle`.
             * @type {?}
             */
            var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-slide-toggle-default-options', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () { return ({ disableToggleValue: false, disableDragValue: false }); })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids for slide-toggle components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlideToggle; })),
                multi: true
            };
            /**
             * Change event object emitted by a MatSlideToggle.
             */
            var MatSlideToggleChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} checked
                 */
                function MatSlideToggleChange(source, checked) {
                    this.source = source;
                    this.checked = checked;
                }
                return MatSlideToggleChange;
            }());
            // Boilerplate for applying mixins to MatSlideToggle.
            /**
             * \@docs-private
             */
            var MatSlideToggleBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatSlideToggleBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatSlideToggleBase;
            }());
            /** @type {?} */
            var _MatSlideToggleMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisabled"])(MatSlideToggleBase)), 'accent'));
            /**
             * Represents a slidable "switch" toggle that can be moved between on and off.
             */
            var MatSlideToggle = /** @class */ (function (_super) {
                __extends(MatSlideToggle, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?} tabIndex
                 * @param {?} _ngZone
                 * @param {?} defaults
                 * @param {?=} _animationMode
                 * @param {?=} _dir
                 */
                function MatSlideToggle(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, _ngZone, defaults, _animationMode, _dir) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._focusMonitor = _focusMonitor;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._ngZone = _ngZone;
                    _this.defaults = defaults;
                    _this._animationMode = _animationMode;
                    _this._dir = _dir;
                    _this._onChange = ( /**
                     * @param {?} _
                     * @return {?}
                     */function (_) { });
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this._uniqueId = "mat-slide-toggle-" + ++nextUniqueId;
                    _this._required = false;
                    _this._checked = false;
                    /**
                     * Whether the thumb is currently being dragged.
                     */
                    _this._dragging = false;
                    /**
                     * Name value will be applied to the input element if present.
                     */
                    _this.name = null;
                    /**
                     * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.
                     */
                    _this.id = _this._uniqueId;
                    /**
                     * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.
                     */
                    _this.labelPosition = 'after';
                    /**
                     * Used to set the aria-label attribute on the underlying input element.
                     */
                    _this.ariaLabel = null;
                    /**
                     * Used to set the aria-labelledby attribute on the underlying input element.
                     */
                    _this.ariaLabelledby = null;
                    /**
                     * An event will be dispatched each time the slide-toggle changes its value.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event will be dispatched each time the slide-toggle input is toggled.
                     * This event is always emitted when the user toggles the slide toggle, but this does not mean
                     * the slide toggle's value has changed. The event does not fire when the user drags to change
                     * the slide toggle value.
                     */
                    _this.toggleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event will be dispatched each time the slide-toggle is dragged.
                     * This event is always emitted when the user drags the slide toggle to make a change greater
                     * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when
                     * the user toggles the slide toggle to change its value.
                     */
                    _this.dragChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    return _this;
                }
                Object.defineProperty(MatSlideToggle.prototype, "required", {
                    /**
                     * Whether the slide-toggle is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlideToggle.prototype, "checked", {
                    /**
                     * Whether the slide-toggle element is checked or not.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._checked = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlideToggle.prototype, "inputId", {
                    /**
                     * Returns the unique id for the visual hidden input.
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} focusOrigin
                 * @return {?}
                 */function (/**
                 * @param {?} focusOrigin
                 * @return {?}
                 */ focusOrigin) {
                        if (!focusOrigin) {
                            // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                            // Angular does not expect events to be raised during change detection, so any state
                            // change (such as a form control's 'ng-touched') will cause a changed-after-checked
                            // error. See https://github.com/angular/angular/issues/17793. To work around this,
                            // we defer telling the form control it has been touched until the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () { return _this._onTouched(); }));
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Method being called whenever the underlying input emits a change event.
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onChangeEvent = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the component's `change` output.
                    event.stopPropagation();
                    if (!this._dragging) {
                        this.toggleChange.emit();
                    }
                    // Releasing the pointer over the `<label>` element while dragging triggers another
                    // click event on the `<label>` element. This means that the checked state of the underlying
                    // input changed unintentionally and needs to be changed back. Or when the slide toggle's config
                    // disabled toggle change event by setting `disableToggleValue: true`, the slide toggle's value
                    // does not change, and the checked state of the underlying input needs to be changed back.
                    if (this._dragging || this.defaults.disableToggleValue) {
                        this._inputElement.nativeElement.checked = this.checked;
                        return;
                    }
                    // Sync the value from the underlying input element with the component instance.
                    this.checked = this._inputElement.nativeElement.checked;
                    // Emit our custom change event only if the underlying input emitted one. This ensures that
                    // there is no change event, when the checked state changes programmatically.
                    this._emitChangeEvent();
                };
                /**
                 * Method being called whenever the slide-toggle has been clicked.
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onInputClick = function (event) {
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `slide-toggle` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatSlideToggle.prototype.writeValue = function (value) {
                    this.checked = !!value;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSlideToggle.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSlideToggle.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                /**
                 * Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSlideToggle.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the slide-toggle.
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlideToggle.prototype.focus = function (options) {
                    this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);
                };
                /**
                 * Toggles the checked state of the slide-toggle.
                 * @return {?}
                 */
                MatSlideToggle.prototype.toggle = function () {
                    this.checked = !this.checked;
                    this._onChange(this.checked);
                };
                /**
                 * Emits a change event on the `change` output. Also notifies the FormControl about the change.
                 * @private
                 * @return {?}
                 */
                MatSlideToggle.prototype._emitChangeEvent = function () {
                    this._onChange(this.checked);
                    this.change.emit(new MatSlideToggleChange(this, this.checked));
                };
                /**
                 * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.
                 * @private
                 * @param {?} distance
                 * @return {?}
                 */
                MatSlideToggle.prototype._getDragPercentage = function (distance) {
                    /** @type {?} */
                    var percentage = (distance / this._thumbBarWidth) * 100;
                    // When the toggle was initially checked, then we have to start the drag at the end.
                    if (this._previousChecked) {
                        percentage += 100;
                    }
                    return Math.max(0, Math.min(percentage, 100));
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDragStart = function () {
                    if (!this.disabled && !this._dragging) {
                        /** @type {?} */
                        var thumbEl = this._thumbEl.nativeElement;
                        this._thumbBarWidth = this._thumbBarEl.nativeElement.clientWidth - thumbEl.clientWidth;
                        thumbEl.classList.add('mat-dragging');
                        this._previousChecked = this.checked;
                        this._dragging = true;
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDrag = function (event) {
                    if (this._dragging) {
                        /** @type {?} */
                        var direction = this._dir && this._dir.value === 'rtl' ? -1 : 1;
                        this._dragPercentage = this._getDragPercentage(event.deltaX * direction);
                        // Calculate the moved distance based on the thumb bar width.
                        /** @type {?} */
                        var dragX = (this._dragPercentage / 100) * this._thumbBarWidth * direction;
                        this._thumbEl.nativeElement.style.transform = "translate3d(" + dragX + "px, 0, 0)";
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDragEnd = function () {
                    var _this = this;
                    if (this._dragging) {
                        /** @type {?} */
                        var newCheckedValue = this._dragPercentage > 50;
                        if (newCheckedValue !== this.checked) {
                            this.dragChange.emit();
                            if (!this.defaults.disableDragValue) {
                                this.checked = newCheckedValue;
                                this._emitChangeEvent();
                            }
                        }
                        // The drag should be stopped outside of the current event handler, otherwise the
                        // click event will be fired before it and will revert the drag change.
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () { return setTimeout(( /**
                         * @return {?}
                         */function () {
                            if (_this._dragging) {
                                _this._dragging = false;
                                _this._thumbEl.nativeElement.classList.remove('mat-dragging');
                                // Reset the transform because the component will take care
                                // of the thumb position after drag.
                                _this._thumbEl.nativeElement.style.transform = '';
                            }
                        })); }));
                    }
                };
                /**
                 * Method being called whenever the label text changes.
                 * @return {?}
                 */
                MatSlideToggle.prototype._onLabelTextChange = function () {
                    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the
                    // slide-toggle component will be only marked for check, but no actual change detection runs
                    // automatically. Instead of going back into the zone in order to trigger a change detection
                    // which causes *all* components to be checked (if explicitly marked or not using OnPush),
                    // we only trigger an explicit change detection for the slide-toggle view and its children.
                    this._changeDetectorRef.detectChanges();
                };
                return MatSlideToggle;
            }(_MatSlideToggleMixinBase));
            MatSlideToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-slide-toggle',
                            exportAs: 'matSlideToggle',
                            host: {
                                'class': 'mat-slide-toggle',
                                '[id]': 'id',
                                // Needs to be `-1` so it can still receive programmatic focus.
                                '[attr.tabindex]': 'disabled ? null : -1',
                                '[attr.aria-label]': 'null',
                                '[attr.aria-labelledby]': 'null',
                                '[class.mat-checked]': 'checked',
                                '[class.mat-disabled]': 'disabled',
                                '[class.mat-slide-toggle-label-before]': 'labelPosition == "before"',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '(focus)': '_inputElement.nativeElement.focus()',
                            },
                            template: "<label [attr.for]=\"inputId\" class=\"mat-slide-toggle-label\" #label><div #toggleBar class=\"mat-slide-toggle-bar\" [class.mat-slide-toggle-bar-no-side-margin]=\"!labelContent.textContent || !labelContent.textContent.trim()\"><input #input class=\"mat-slide-toggle-input cdk-visually-hidden\" type=\"checkbox\" role=\"switch\" [id]=\"inputId\" [required]=\"required\" [tabIndex]=\"tabIndex\" [checked]=\"checked\" [disabled]=\"disabled\" [attr.name]=\"name\" [attr.aria-checked]=\"checked.toString()\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (change)=\"_onChangeEvent($event)\" (click)=\"_onInputClick($event)\"><div class=\"mat-slide-toggle-thumb-container\" #thumbContainer (slidestart)=\"_onDragStart()\" (slide)=\"_onDrag($event)\" (slideend)=\"_onDragEnd()\"><div class=\"mat-slide-toggle-thumb\"></div><div class=\"mat-slide-toggle-ripple\" mat-ripple [matRippleTrigger]=\"label\" [matRippleDisabled]=\"disableRipple || disabled\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-slide-toggle-persistent-ripple\"></div></div></div></div><span class=\"mat-slide-toggle-content\" #labelContent (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                            styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px,0,0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging{transition-duration:0s}.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media (hover:none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}@media (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background:#000;border:1px solid #fff}.mat-slide-toggle-bar{background:#fff}.mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:1px dotted;outline-offset:5px}}@media (-ms-high-contrast:black-on-white){.mat-slide-toggle-bar{border:1px solid #000}}"],
                            providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],
                            inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatSlideToggle.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__["ANIMATION_MODULE_TYPE"],] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatSlideToggle.propDecorators = {
                _thumbEl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['thumbContainer', { static: false },] }],
                _thumbBarEl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['toggleBar', { static: false },] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                toggleChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                dragChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['input', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlideToggleRequiredValidator; })),
                multi: true
            };
            /**
             * Validator for Material slide-toggle components with the required attribute in a
             * template-driven form. The default validator for required form controls asserts
             * that the control value is not undefined but that is not appropriate for a slide-toggle
             * where the value is always defined.
             *
             * Required slide-toggle form controls are valid when checked.
             */
            var MatSlideToggleRequiredValidator = /** @class */ (function (_super) {
                __extends(MatSlideToggleRequiredValidator, _super);
                function MatSlideToggleRequiredValidator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatSlideToggleRequiredValidator;
            }(_angular_forms__WEBPACK_IMPORTED_MODULE_4__["CheckboxRequiredValidator"]));
            MatSlideToggleRequiredValidator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-slide-toggle[required][formControlName],\n             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]",
                            providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This module is used by both original and MDC-based slide-toggle implementations.
             */
            // tslint:disable-next-line:class-name
            var _MatSlideToggleRequiredValidatorModule = /** @class */ (function () {
                function _MatSlideToggleRequiredValidatorModule() {
                }
                return _MatSlideToggleRequiredValidatorModule;
            }());
            _MatSlideToggleRequiredValidatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [MatSlideToggleRequiredValidator],
                            declarations: [MatSlideToggleRequiredValidator],
                        },] },
            ];
            var MatSlideToggleModule = /** @class */ (function () {
                function MatSlideToggleModule() {
                }
                return MatSlideToggleModule;
            }());
            MatSlideToggleModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _MatSlideToggleRequiredValidatorModule,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"],
                                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["ObserversModule"],
                            ],
                            exports: [
                                _MatSlideToggleRequiredValidatorModule,
                                MatSlideToggle,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]
                            ],
                            declarations: [MatSlideToggle],
                            providers: [
                                { provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["GestureConfig"] }
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=slide-toggle.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/slider.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/slider.js ***!
          \**********************************************************/
        /*! exports provided: MatSliderModule, MAT_SLIDER_VALUE_ACCESSOR, MatSliderChange, MatSlider */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSliderModule", function () { return MatSliderModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDER_VALUE_ACCESSOR", function () { return MAT_SLIDER_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSliderChange", function () { return MatSliderChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlider", function () { return MatSlider; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
             * the default separation we chose.
             * @type {?}
             */
            var MIN_AUTO_TICK_SEPARATION = 30;
            /**
             * The thumb gap size for a disabled slider.
             * @type {?}
             */
            var DISABLED_THUMB_GAP = 7;
            /**
             * The thumb gap size for a non-active slider at its minimum value.
             * @type {?}
             */
            var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
            /**
             * The thumb gap size for an active slider at its minimum value.
             * @type {?}
             */
            var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
            /**
             * Provider Expression that allows mat-slider to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)] and [formControl].
             * \@docs-private
             * @type {?}
             */
            var MAT_SLIDER_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlider; })),
                multi: true
            };
            /**
             * A simple change event emitted by the MatSlider component.
             */
            var MatSliderChange = /** @class */ (function () {
                function MatSliderChange() {
                }
                return MatSliderChange;
            }());
            // Boilerplate for applying mixins to MatSlider.
            /**
             * \@docs-private
             */
            var MatSliderBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatSliderBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatSliderBase;
            }());
            /** @type {?} */
            var _MatSliderMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisabled"])(MatSliderBase), 'accent'));
            /**
             * Allows users to select from a range of values by moving the slider thumb. It is similar in
             * behavior to the native `<input type="range">` element.
             */
            var MatSlider = /** @class */ (function (_super) {
                __extends(MatSlider, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?} _dir
                 * @param {?} tabIndex
                 * @param {?=} _animationMode
                 */
                function MatSlider(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _animationMode) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._focusMonitor = _focusMonitor;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._dir = _dir;
                    _this._animationMode = _animationMode;
                    _this._invert = false;
                    _this._max = 100;
                    _this._min = 0;
                    _this._step = 1;
                    _this._thumbLabel = false;
                    _this._tickInterval = 0;
                    _this._value = null;
                    _this._vertical = false;
                    /**
                     * Event emitted when the slider value has changed.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * Event emitted when the slider thumb moves.
                     */
                    _this.input = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * Emits when the raw value of the slider changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     */
                    _this.onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this._percent = 0;
                    /**
                     * Whether or not the thumb is sliding.
                     * Used to determine if there should be a transition for the thumb and fill track.
                     */
                    _this._isSliding = false;
                    /**
                     * Whether or not the slider is active (clicked or sliding).
                     * Used to shrink and grow the thumb as according to the Material Design spec.
                     */
                    _this._isActive = false;
                    /**
                     * The size of a tick interval as a percentage of the size of the track.
                     */
                    _this._tickIntervalPercent = 0;
                    /**
                     * The dimensions of the slider.
                     */
                    _this._sliderDimensions = null;
                    _this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Subscription to the Directionality change EventEmitter.
                     */
                    _this._dirChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__["Subscription"].EMPTY;
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    return _this;
                }
                Object.defineProperty(MatSlider.prototype, "invert", {
                    /**
                     * Whether the slider is inverted.
                     * @return {?}
                     */
                    get: function () { return this._invert; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._invert = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "max", {
                    /**
                     * The maximum value that the slider can have.
                     * @return {?}
                     */
                    get: function () { return this._max; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._max = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._max);
                        this._percent = this._calculatePercentage(this._value);
                        // Since this also modifies the percentage, we need to let the change detection know.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "min", {
                    /**
                     * The minimum value that the slider can have.
                     * @return {?}
                     */
                    get: function () { return this._min; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._min = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._min);
                        // If the value wasn't explicitly set by the user, set it to the min.
                        if (this._value === null) {
                            this.value = this._min;
                        }
                        this._percent = this._calculatePercentage(this._value);
                        // Since this also modifies the percentage, we need to let the change detection know.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "step", {
                    /**
                     * The values at which the thumb will snap.
                     * @return {?}
                     */
                    get: function () { return this._step; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._step = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._step);
                        if (this._step % 1 !== 0) {
                            this._roundToDecimal = ( /** @type {?} */(this._step.toString().split('.').pop())).length;
                        }
                        // Since this could modify the label, we need to notify the change detection.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "thumbLabel", {
                    /**
                     * Whether or not to show the thumb label.
                     * @return {?}
                     */
                    get: function () { return this._thumbLabel; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._thumbLabel = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "tickInterval", {
                    /**
                     * How often to show ticks. Relative to the step so that a tick always appears on a step.
                     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
                     * @return {?}
                     */
                    get: function () { return this._tickInterval; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value === 'auto') {
                            this._tickInterval = 'auto';
                        }
                        else if (typeof value === 'number' || typeof value === 'string') {
                            this._tickInterval = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value, ( /** @type {?} */(this._tickInterval)));
                        }
                        else {
                            this._tickInterval = 0;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "value", {
                    /**
                     * Value of the slider.
                     * @return {?}
                     */
                    get: function () {
                        // If the value needs to be read and it is still uninitialized, initialize it to the min.
                        if (this._value === null) {
                            this.value = this._min;
                        }
                        return this._value;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        if (v !== this._value) {
                            /** @type {?} */
                            var value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v);
                            // While incrementing by a decimal we can end up with values like 33.300000000000004.
                            // Truncate it to ensure that it matches the label and to make it easier to work with.
                            if (this._roundToDecimal) {
                                value = parseFloat(value.toFixed(this._roundToDecimal));
                            }
                            this._value = value;
                            this._percent = this._calculatePercentage(this._value);
                            // Since this also modifies the percentage, we need to let the change detection know.
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "vertical", {
                    /**
                     * Whether the slider is vertical.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "displayValue", {
                    /**
                     * The value to be used for display purposes.
                     * @return {?}
                     */
                    get: function () {
                        if (this.displayWith) {
                            // Value is never null but since setters and getters cannot have
                            // different types, the value getter is also typed to return null.
                            return this.displayWith(( /** @type {?} */(this.value)));
                        }
                        // Note that this could be improved further by rounding something like 0.999 to 1 or
                        // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
                        // every change detection cycle.
                        if (this._roundToDecimal && this.value && this.value % 1 !== 0) {
                            return this.value.toFixed(this._roundToDecimal);
                        }
                        return this.value || 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * set focus to the host element
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlider.prototype.focus = function (options) {
                    this._focusHostElement(options);
                };
                /**
                 * blur the host element
                 * @return {?}
                 */
                MatSlider.prototype.blur = function () {
                    this._blurHostElement();
                };
                Object.defineProperty(MatSlider.prototype, "percent", {
                    /**
                     * The percentage of the slider that coincides with the value.
                     * @return {?}
                     */
                    get: function () { return this._clamp(this._percent); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_invertAxis", {
                    /**
                     * Whether the axis of the slider is inverted.
                     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
                     * @return {?}
                     */
                    get: function () {
                        // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
                        // top. However from a y-axis standpoint this is inverted.
                        return this.vertical ? !this.invert : this.invert;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_isMinValue", {
                    /**
                     * Whether the slider is at its minimum value.
                     * @return {?}
                     */
                    get: function () {
                        return this.percent === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_thumbGap", {
                    /**
                     * The amount of space to leave between the slider thumb and the track fill & track background
                     * elements.
                     * @return {?}
                     */
                    get: function () {
                        if (this.disabled) {
                            return DISABLED_THUMB_GAP;
                        }
                        if (this._isMinValue && !this.thumbLabel) {
                            return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
                        }
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_trackBackgroundStyles", {
                    /**
                     * CSS styles for the track background element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        /** @type {?} */
                        var scale = this.vertical ? "1, " + (1 - this.percent) + ", 1" : 1 - this.percent + ", 1, 1";
                        /** @type {?} */
                        var sign = this._shouldInvertMouseCoords() ? '-' : '';
                        return {
                            // scale3d avoids some rendering issues in Chrome. See #12071.
                            transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_trackFillStyles", {
                    /**
                     * CSS styles for the track fill element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        /** @type {?} */
                        var scale = this.vertical ? "1, " + this.percent + ", 1" : this.percent + ", 1, 1";
                        /** @type {?} */
                        var sign = this._shouldInvertMouseCoords() ? '' : '-';
                        return {
                            // scale3d avoids some rendering issues in Chrome. See #12071.
                            transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_ticksContainerStyles", {
                    /**
                     * CSS styles for the ticks container element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // For a horizontal slider in RTL languages we push the ticks container off the left edge
                        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
                        /** @type {?} */
                        var sign = !this.vertical && this._getDirection() == 'rtl' ? '' : '-';
                        /** @type {?} */
                        var offset = this._tickIntervalPercent / 2 * 100;
                        return {
                            'transform': "translate" + axis + "(" + sign + offset + "%)"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_ticksStyles", {
                    /**
                     * CSS styles for the ticks element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var tickSize = this._tickIntervalPercent * 100;
                        /** @type {?} */
                        var backgroundSize = this.vertical ? "2px " + tickSize + "%" : tickSize + "% 2px";
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // Depending on the direction we pushed the ticks container, push the ticks the opposite
                        // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
                        // ticks 180 degrees so we're really cutting off the end edge abd not the start.
                        /** @type {?} */
                        var sign = !this.vertical && this._getDirection() == 'rtl' ? '-' : '';
                        /** @type {?} */
                        var rotate = !this.vertical && this._getDirection() == 'rtl' ? ' rotate(180deg)' : '';
                        /** @type {?} */
                        var styles = {
                            'backgroundSize': backgroundSize,
                            // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
                            'transform': "translateZ(0) translate" + axis + "(" + sign + tickSize / 2 + "%)" + rotate
                        };
                        if (this._isMinValue && this._thumbGap) {
                            /** @type {?} */
                            var side = this.vertical ?
                                (this._invertAxis ? 'Bottom' : 'Top') :
                                (this._invertAxis ? 'Right' : 'Left');
                            styles["padding" + side] = this._thumbGap + "px";
                        }
                        return styles;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_thumbContainerStyles", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // For a horizontal slider in RTL languages we push the thumb container off the left edge
                        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
                        /** @type {?} */
                        var invertOffset = (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
                        /** @type {?} */
                        var offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
                        return {
                            'transform': "translate" + axis + "(-" + offset + "%)"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether mouse events should be converted to a slider position by calculating their distance
                 * from the right or bottom edge of the slider as opposed to the top or left.
                 * @return {?}
                 */
                MatSlider.prototype._shouldInvertMouseCoords = function () {
                    return (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
                };
                /**
                 * The language direction for this slider element.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._getDirection = function () {
                    return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype.ngOnInit = function () {
                    var _this = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} origin
                 * @return {?}
                 */function (origin) {
                        _this._isActive = !!origin && origin !== 'keyboard';
                        _this._changeDetectorRef.detectChanges();
                    }));
                    if (this._dir) {
                        this._dirChangeSubscription = this._dir.change.subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    this._dirChangeSubscription.unsubscribe();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onMouseenter = function () {
                    if (this.disabled) {
                        return;
                    }
                    // We save the dimensions of the slider here so we can use them to update the spacing of the
                    // ticks and determine where on the slider click and slide events happen.
                    this._sliderDimensions = this._getSliderDimensions();
                    this._updateTickIntervalPercent();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onMousedown = function (event) {
                    // Don't do anything if the slider is disabled or the
                    // user is using anything other than the main mouse button.
                    if (this.disabled || event.button !== 0) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this.value;
                    this._isSliding = false;
                    this._focusHostElement();
                    this._updateValueFromPosition({ x: event.clientX, y: event.clientY });
                    // Emit a change and input event if the value changed.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                        this._emitChangeEvent();
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onSlide = function (event) {
                    if (this.disabled) {
                        return;
                    }
                    // The slide start event sometimes fails to fire on iOS, so if we're not already in the sliding
                    // state, call the slide start handler manually.
                    if (!this._isSliding) {
                        this._onSlideStart(null);
                    }
                    // Prevent the slide from selecting anything else.
                    event.preventDefault();
                    /** @type {?} */
                    var oldValue = this.value;
                    this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                    // Native range elements always emit `input` events when the value changed while sliding.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onSlideStart = function (event) {
                    if (this.disabled || this._isSliding) {
                        return;
                    }
                    // Simulate mouseenter in case this is a mobile device.
                    this._onMouseenter();
                    this._isSliding = true;
                    this._focusHostElement();
                    this._valueOnSlideStart = this.value;
                    if (event) {
                        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                        event.preventDefault();
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onSlideEnd = function () {
                    this._isSliding = false;
                    if (this._valueOnSlideStart != this.value && !this.disabled) {
                        this._emitChangeEvent();
                    }
                    this._valueOnSlideStart = null;
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onFocus = function () {
                    // We save the dimensions of the slider here so we can use them to update the spacing of the
                    // ticks and determine where on the slider click and slide events happen.
                    this._sliderDimensions = this._getSliderDimensions();
                    this._updateTickIntervalPercent();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onBlur = function () {
                    this.onTouched();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onKeydown = function (event) {
                    if (this.disabled || Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["hasModifierKey"])(event)) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this.value;
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this._increment(10);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this._increment(-10);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.value = this.max;
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.value = this.min;
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
                            // inverted slider the thumb moves in that direction. However for a blind user, nothing
                            // about the slider indicates that it is inverted. They will expect left to be decrement,
                            // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
                            // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
                            // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
                            // sighted users, therefore we do not swap the meaning.
                            this._increment(this._getDirection() == 'rtl' ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this._increment(1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
                            this._increment(this._getDirection() == 'rtl' ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this._increment(-1);
                            break;
                        default:
                            // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
                            // it.
                            return;
                    }
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                        this._emitChangeEvent();
                    }
                    this._isSliding = true;
                    event.preventDefault();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onKeyup = function () {
                    this._isSliding = false;
                };
                /**
                 * Increments the slider by the given number of steps (negative number decrements).
                 * @private
                 * @param {?} numSteps
                 * @return {?}
                 */
                MatSlider.prototype._increment = function (numSteps) {
                    this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);
                };
                /**
                 * Calculate the new value from the new physical location. The value will always be snapped.
                 * @private
                 * @param {?} pos
                 * @return {?}
                 */
                MatSlider.prototype._updateValueFromPosition = function (pos) {
                    if (!this._sliderDimensions) {
                        return;
                    }
                    /** @type {?} */
                    var offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
                    /** @type {?} */
                    var size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                    /** @type {?} */
                    var posComponent = this.vertical ? pos.y : pos.x;
                    // The exact value is calculated from the event and used to find the closest snap value.
                    /** @type {?} */
                    var percent = this._clamp((posComponent - offset) / size);
                    if (this._shouldInvertMouseCoords()) {
                        percent = 1 - percent;
                    }
                    // Since the steps may not divide cleanly into the max value, if the user
                    // slid to 0 or 100 percent, we jump to the min/max value. This approach
                    // is slightly more intuitive than using `Math.ceil` below, because it
                    // follows the user's pointer closer.
                    if (percent === 0) {
                        this.value = this.min;
                    }
                    else if (percent === 1) {
                        this.value = this.max;
                    }
                    else {
                        /** @type {?} */
                        var exactValue = this._calculateValue(percent);
                        // This calculation finds the closest step by finding the closest
                        // whole number divisible by the step relative to the min.
                        /** @type {?} */
                        var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
                        // The value needs to snap to the min and max.
                        this.value = this._clamp(closestValue, this.min, this.max);
                    }
                };
                /**
                 * Emits a change event if the current value is different from the last emitted value.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._emitChangeEvent = function () {
                    this._controlValueAccessorChangeFn(this.value);
                    this.valueChange.emit(this.value);
                    this.change.emit(this._createChangeEvent());
                };
                /**
                 * Emits an input event when the current value is different from the last emitted value.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._emitInputEvent = function () {
                    this.input.emit(this._createChangeEvent());
                };
                /**
                 * Updates the amount of space between ticks as a percentage of the width of the slider.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._updateTickIntervalPercent = function () {
                    if (!this.tickInterval || !this._sliderDimensions) {
                        return;
                    }
                    if (this.tickInterval == 'auto') {
                        /** @type {?} */
                        var trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                        /** @type {?} */
                        var pixelsPerStep = trackSize * this.step / (this.max - this.min);
                        /** @type {?} */
                        var stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
                        /** @type {?} */
                        var pixelsPerTick = stepsPerTick * this.step;
                        this._tickIntervalPercent = pixelsPerTick / trackSize;
                    }
                    else {
                        this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
                    }
                };
                /**
                 * Creates a slider change object from the specified value.
                 * @private
                 * @param {?=} value
                 * @return {?}
                 */
                MatSlider.prototype._createChangeEvent = function (value) {
                    if (value === void 0) { value = this.value; }
                    /** @type {?} */
                    var event = new MatSliderChange();
                    event.source = this;
                    event.value = value;
                    return event;
                };
                /**
                 * Calculates the percentage of the slider that a value is.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatSlider.prototype._calculatePercentage = function (value) {
                    return ((value || 0) - this.min) / (this.max - this.min);
                };
                /**
                 * Calculates the value a percentage of the slider corresponds to.
                 * @private
                 * @param {?} percentage
                 * @return {?}
                 */
                MatSlider.prototype._calculateValue = function (percentage) {
                    return this.min + percentage * (this.max - this.min);
                };
                /**
                 * Return a number between two numbers.
                 * @private
                 * @param {?} value
                 * @param {?=} min
                 * @param {?=} max
                 * @return {?}
                 */
                MatSlider.prototype._clamp = function (value, min, max) {
                    if (min === void 0) { min = 0; }
                    if (max === void 0) { max = 1; }
                    return Math.max(min, Math.min(value, max));
                };
                /**
                 * Get the bounding client rect of the slider track element.
                 * The track is used rather than the native element to ignore the extra space that the thumb can
                 * take up.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._getSliderDimensions = function () {
                    return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;
                };
                /**
                 * Focuses the native element.
                 * Currently only used to allow a blur event to fire but will be used with keyboard input later.
                 * @private
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlider.prototype._focusHostElement = function (options) {
                    this._elementRef.nativeElement.focus(options);
                };
                /**
                 * Blurs the native element.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._blurHostElement = function () {
                    this._elementRef.nativeElement.blur();
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatSlider.prototype.writeValue = function (value) {
                    this.value = value;
                };
                /**
                 * Registers a callback to be triggered when the value has changed.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatSlider.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                /**
                 * Registers a callback to be triggered when the component is touched.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatSlider.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                /**
                 * Sets whether the component should be disabled.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSlider.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                return MatSlider;
            }(_MatSliderMixinBase));
            MatSlider.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Component"], args: [{ selector: 'mat-slider',
                            exportAs: 'matSlider',
                            providers: [MAT_SLIDER_VALUE_ACCESSOR],
                            host: {
                                '(focus)': '_onFocus()',
                                '(blur)': '_onBlur()',
                                '(mousedown)': '_onMousedown($event)',
                                '(keydown)': '_onKeydown($event)',
                                '(keyup)': '_onKeyup()',
                                '(mouseenter)': '_onMouseenter()',
                                '(slide)': '_onSlide($event)',
                                '(slideend)': '_onSlideEnd()',
                                '(slidestart)': '_onSlideStart($event)',
                                // On Safari starting to slide temporarily triggers text selection mode which
                                // show the wrong cursor. We prevent it by stopping the `selectstart` event.
                                '(selectstart)': '$event.preventDefault()',
                                'class': 'mat-slider',
                                'role': 'slider',
                                '[tabIndex]': 'tabIndex',
                                '[attr.aria-disabled]': 'disabled',
                                '[attr.aria-valuemax]': 'max',
                                '[attr.aria-valuemin]': 'min',
                                '[attr.aria-valuenow]': 'value',
                                '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                                '[class.mat-slider-disabled]': 'disabled',
                                '[class.mat-slider-has-ticks]': 'tickInterval',
                                '[class.mat-slider-horizontal]': '!vertical',
                                '[class.mat-slider-axis-inverted]': '_invertAxis',
                                // Class binding which is only used by the test harness as there is no other
                                // way for the harness to detect if mouse coordinates need to be inverted.
                                '[class.mat-slider-invert-mouse-coords]': '_shouldInvertMouseCoords()',
                                '[class.mat-slider-sliding]': '_isSliding',
                                '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
                                '[class.mat-slider-vertical]': 'vertical',
                                '[class.mat-slider-min-value]': '_isMinValue',
                                '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue && _thumbGap && _invertAxis',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            },
                            template: "<div class=\"mat-slider-wrapper\" #sliderWrapper><div class=\"mat-slider-track-wrapper\"><div class=\"mat-slider-track-background\" [ngStyle]=\"_trackBackgroundStyles\"></div><div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div></div><div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\"><div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div></div><div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\"><div class=\"mat-slider-focus-ring\"></div><div class=\"mat-slider-thumb\"></div><div class=\"mat-slider-thumb-label\"><span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span></div></div></div>",
                            styles: [".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider.mat-slider-sliding:not(.mat-slider-disabled),.mat-slider:not(.mat-slider-disabled):active{cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}@media (-ms-high-contrast:active){.mat-slider-thumb-label{outline:solid 1px}}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:'';position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}@media (-ms-high-contrast:active){.mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}@media (-ms-high-contrast:active){.mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-track-fill{transition:none}"],
                            inputs: ['disabled', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatSlider.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ChangeDetectorRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_1__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Attribute"], args: ['tabindex',] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatSlider.propDecorators = {
                invert: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                min: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                thumbLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                tickInterval: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                displayWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                _sliderWrapper: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ViewChild"], args: ['sliderWrapper', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSliderModule = /** @class */ (function () {
                function MatSliderModule() {
                }
                return MatSliderModule;
            }());
            MatSliderModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_9__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            exports: [MatSlider, _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            declarations: [MatSlider],
                            providers: [{ provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_10__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["GestureConfig"] }]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=slider.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/snack-bar.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/snack-bar.js ***!
          \*************************************************************/
        /*! exports provided: MatSnackBarModule, MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY, MAT_SNACK_BAR_DEFAULT_OPTIONS, MatSnackBar, MatSnackBarContainer, MAT_SNACK_BAR_DATA, MatSnackBarConfig, MatSnackBarRef, SimpleSnackBar, matSnackBarAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarModule", function () { return MatSnackBarModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY", function () { return MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DEFAULT_OPTIONS", function () { return MAT_SNACK_BAR_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBar", function () { return MatSnackBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarContainer", function () { return MatSnackBarContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DATA", function () { return MAT_SNACK_BAR_DATA; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarConfig", function () { return MatSnackBarConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarRef", function () { return MatSnackBarRef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleSnackBar", function () { return SimpleSnackBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matSnackBarAnimations", function () { return matSnackBarAnimations; });
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Reference to a snack bar dispatched from the snack bar service.
             * @template T
             */
            var MatSnackBarRef = /** @class */ (function () {
                /**
                 * @param {?} containerInstance
                 * @param {?} _overlayRef
                 */
                function MatSnackBarRef(containerInstance, _overlayRef) {
                    var _this = this;
                    this._overlayRef = _overlayRef;
                    /**
                     * Subject for notifying the user that the snack bar has been dismissed.
                     */
                    this._afterDismissed = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Subject for notifying the user that the snack bar has opened and appeared.
                     */
                    this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Subject for notifying the user that the snack bar action was called.
                     */
                    this._onAction = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Whether the snack bar was dismissed using the action button.
                     */
                    this._dismissedByAction = false;
                    this.containerInstance = containerInstance;
                    // Dismiss snackbar on action.
                    this.onAction().subscribe(( /**
                     * @return {?}
                     */function () { return _this.dismiss(); }));
                    containerInstance._onExit.subscribe(( /**
                     * @return {?}
                     */function () { return _this._finishDismiss(); }));
                }
                /**
                 * Dismisses the snack bar.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.dismiss = function () {
                    if (!this._afterDismissed.closed) {
                        this.containerInstance.exit();
                    }
                    clearTimeout(this._durationTimeoutId);
                };
                /**
                 * Marks the snackbar action clicked.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.dismissWithAction = function () {
                    if (!this._onAction.closed) {
                        this._dismissedByAction = true;
                        this._onAction.next();
                        this._onAction.complete();
                    }
                };
                /**
                 * Marks the snackbar action clicked.
                 * @deprecated Use `dismissWithAction` instead.
                 * \@breaking-change 8.0.0
                 * @return {?}
                 */
                MatSnackBarRef.prototype.closeWithAction = function () {
                    this.dismissWithAction();
                };
                /**
                 * Dismisses the snack bar after some duration
                 * @param {?} duration
                 * @return {?}
                 */
                MatSnackBarRef.prototype._dismissAfter = function (duration) {
                    var _this = this;
                    this._durationTimeoutId = setTimeout(( /**
                     * @return {?}
                     */function () { return _this.dismiss(); }), duration);
                };
                /**
                 * Marks the snackbar as opened
                 * @return {?}
                 */
                MatSnackBarRef.prototype._open = function () {
                    if (!this._afterOpened.closed) {
                        this._afterOpened.next();
                        this._afterOpened.complete();
                    }
                };
                /**
                 * Cleans up the DOM after closing.
                 * @private
                 * @return {?}
                 */
                MatSnackBarRef.prototype._finishDismiss = function () {
                    this._overlayRef.dispose();
                    if (!this._onAction.closed) {
                        this._onAction.complete();
                    }
                    this._afterDismissed.next({ dismissedByAction: this._dismissedByAction });
                    this._afterDismissed.complete();
                    this._dismissedByAction = false;
                };
                /**
                 * Gets an observable that is notified when the snack bar is finished closing.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.afterDismissed = function () {
                    return this._afterDismissed.asObservable();
                };
                /**
                 * Gets an observable that is notified when the snack bar has opened and appeared.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.afterOpened = function () {
                    return this.containerInstance._onEnter;
                };
                /**
                 * Gets an observable that is notified when the snack bar action is called.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.onAction = function () {
                    return this._onAction.asObservable();
                };
                return MatSnackBarRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to access the data that was passed in to a snack bar.
             * @type {?}
             */
            var MAT_SNACK_BAR_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('MatSnackBarData');
            /**
             * Configuration used when opening a snack-bar.
             * @template D
             */
            var MatSnackBarConfig = /** @class */ (function () {
                function MatSnackBarConfig() {
                    /**
                     * The politeness level for the MatAriaLiveAnnouncer announcement.
                     */
                    this.politeness = 'assertive';
                    /**
                     * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom
                     * component or template, the announcement message will default to the specified message.
                     */
                    this.announcementMessage = '';
                    /**
                     * The length of time in milliseconds to wait before automatically dismissing the snack bar.
                     */
                    this.duration = 0;
                    /**
                     * Data being injected into the child component.
                     */
                    this.data = null;
                    /**
                     * The horizontal position to place the snack bar.
                     */
                    this.horizontalPosition = 'center';
                    /**
                     * The vertical position to place the snack bar.
                     */
                    this.verticalPosition = 'bottom';
                }
                return MatSnackBarConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * A component used to open as the default snack bar, matching material spec.
             * This should only be used internally by the snack bar service.
             */
            var SimpleSnackBar = /** @class */ (function () {
                /**
                 * @param {?} snackBarRef
                 * @param {?} data
                 */
                function SimpleSnackBar(snackBarRef, data) {
                    this.snackBarRef = snackBarRef;
                    this.data = data;
                }
                /**
                 * Performs the action on the snack bar.
                 * @return {?}
                 */
                SimpleSnackBar.prototype.action = function () {
                    this.snackBarRef.dismissWithAction();
                };
                Object.defineProperty(SimpleSnackBar.prototype, "hasAction", {
                    /**
                     * If the action button should be shown.
                     * @return {?}
                     */
                    get: function () {
                        return !!this.data.action;
                    },
                    enumerable: true,
                    configurable: true
                });
                return SimpleSnackBar;
            }());
            SimpleSnackBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'simple-snack-bar',
                            template: "<span>{{data.message}}</span><div class=\"mat-simple-snackbar-action\" *ngIf=\"hasAction\"><button mat-button (click)=\"action()\">{{data.action}}</button></div>",
                            styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-simple-snackbar',
                            }
                        },] },
            ];
            /** @nocollapse */
            SimpleSnackBar.ctorParameters = function () { return [
                { type: MatSnackBarRef },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_SNACK_BAR_DATA,] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material snack bar.
             * \@docs-private
             * @type {?}
             */
            var matSnackBarAnimations = {
                /**
                 * Animation that shows and hides a snack bar.
                 */
                snackBarState: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])('state', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('void, hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        transform: 'scale(0.8)',
                        opacity: 0,
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        transform: 'scale(1)',
                        opacity: 1,
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('* => visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('150ms cubic-bezier(0, 0, 0.2, 1)')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('* => void, * => hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('75ms cubic-bezier(0.4, 0.0, 1, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        opacity: 0
                    }))),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Internal component that wraps user-provided snack bar content.
             * \@docs-private
             */
            var MatSnackBarContainer = /** @class */ (function (_super) {
                __extends(MatSnackBarContainer, _super);
                /**
                 * @param {?} _ngZone
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} snackBarConfig
                 */
                function MatSnackBarContainer(_ngZone, _elementRef, _changeDetectorRef, snackBarConfig) {
                    var _this = _super.call(this) || this;
                    _this._ngZone = _ngZone;
                    _this._elementRef = _elementRef;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this.snackBarConfig = snackBarConfig;
                    /**
                     * Whether the component has been destroyed.
                     */
                    _this._destroyed = false;
                    /**
                     * Subject for notifying that the snack bar has exited from view.
                     */
                    _this._onExit = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Subject for notifying that the snack bar has finished entering the view.
                     */
                    _this._onEnter = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * The state of the snack bar animations.
                     */
                    _this._animationState = 'void';
                    // Based on the ARIA spec, `alert` and `status` roles have an
                    // implicit `assertive` and `polite` politeness respectively.
                    if (snackBarConfig.politeness === 'assertive' && !snackBarConfig.announcementMessage) {
                        _this._role = 'alert';
                    }
                    else if (snackBarConfig.politeness === 'off') {
                        _this._role = null;
                    }
                    else {
                        _this._role = 'status';
                    }
                    return _this;
                }
                /**
                 * Attach a component portal as content to this snack bar container.
                 * @template T
                 * @param {?} portal
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.attachComponentPortal = function (portal) {
                    this._assertNotAttached();
                    this._applySnackBarClasses();
                    return this._portalOutlet.attachComponentPortal(portal);
                };
                /**
                 * Attach a template portal as content to this snack bar container.
                 * @template C
                 * @param {?} portal
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.attachTemplatePortal = function (portal) {
                    this._assertNotAttached();
                    this._applySnackBarClasses();
                    return this._portalOutlet.attachTemplatePortal(portal);
                };
                /**
                 * Handle end of animations, updating the state of the snackbar.
                 * @param {?} event
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.onAnimationEnd = function (event) {
                    var fromState = event.fromState, toState = event.toState;
                    if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
                        this._completeExit();
                    }
                    if (toState === 'visible') {
                        // Note: we shouldn't use `this` inside the zone callback,
                        // because it can cause a memory leak.
                        /** @type {?} */
                        var onEnter_1 = this._onEnter;
                        this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            onEnter_1.next();
                            onEnter_1.complete();
                        }));
                    }
                };
                /**
                 * Begin animation of snack bar entrance into view.
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.enter = function () {
                    if (!this._destroyed) {
                        this._animationState = 'visible';
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Begin animation of the snack bar exiting from view.
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.exit = function () {
                    // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
                    // where multiple snack bars are opened in quick succession (e.g. two consecutive calls to
                    // `MatSnackBar.open`).
                    this._animationState = 'hidden';
                    return this._onExit;
                };
                /**
                 * Makes sure the exit callbacks have been invoked when the element is destroyed.
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.ngOnDestroy = function () {
                    this._destroyed = true;
                    this._completeExit();
                };
                /**
                 * Waits for the zone to settle before removing the element. Helps prevent
                 * errors where we end up removing an element which is in the middle of an animation.
                 * @private
                 * @return {?}
                 */
                MatSnackBarContainer.prototype._completeExit = function () {
                    var _this = this;
                    this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._onExit.next();
                        _this._onExit.complete();
                    }));
                };
                /**
                 * Applies the various positioning and user-configured CSS classes to the snack bar.
                 * @private
                 * @return {?}
                 */
                MatSnackBarContainer.prototype._applySnackBarClasses = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var panelClasses = this.snackBarConfig.panelClass;
                    if (panelClasses) {
                        if (Array.isArray(panelClasses)) {
                            // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                            panelClasses.forEach(( /**
                             * @param {?} cssClass
                             * @return {?}
                             */function (/**
                             * @param {?} cssClass
                             * @return {?}
                             */ cssClass) { return element.classList.add(cssClass); }));
                        }
                        else {
                            element.classList.add(panelClasses);
                        }
                    }
                    if (this.snackBarConfig.horizontalPosition === 'center') {
                        element.classList.add('mat-snack-bar-center');
                    }
                    if (this.snackBarConfig.verticalPosition === 'top') {
                        element.classList.add('mat-snack-bar-top');
                    }
                };
                /**
                 * Asserts that no content is already attached to the container.
                 * @private
                 * @return {?}
                 */
                MatSnackBarContainer.prototype._assertNotAttached = function () {
                    if (this._portalOutlet.hasAttached()) {
                        throw Error('Attempting to attach snack bar content after content is already attached');
                    }
                };
                return MatSnackBarContainer;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["BasePortalOutlet"]));
            MatSnackBarContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'snack-bar-container',
                            template: "<ng-template cdkPortalOutlet></ng-template>",
                            styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}@media (-ms-high-contrast:active){.mat-snack-bar-container{border:solid 1px}}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}"],
                            // In Ivy embedded views will be change detected from their declaration place, rather than
                            // where they were stamped out. This means that we can't have the snack bar container be OnPush,
                            // because it might cause snack bars that were opened from a template not to be out of date.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            animations: [matSnackBarAnimations.snackBarState],
                            host: {
                                '[attr.role]': '_role',
                                'class': 'mat-snack-bar-container',
                                '[@state]': '_animationState',
                                '(@state.done)': 'onAnimationEnd($event)'
                            },
                        },] },
            ];
            /** @nocollapse */
            MatSnackBarContainer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: MatSnackBarConfig }
            ]; };
            MatSnackBarContainer.propDecorators = {
                _portalOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["CdkPortalOutlet"], { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSnackBarModule = /** @class */ (function () {
                function MatSnackBarModule() {
                }
                return MatSnackBarModule;
            }());
            MatSnackBarModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["OverlayModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_8__["MatButtonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                            ],
                            exports: [MatSnackBarContainer, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"]],
                            declarations: [MatSnackBarContainer, SimpleSnackBar],
                            entryComponents: [MatSnackBarContainer, SimpleSnackBar],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify default snack bar.
             * @type {?}
             */
            var MAT_SNACK_BAR_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('mat-snack-bar-default-options', {
                providedIn: 'root',
                factory: MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY() {
                return new MatSnackBarConfig();
            }
            /**
             * Service to dispatch Material Design snack bar messages.
             */
            var MatSnackBar = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _live
                 * @param {?} _injector
                 * @param {?} _breakpointObserver
                 * @param {?} _parentSnackBar
                 * @param {?} _defaultConfig
                 */
                function MatSnackBar(_overlay, _live, _injector, _breakpointObserver, _parentSnackBar, _defaultConfig) {
                    this._overlay = _overlay;
                    this._live = _live;
                    this._injector = _injector;
                    this._breakpointObserver = _breakpointObserver;
                    this._parentSnackBar = _parentSnackBar;
                    this._defaultConfig = _defaultConfig;
                    /**
                     * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).
                     * If there is a parent snack-bar service, all operations should delegate to that parent
                     * via `_openedSnackBarRef`.
                     */
                    this._snackBarRefAtThisLevel = null;
                }
                Object.defineProperty(MatSnackBar.prototype, "_openedSnackBarRef", {
                    /**
                     * Reference to the currently opened snackbar at *any* level.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var parent = this._parentSnackBar;
                        return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._parentSnackBar) {
                            this._parentSnackBar._openedSnackBarRef = value;
                        }
                        else {
                            this._snackBarRefAtThisLevel = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Creates and dispatches a snack bar with a custom component for the content, removing any
                 * currently opened snack bars.
                 *
                 * @template T
                 * @param {?} component Component to be instantiated.
                 * @param {?=} config Extra configuration for the snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype.openFromComponent = function (component, config) {
                    return ( /** @type {?} */(this._attach(component, config)));
                };
                /**
                 * Creates and dispatches a snack bar with a custom template for the content, removing any
                 * currently opened snack bars.
                 *
                 * @param {?} template Template to be instantiated.
                 * @param {?=} config Extra configuration for the snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype.openFromTemplate = function (template, config) {
                    return this._attach(template, config);
                };
                /**
                 * Opens a snackbar with a message and an optional action.
                 * @param {?} message The message to show in the snackbar.
                 * @param {?=} action The label for the snackbar action.
                 * @param {?=} config Additional configuration options for the snackbar.
                 * @return {?}
                 */
                MatSnackBar.prototype.open = function (message, action, config) {
                    if (action === void 0) { action = ''; }
                    /** @type {?} */
                    var _config = Object.assign({}, this._defaultConfig, config);
                    // Since the user doesn't have access to the component, we can
                    // override the data to pass in our own message and action.
                    _config.data = { message: message, action: action };
                    if (!_config.announcementMessage) {
                        _config.announcementMessage = message;
                    }
                    return this.openFromComponent(SimpleSnackBar, _config);
                };
                /**
                 * Dismisses the currently-visible snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype.dismiss = function () {
                    if (this._openedSnackBarRef) {
                        this._openedSnackBarRef.dismiss();
                    }
                };
                /**
                 * @return {?}
                 */
                MatSnackBar.prototype.ngOnDestroy = function () {
                    // Only dismiss the snack bar at the current level on destroy.
                    if (this._snackBarRefAtThisLevel) {
                        this._snackBarRefAtThisLevel.dismiss();
                    }
                };
                /**
                 * Attaches the snack bar container component to the overlay.
                 * @private
                 * @param {?} overlayRef
                 * @param {?} config
                 * @return {?}
                 */
                MatSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injector = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatSnackBarConfig, config]
                    ]));
                    /** @type {?} */
                    var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](MatSnackBarContainer, config.viewContainerRef, injector);
                    /** @type {?} */
                    var containerRef = overlayRef.attach(containerPortal);
                    containerRef.instance.snackBarConfig = config;
                    return containerRef.instance;
                };
                /**
                 * Places a new component or a template as the content of the snack bar container.
                 * @private
                 * @template T
                 * @param {?} content
                 * @param {?=} userConfig
                 * @return {?}
                 */
                MatSnackBar.prototype._attach = function (content, userConfig) {
                    /** @type {?} */
                    var config = Object.assign({}, new MatSnackBarConfig(), this._defaultConfig, userConfig);
                    /** @type {?} */
                    var overlayRef = this._createOverlay(config);
                    /** @type {?} */
                    var container = this._attachSnackBarContainer(overlayRef, config);
                    /** @type {?} */
                    var snackBarRef = new MatSnackBarRef(container, overlayRef);
                    if (content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]) {
                        /** @type {?} */
                        var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["TemplatePortal"](content, ( /** @type {?} */(null)), ( /** @type {?} */({
                            $implicit: config.data,
                            snackBarRef: snackBarRef
                        })));
                        snackBarRef.instance = container.attachTemplatePortal(portal);
                    }
                    else {
                        /** @type {?} */
                        var injector = this._createInjector(config, snackBarRef);
                        /** @type {?} */
                        var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](content, undefined, injector);
                        /** @type {?} */
                        var contentRef = container.attachComponentPortal(portal);
                        // We can't pass this via the injector, because the injector is created earlier.
                        snackBarRef.instance = contentRef.instance;
                    }
                    // Subscribe to the breakpoint observer and attach the mat-snack-bar-handset class as
                    // appropriate. This class is applied to the overlay element because the overlay must expand to
                    // fill the width of the screen for full width snackbars.
                    this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__["Breakpoints"].HandsetPortrait).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(overlayRef.detachments())).subscribe(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state$$1) {
                        /** @type {?} */
                        var classList = overlayRef.overlayElement.classList;
                        /** @type {?} */
                        var className = 'mat-snack-bar-handset';
                        state$$1.matches ? classList.add(className) : classList.remove(className);
                    }));
                    this._animateSnackBar(snackBarRef, config);
                    this._openedSnackBarRef = snackBarRef;
                    return this._openedSnackBarRef;
                };
                /**
                 * Animates the old snack bar out and the new one in.
                 * @private
                 * @param {?} snackBarRef
                 * @param {?} config
                 * @return {?}
                 */
                MatSnackBar.prototype._animateSnackBar = function (snackBarRef, config) {
                    var _this = this;
                    // When the snackbar is dismissed, clear the reference to it.
                    snackBarRef.afterDismissed().subscribe(( /**
                     * @return {?}
                     */function () {
                        // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
                        if (_this._openedSnackBarRef == snackBarRef) {
                            _this._openedSnackBarRef = null;
                        }
                        if (config.announcementMessage) {
                            _this._live.clear();
                        }
                    }));
                    if (this._openedSnackBarRef) {
                        // If a snack bar is already in view, dismiss it and enter the
                        // new snack bar after exit animation is complete.
                        this._openedSnackBarRef.afterDismissed().subscribe(( /**
                         * @return {?}
                         */function () {
                            snackBarRef.containerInstance.enter();
                        }));
                        this._openedSnackBarRef.dismiss();
                    }
                    else {
                        // If no snack bar is in view, enter the new snack bar.
                        snackBarRef.containerInstance.enter();
                    }
                    // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.
                    if (config.duration && config.duration > 0) {
                        snackBarRef.afterOpened().subscribe(( /**
                         * @return {?}
                         */function () { return snackBarRef._dismissAfter(( /** @type {?} */(config.duration))); }));
                    }
                    if (config.announcementMessage) {
                        this._live.announce(config.announcementMessage, config.politeness);
                    }
                };
                /**
                 * Creates a new overlay and places it in the correct location.
                 * @private
                 * @param {?} config The user-specified snack bar config.
                 * @return {?}
                 */
                MatSnackBar.prototype._createOverlay = function (config) {
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["OverlayConfig"]();
                    overlayConfig.direction = config.direction;
                    /** @type {?} */
                    var positionStrategy = this._overlay.position().global();
                    // Set horizontal position.
                    /** @type {?} */
                    var isRtl = config.direction === 'rtl';
                    /** @type {?} */
                    var isLeft = (config.horizontalPosition === 'left' ||
                        (config.horizontalPosition === 'start' && !isRtl) ||
                        (config.horizontalPosition === 'end' && isRtl));
                    /** @type {?} */
                    var isRight = !isLeft && config.horizontalPosition !== 'center';
                    if (isLeft) {
                        positionStrategy.left('0');
                    }
                    else if (isRight) {
                        positionStrategy.right('0');
                    }
                    else {
                        positionStrategy.centerHorizontally();
                    }
                    // Set horizontal position.
                    if (config.verticalPosition === 'top') {
                        positionStrategy.top('0');
                    }
                    else {
                        positionStrategy.bottom('0');
                    }
                    overlayConfig.positionStrategy = positionStrategy;
                    return this._overlay.create(overlayConfig);
                };
                /**
                 * Creates an injector to be used inside of a snack bar component.
                 * @private
                 * @template T
                 * @param {?} config Config that was used to create the snack bar.
                 * @param {?} snackBarRef Reference to the snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype._createInjector = function (config, snackBarRef) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatSnackBarRef, snackBarRef],
                        [MAT_SNACK_BAR_DATA, config.data]
                    ]));
                };
                return MatSnackBar;
            }());
            MatSnackBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: MatSnackBarModule },] },
            ];
            /** @nocollapse */
            MatSnackBar.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["Overlay"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__["LiveAnnouncer"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] },
                { type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__["BreakpointObserver"] },
                { type: MatSnackBar, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: MatSnackBarConfig, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_SNACK_BAR_DEFAULT_OPTIONS,] }] }
            ]; };
            /** @nocollapse */ MatSnackBar.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function MatSnackBar_Factory() { return new MatSnackBar(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["Overlay"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__["LiveAnnouncer"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__["BreakpointObserver"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(MatSnackBar, 12), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(MAT_SNACK_BAR_DEFAULT_OPTIONS)); }, token: MatSnackBar, providedIn: MatSnackBarModule });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=snack-bar.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/sort.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/sort.js ***!
          \********************************************************/
        /*! exports provided: MatSortModule, MatSortHeader, MAT_SORT_HEADER_INTL_PROVIDER_FACTORY, MatSortHeaderIntl, MAT_SORT_HEADER_INTL_PROVIDER, MatSort, matSortAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSortModule", function () { return MatSortModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSortHeader", function () { return MatSortHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SORT_HEADER_INTL_PROVIDER_FACTORY", function () { return MAT_SORT_HEADER_INTL_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSortHeaderIntl", function () { return MatSortHeaderIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SORT_HEADER_INTL_PROVIDER", function () { return MAT_SORT_HEADER_INTL_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSort", function () { return MatSort; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matSortAnimations", function () { return matSortAnimations; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} id
             * @return {?}
             */
            function getSortDuplicateSortableIdError(id) {
                return Error("Cannot have two MatSortables with the same id (" + id + ").");
            }
            /**
             * \@docs-private
             * @return {?}
             */
            function getSortHeaderNotContainedWithinSortError() {
                return Error("MatSortHeader must be placed within a parent element with the MatSort directive.");
            }
            /**
             * \@docs-private
             * @return {?}
             */
            function getSortHeaderMissingIdError() {
                return Error("MatSortHeader must be provided with a unique id.");
            }
            /**
             * \@docs-private
             * @param {?} direction
             * @return {?}
             */
            function getSortInvalidDirectionError(direction) {
                return Error(direction + " is not a valid sort direction ('asc' or 'desc').");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatSort.
            /**
             * \@docs-private
             */
            var MatSortBase = /** @class */ (function () {
                function MatSortBase() {
                }
                return MatSortBase;
            }());
            /** @type {?} */
            var _MatSortMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinInitialized"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisabled"])(MatSortBase));
            /**
             * Container for MatSortables to manage the sort state and provide default sort parameters.
             */
            var MatSort = /** @class */ (function (_super) {
                __extends(MatSort, _super);
                function MatSort() {
                    var _this = _super.apply(this, arguments) || this;
                    /**
                     * Collection of all registered sortables that this directive manages.
                     */
                    _this.sortables = new Map();
                    /**
                     * Used to notify any child components listening to state changes.
                     */
                    _this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /**
                     * The direction to set when an MatSortable is initially sorted.
                     * May be overriden by the MatSortable's sort start.
                     */
                    _this.start = 'asc';
                    _this._direction = '';
                    /**
                     * Event emitted when the user changes either the active sort or sort direction.
                     */
                    _this.sortChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    return _this;
                }
                Object.defineProperty(MatSort.prototype, "direction", {
                    /**
                     * The sort direction of the currently active MatSortable.
                     * @return {?}
                     */
                    get: function () { return this._direction; },
                    /**
                     * @param {?} direction
                     * @return {?}
                     */
                    set: function (direction) {
                        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && direction && direction !== 'asc' && direction !== 'desc') {
                            throw getSortInvalidDirectionError(direction);
                        }
                        this._direction = direction;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSort.prototype, "disableClear", {
                    /**
                     * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
                     * May be overriden by the MatSortable's disable clear input.
                     * @return {?}
                     */
                    get: function () { return this._disableClear; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) { this._disableClear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Register function to be used by the contained MatSortables. Adds the MatSortable to the
                 * collection of MatSortables.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.register = function (sortable) {
                    if (!sortable.id) {
                        throw getSortHeaderMissingIdError();
                    }
                    if (this.sortables.has(sortable.id)) {
                        throw getSortDuplicateSortableIdError(sortable.id);
                    }
                    this.sortables.set(sortable.id, sortable);
                };
                /**
                 * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
                 * collection of contained MatSortables.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.deregister = function (sortable) {
                    this.sortables.delete(sortable.id);
                };
                /**
                 * Sets the active sort id and determines the new sort direction.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.sort = function (sortable) {
                    if (this.active != sortable.id) {
                        this.active = sortable.id;
                        this.direction = sortable.start ? sortable.start : this.start;
                    }
                    else {
                        this.direction = this.getNextSortDirection(sortable);
                    }
                    this.sortChange.emit({ active: this.active, direction: this.direction });
                };
                /**
                 * Returns the next sort direction of the active sortable, checking for potential overrides.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.getNextSortDirection = function (sortable) {
                    if (!sortable) {
                        return '';
                    }
                    // Get the sort direction cycle with the potential sortable overrides.
                    /** @type {?} */
                    var disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;
                    /** @type {?} */
                    var sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
                    // Get and return the next direction in the cycle
                    /** @type {?} */
                    var nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
                    if (nextDirectionIndex >= sortDirectionCycle.length) {
                        nextDirectionIndex = 0;
                    }
                    return sortDirectionCycle[nextDirectionIndex];
                };
                /**
                 * @return {?}
                 */
                MatSort.prototype.ngOnInit = function () {
                    this._markInitialized();
                };
                /**
                 * @return {?}
                 */
                MatSort.prototype.ngOnChanges = function () {
                    this._stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatSort.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                return MatSort;
            }(_MatSortMixinBase));
            MatSort.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matSort]',
                            exportAs: 'matSort',
                            inputs: ['disabled: matSortDisabled']
                        },] },
            ];
            MatSort.propDecorators = {
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortActive',] }],
                start: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortStart',] }],
                direction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortDirection',] }],
                disableClear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortDisableClear',] }],
                sortChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"], args: ['matSortChange',] }]
            };
            /**
             * Returns the sort direction cycle to use given the provided parameters of order and clear.
             * @param {?} start
             * @param {?} disableClear
             * @return {?}
             */
            function getSortDirectionCycle(start, disableClear) {
                /** @type {?} */
                var sortOrder = ['asc', 'desc'];
                if (start == 'desc') {
                    sortOrder.reverse();
                }
                if (!disableClear) {
                    sortOrder.push('');
                }
                return sortOrder;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var SORT_ANIMATION_TRANSITION = _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationDurations"].ENTERING + ' ' +
                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationCurves"].STANDARD_CURVE;
            /**
             * Animations used by MatSort.
             * \@docs-private
             * @type {?}
             */
            var matSortAnimations = {
                /**
                 * Animation that moves the sort indicator.
                 */
                indicator: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('indicator', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0px)' })),
                    // 10px is the height of the sort indicator, minus the width of the pointers
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(10px)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('active-asc <=> active-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION))
                ]),
                /**
                 * Animation that rotates the left pointer of the indicator based on the sorting direction.
                 */
                leftPointer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('leftPointer', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(-45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('active-asc <=> active-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION))
                ]),
                /**
                 * Animation that rotates the right pointer of the indicator based on the sorting direction.
                 */
                rightPointer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('rightPointer', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(-45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('active-asc <=> active-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION))
                ]),
                /**
                 * Animation that controls the arrow opacity.
                 */
                arrowOpacity: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('arrowOpacity', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('desc-to-active, asc-to-active, active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ opacity: 1 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('desc-to-hint, asc-to-hint, hint', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ opacity: .54 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ opacity: 0 })),
                    // Transition between all states except for immediate transitions
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => asc, * => desc, * => active, * => hint, * => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('0ms')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION)),
                ]),
                /**
                 * Animation for the translation of the arrow as a whole. States are separated into two
                 * groups: ones with animations and others that are immediate. Immediate states are asc, desc,
                 * peek, and active. The other states define a specific animation (source-to-destination)
                 * and are determined as a function of their prev user-perceived state and what the next state
                 * should be.
                 */
                arrowPosition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('arrowPosition', [
                    // Hidden Above => Hint Center
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => desc-to-hint, * => desc-to-active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(-25%)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' })
                    ]))),
                    // Hint Center => Hidden Below
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => hint-to-desc, * => active-to-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(25%)' })
                    ]))),
                    // Hidden Below => Hint Center
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => asc-to-hint, * => asc-to-active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(25%)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' })
                    ]))),
                    // Hint Center => Hidden Above
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => hint-to-asc, * => active-to-asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(-25%)' })
                    ]))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('hint-to-desc, active-to-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(-25%)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('hint-to-asc, active-to-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(25%)' })),
                ]),
                /**
                 * Necessary trigger that calls animate on children animations.
                 */
                allowChildren: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('allowChildren', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> *', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["query"])('@*', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animateChild"])(), { optional: true })
                    ])
                ]),
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * To modify the labels and text displayed, create a new instance of MatSortHeaderIntl and
             * include it in a custom provider.
             */
            var MatSortHeaderIntl = /** @class */ (function () {
                function MatSortHeaderIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /**
                     * ARIA label for the sorting button.
                     */
                    this.sortButtonLabel = ( /**
                     * @param {?} id
                     * @return {?}
                     */function (id) {
                        return "Change sorting for " + id;
                    });
                }
                return MatSortHeaderIntl;
            }());
            MatSortHeaderIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatSortHeaderIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function MatSortHeaderIntl_Factory() { return new MatSortHeaderIntl(); }, token: MatSortHeaderIntl, providedIn: "root" });
            /**
             * \@docs-private
             * @param {?} parentIntl
             * @return {?}
             */
            function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {
                return parentIntl || new MatSortHeaderIntl();
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SORT_HEADER_INTL_PROVIDER = {
                // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.
                provide: MatSortHeaderIntl,
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"](), MatSortHeaderIntl]],
                useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to the sort header.
            /**
             * \@docs-private
             */
            var MatSortHeaderBase = /** @class */ (function () {
                function MatSortHeaderBase() {
                }
                return MatSortHeaderBase;
            }());
            /** @type {?} */
            var _MatSortHeaderMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisabled"])(MatSortHeaderBase);
            /**
             * Applies sorting behavior (click to change sort) and styles to an element, including an
             * arrow to display the current sort direction.
             *
             * Must be provided with an id and contained within a parent MatSort directive.
             *
             * If used on header cells in a CdkTable, it will automatically default its id from its containing
             * column definition.
             */
            var MatSortHeader = /** @class */ (function (_super) {
                __extends(MatSortHeader, _super);
                /**
                 * @param {?} _intl
                 * @param {?} changeDetectorRef
                 * @param {?} _sort
                 * @param {?} _columnDef
                 */
                function MatSortHeader(_intl, changeDetectorRef, _sort, _columnDef) {
                    var _this = 
                    // Note that we use a string token for the `_columnDef`, because the value is provided both by
                    // `material/table` and `cdk/table` and we can't have the CDK depending on Material,
                    // and we want to avoid having the sort header depending on the CDK table because
                    // of this single reference.
                    _super.call(this) || this;
                    _this._intl = _intl;
                    _this._sort = _sort;
                    _this._columnDef = _columnDef;
                    /**
                     * Flag set to true when the indicator should be displayed while the sort is not active. Used to
                     * provide an affordance that the header is sortable by showing on focus and hover.
                     */
                    _this._showIndicatorHint = false;
                    /**
                     * The direction the arrow should be facing according to the current state.
                     */
                    _this._arrowDirection = '';
                    /**
                     * Whether the view state animation should show the transition between the `from` and `to` states.
                     */
                    _this._disableViewStateAnimation = false;
                    /**
                     * Sets the position of the arrow that displays when sorted.
                     */
                    _this.arrowPosition = 'after';
                    if (!_sort) {
                        throw getSortHeaderNotContainedWithinSortError();
                    }
                    _this._rerenderSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["merge"])(_sort.sortChange, _sort._stateChanges, _intl.changes)
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        if (_this._isSorted()) {
                            _this._updateArrowDirection();
                        }
                        // If this header was recently active and now no longer sorted, animate away the arrow.
                        if (!_this._isSorted() && _this._viewState && _this._viewState.toState === 'active') {
                            _this._disableViewStateAnimation = false;
                            _this._setAnimationTransitionState({ fromState: 'active', toState: _this._arrowDirection });
                        }
                        changeDetectorRef.markForCheck();
                    }));
                    return _this;
                }
                Object.defineProperty(MatSortHeader.prototype, "disableClear", {
                    /**
                     * Overrides the disable clear value of the containing MatSort for this MatSortable.
                     * @return {?}
                     */
                    get: function () { return this._disableClear; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) { this._disableClear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSortHeader.prototype.ngOnInit = function () {
                    if (!this.id && this._columnDef) {
                        this.id = this._columnDef.name;
                    }
                    // Initialize the direction of the arrow and set the view state to be immediately that state.
                    this._updateArrowDirection();
                    this._setAnimationTransitionState({ toState: this._isSorted() ? 'active' : this._arrowDirection });
                    this._sort.register(this);
                };
                /**
                 * @return {?}
                 */
                MatSortHeader.prototype.ngOnDestroy = function () {
                    this._sort.deregister(this);
                    this._rerenderSubscription.unsubscribe();
                };
                /**
                 * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
                 * user showing what the active sort will become. If set to false, the arrow will fade away.
                 * @param {?} visible
                 * @return {?}
                 */
                MatSortHeader.prototype._setIndicatorHintVisible = function (visible) {
                    // No-op if the sort header is disabled - should not make the hint visible.
                    if (this._isDisabled() && visible) {
                        return;
                    }
                    this._showIndicatorHint = visible;
                    if (!this._isSorted()) {
                        this._updateArrowDirection();
                        if (this._showIndicatorHint) {
                            this._setAnimationTransitionState({ fromState: this._arrowDirection, toState: 'hint' });
                        }
                        else {
                            this._setAnimationTransitionState({ fromState: 'hint', toState: this._arrowDirection });
                        }
                    }
                };
                /**
                 * Sets the animation transition view state for the arrow's position and opacity. If the
                 * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
                 * no animation appears.
                 * @param {?} viewState
                 * @return {?}
                 */
                MatSortHeader.prototype._setAnimationTransitionState = function (viewState) {
                    this._viewState = viewState;
                    // If the animation for arrow position state (opacity/translation) should be disabled,
                    // remove the fromState so that it jumps right to the toState.
                    if (this._disableViewStateAnimation) {
                        this._viewState = { toState: viewState.toState };
                    }
                };
                /**
                 * Triggers the sort on this sort header and removes the indicator hint.
                 * @return {?}
                 */
                MatSortHeader.prototype._handleClick = function () {
                    if (this._isDisabled()) {
                        return;
                    }
                    this._sort.sort(this);
                    // Do not show the animation if the header was already shown in the right position.
                    if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {
                        this._disableViewStateAnimation = true;
                    }
                    // If the arrow is now sorted, animate the arrow into place. Otherwise, animate it away into
                    // the direction it is facing.
                    /** @type {?} */
                    var viewState = this._isSorted() ?
                        { fromState: this._arrowDirection, toState: 'active' } :
                        { fromState: 'active', toState: this._arrowDirection };
                    this._setAnimationTransitionState(viewState);
                    this._showIndicatorHint = false;
                };
                /**
                 * Whether this MatSortHeader is currently sorted in either ascending or descending order.
                 * @return {?}
                 */
                MatSortHeader.prototype._isSorted = function () {
                    return this._sort.active == this.id &&
                        (this._sort.direction === 'asc' || this._sort.direction === 'desc');
                };
                /**
                 * Returns the animation state for the arrow direction (indicator and pointers).
                 * @return {?}
                 */
                MatSortHeader.prototype._getArrowDirectionState = function () {
                    return "" + (this._isSorted() ? 'active-' : '') + this._arrowDirection;
                };
                /**
                 * Returns the arrow position state (opacity, translation).
                 * @return {?}
                 */
                MatSortHeader.prototype._getArrowViewState = function () {
                    /** @type {?} */
                    var fromState = this._viewState.fromState;
                    return (fromState ? fromState + "-to-" : '') + this._viewState.toState;
                };
                /**
                 * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
                 * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
                 * active sorted direction. The reason this is updated through a function is because the direction
                 * should only be changed at specific times - when deactivated but the hint is displayed and when
                 * the sort is active and the direction changes. Otherwise the arrow's direction should linger
                 * in cases such as the sort becoming deactivated but we want to animate the arrow away while
                 * preserving its direction, even though the next sort direction is actually different and should
                 * only be changed once the arrow displays again (hint or activation).
                 * @return {?}
                 */
                MatSortHeader.prototype._updateArrowDirection = function () {
                    this._arrowDirection = this._isSorted() ?
                        this._sort.direction :
                        (this.start || this._sort.start);
                };
                /**
                 * @return {?}
                 */
                MatSortHeader.prototype._isDisabled = function () {
                    return this._sort.disabled || this.disabled;
                };
                /**
                 * Gets the aria-sort attribute that should be applied to this sort header. If this header
                 * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
                 * says that the aria-sort property should only be present on one header at a time, so removing
                 * ensures this is true.
                 * @return {?}
                 */
                MatSortHeader.prototype._getAriaSortAttribute = function () {
                    if (!this._isSorted()) {
                        return null;
                    }
                    return this._sort.direction == 'asc' ? 'ascending' : 'descending';
                };
                /**
                 * Whether the arrow inside the sort header should be rendered.
                 * @return {?}
                 */
                MatSortHeader.prototype._renderArrow = function () {
                    return !this._isDisabled() || this._isSorted();
                };
                return MatSortHeader;
            }(_MatSortHeaderMixinBase));
            MatSortHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: '[mat-sort-header]',
                            exportAs: 'matSortHeader',
                            template: "<div class=\"mat-sort-header-container\" [class.mat-sort-header-sorted]=\"_isSorted()\" [class.mat-sort-header-position-before]=\"arrowPosition == 'before'\"><button class=\"mat-sort-header-button\" type=\"button\" [attr.disabled]=\"_isDisabled() || null\" [attr.aria-label]=\"_intl.sortButtonLabel(id)\" (focus)=\"_setIndicatorHintVisible(true)\" (blur)=\"_setIndicatorHintVisible(false)\"><ng-content></ng-content></button><div class=\"mat-sort-header-arrow\" *ngIf=\"_renderArrow()\" [@arrowOpacity]=\"_getArrowViewState()\" [@arrowPosition]=\"_getArrowViewState()\" [@allowChildren]=\"_getArrowDirectionState()\" (@arrowPosition.start)=\"_disableViewStateAnimation = true\" (@arrowPosition.done)=\"_disableViewStateAnimation = false\"><div class=\"mat-sort-header-stem\"></div><div class=\"mat-sort-header-indicator\" [@indicator]=\"_getArrowDirectionState()\"><div class=\"mat-sort-header-pointer-left\" [@leftPointer]=\"_getArrowDirectionState()\"></div><div class=\"mat-sort-header-pointer-right\" [@rightPointer]=\"_getArrowDirectionState()\"></div><div class=\"mat-sort-header-pointer-middle\"></div></div></div></div>",
                            styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:inherit;outline:0;font:inherit;color:currentColor}.mat-sort-header-button::-moz-focus-inner{border:0}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}@media (-ms-high-contrast:active){.mat-sort-header-stem{width:0;border-left:solid 2px}}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}@media (-ms-high-contrast:active){.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}"],
                            host: {
                                '(click)': '_handleClick()',
                                '(mouseenter)': '_setIndicatorHintVisible(true)',
                                '(mouseleave)': '_setIndicatorHintVisible(false)',
                                '[attr.aria-sort]': '_getAriaSortAttribute()',
                                '[class.mat-sort-header-disabled]': '_isDisabled()',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disabled'],
                            animations: [
                                matSortAnimations.indicator,
                                matSortAnimations.leftPointer,
                                matSortAnimations.rightPointer,
                                matSortAnimations.arrowOpacity,
                                matSortAnimations.arrowPosition,
                                matSortAnimations.allowChildren,
                            ]
                        },] },
            ];
            /** @nocollapse */
            MatSortHeader.ctorParameters = function () { return [
                { type: MatSortHeaderIntl },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: MatSort, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: ['MAT_SORT_HEADER_COLUMN_DEF',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
            ]; };
            MatSortHeader.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['mat-sort-header',] }],
                arrowPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                start: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                disableClear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSortModule = /** @class */ (function () {
                function MatSortModule() {
                }
                return MatSortModule;
            }());
            MatSortModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: [MatSort, MatSortHeader],
                            declarations: [MatSort, MatSortHeader],
                            providers: [MAT_SORT_HEADER_INTL_PROVIDER]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=sort.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/stepper.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/stepper.js ***!
          \***********************************************************/
        /*! exports provided: MatStepperModule, MatStepLabel, MatStep, MatStepper, MatHorizontalStepper, MatVerticalStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MAT_STEPPER_INTL_PROVIDER_FACTORY, MatStepperIntl, MAT_STEPPER_INTL_PROVIDER, matStepperAnimations, MatStepperIcon */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperModule", function () { return MatStepperModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepLabel", function () { return MatStepLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStep", function () { return MatStep; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepper", function () { return MatStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHorizontalStepper", function () { return MatHorizontalStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatVerticalStepper", function () { return MatVerticalStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperNext", function () { return MatStepperNext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperPrevious", function () { return MatStepperPrevious; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepHeader", function () { return MatStepHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER_FACTORY", function () { return MAT_STEPPER_INTL_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperIntl", function () { return MatStepperIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER", function () { return MAT_STEPPER_INTL_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matStepperAnimations", function () { return matStepperAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperIcon", function () { return MatStepperIcon; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/stepper */ "./node_modules/@angular/cdk/esm2015/stepper.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepLabel = /** @class */ (function (_super) {
                __extends(MatStepLabel, _super);
                function MatStepLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepLabel;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepLabel"]));
            MatStepLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matStepLabel]',
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Stepper data that is required for internationalization.
             */
            var MatStepperIntl = /** @class */ (function () {
                function MatStepperIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Label that is rendered below optional steps.
                     */
                    this.optionalLabel = 'Optional';
                }
                return MatStepperIntl;
            }());
            MatStepperIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatStepperIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatStepperIntl_Factory() { return new MatStepperIntl(); }, token: MatStepperIntl, providedIn: "root" });
            /**
             * \@docs-private
             * @param {?} parentIntl
             * @return {?}
             */
            function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl) {
                return parentIntl || new MatStepperIntl();
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_STEPPER_INTL_PROVIDER = {
                provide: MatStepperIntl,
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"](), MatStepperIntl]],
                useFactory: MAT_STEPPER_INTL_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepHeader = /** @class */ (function (_super) {
                __extends(MatStepHeader, _super);
                /**
                 * @param {?} _intl
                 * @param {?} _focusMonitor
                 * @param {?} _elementRef
                 * @param {?} changeDetectorRef
                 */
                function MatStepHeader(_intl, _focusMonitor, _elementRef, changeDetectorRef) {
                    var _this = _super.call(this, _elementRef) || this;
                    _this._intl = _intl;
                    _this._focusMonitor = _focusMonitor;
                    _focusMonitor.monitor(_elementRef, true);
                    _this._intlSubscription = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () { return changeDetectorRef.markForCheck(); }));
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatStepHeader.prototype.ngOnDestroy = function () {
                    this._intlSubscription.unsubscribe();
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Focuses the step header.
                 * @return {?}
                 */
                MatStepHeader.prototype.focus = function () {
                    this._focusMonitor.focusVia(this._elementRef, 'program');
                };
                /**
                 * Returns string label of given step if it is a text label.
                 * @return {?}
                 */
                MatStepHeader.prototype._stringLabel = function () {
                    return this.label instanceof MatStepLabel ? null : this.label;
                };
                /**
                 * Returns MatStepLabel if the label of given step is a template label.
                 * @return {?}
                 */
                MatStepHeader.prototype._templateLabel = function () {
                    return this.label instanceof MatStepLabel ? this.label : null;
                };
                /**
                 * Returns the host HTML element.
                 * @return {?}
                 */
                MatStepHeader.prototype._getHostElement = function () {
                    return this._elementRef.nativeElement;
                };
                /**
                 * Template context variables that are exposed to the `matStepperIcon` instances.
                 * @return {?}
                 */
                MatStepHeader.prototype._getIconContext = function () {
                    return {
                        index: this.index,
                        active: this.active,
                        optional: this.optional
                    };
                };
                /**
                 * @param {?} state
                 * @return {?}
                 */
                MatStepHeader.prototype._getDefaultTextForState = function (state$$1) {
                    if (state$$1 == 'number') {
                        return "" + (this.index + 1);
                    }
                    if (state$$1 == 'edit') {
                        return 'create';
                    }
                    if (state$$1 == 'error') {
                        return 'warning';
                    }
                    return state$$1;
                };
                return MatStepHeader;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepHeader"]));
            MatStepHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-step-header',
                            template: "<div class=\"mat-step-header-ripple\" matRipple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"disableRipple\"></div><div class=\"mat-step-icon-state-{{state}} mat-step-icon\" [class.mat-step-icon-selected]=\"selected\"><div class=\"mat-step-icon-content\" [ngSwitch]=\"!!(iconOverrides && iconOverrides[state])\"><ng-container *ngSwitchCase=\"true\" [ngTemplateOutlet]=\"iconOverrides[state]\" [ngTemplateOutletContext]=\"_getIconContext()\"></ng-container><ng-container *ngSwitchDefault [ngSwitch]=\"state\"><span *ngSwitchCase=\"'number'\">{{_getDefaultTextForState(state)}}</span><mat-icon *ngSwitchDefault>{{_getDefaultTextForState(state)}}</mat-icon></ng-container></div></div><div class=\"mat-step-label\" [class.mat-step-label-active]=\"active\" [class.mat-step-label-selected]=\"selected\" [class.mat-step-label-error]=\"state == 'error'\"><ng-container *ngIf=\"_templateLabel()\" [ngTemplateOutlet]=\"_templateLabel()!.template\"></ng-container><div class=\"mat-step-text-label\" *ngIf=\"_stringLabel()\">{{label}}</div><div class=\"mat-step-optional\" *ngIf=\"optional && state != 'error'\">{{_intl.optionalLabel}}</div><div class=\"mat-step-sub-label-error\" *ngIf=\"state == 'error'\">{{errorMessage}}</div></div>",
                            styles: [".mat-step-header{overflow:hidden;outline:0;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon .mat-icon,.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                            host: {
                                'class': 'mat-step-header',
                                'role': 'tab',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatStepHeader.ctorParameters = function () { return [
                { type: MatStepperIntl },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatStepHeader.propDecorators = {
                state: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                errorMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                iconOverrides: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                optional: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material steppers.
             * \@docs-private
             * @type {?}
             */
            var matStepperAnimations = {
                /**
                 * Animation that transitions the step along the X axis in a horizontal stepper.
                 */
                horizontalStepTransition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('stepTransition', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('previous', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translate3d(-100%, 0, 0)', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'none', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translate3d(100%, 0, 0)', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('500ms cubic-bezier(0.35, 0, 0.25, 1)'))
                ]),
                /**
                 * Animation that transitions the step along the Y axis in a vertical stepper.
                 */
                verticalStepTransition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('stepTransition', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('previous', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '*', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('225ms cubic-bezier(0.4, 0.0, 0.2, 1)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Template to be used to override the icons inside the step header.
             */
            var MatStepperIcon = /** @class */ (function () {
                /**
                 * @param {?} templateRef
                 */
                function MatStepperIcon(templateRef) {
                    this.templateRef = templateRef;
                }
                return MatStepperIcon;
            }());
            MatStepperIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'ng-template[matStepperIcon]',
                        },] },
            ];
            /** @nocollapse */
            MatStepperIcon.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            MatStepperIcon.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['matStepperIcon',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStep = /** @class */ (function (_super) {
                __extends(MatStep, _super);
                /**
                 * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
                 * @param {?} stepper
                 * @param {?} _errorStateMatcher
                 * @param {?=} stepperOptions
                 */
                function MatStep(stepper, _errorStateMatcher, stepperOptions) {
                    var _this = _super.call(this, stepper, stepperOptions) || this;
                    _this._errorStateMatcher = _errorStateMatcher;
                    return _this;
                }
                /**
                 * Custom error state matcher that additionally checks for validity of interacted form.
                 * @param {?} control
                 * @param {?} form
                 * @return {?}
                 */
                MatStep.prototype.isErrorState = function (control, form) {
                    /** @type {?} */
                    var originalErrorState = this._errorStateMatcher.isErrorState(control, form);
                    // Custom error state checks for the validity of form that is not submitted or touched
                    // since user can trigger a form change by calling for another step without directly
                    // interacting with the current form.
                    /** @type {?} */
                    var customErrorState = !!(control && control.invalid && this.interacted);
                    return originalErrorState || customErrorState;
                };
                return MatStep;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStep"]));
            MatStep.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-step',
                            template: "<ng-template><ng-content></ng-content></ng-template>",
                            providers: [{ provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"], useExisting: MatStep }],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            exportAs: 'matStep',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatStep.ctorParameters = function () { return [
                { type: MatStepper, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatStepper; })),] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["STEPPER_GLOBAL_OPTIONS"],] }] }
            ]; };
            MatStep.propDecorators = {
                stepLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatStepLabel, { static: false },] }]
            };
            var MatStepper = /** @class */ (function (_super) {
                __extends(MatStepper, _super);
                function MatStepper() {
                    var _this = _super.apply(this, arguments) || this;
                    /**
                     * Event emitted when the current step is done transitioning in.
                     */
                    _this.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Consumer-specified template-refs to be used to override the header icons.
                     */
                    _this._iconOverrides = {};
                    /**
                     * Stream of animation `done` events when the body expands/collapses.
                     */
                    _this._animationDone = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatStepper.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._icons.forEach(( /**
                     * @param {?} __0
                     * @return {?}
                     */function (_a) {
                        var name = _a.name, templateRef = _a.templateRef;
                        return _this._iconOverrides[name] = templateRef;
                    }));
                    // Mark the component for change detection whenever the content children query changes
                    this._steps.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () { return _this._stateChanged(); }));
                    this._animationDone.pipe(
                    // This needs a `distinctUntilChanged` in order to avoid emitting the same event twice due
                    // to a bug in animations where the `.done` callback gets invoked twice on some browsers.
                    // See https://github.com/angular/angular/issues/24084
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) { return x.fromState === y.fromState && x.toState === y.toState; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if ((( /** @type {?} */(event.toState))) === 'current') {
                            _this.animationDone.emit();
                        }
                    }));
                };
                return MatStepper;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"]));
            MatStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: '[matStepper]', providers: [{ provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatStepper }] },] },
            ];
            MatStepper.propDecorators = {
                _stepHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChildren"], args: [MatStepHeader,] }],
                _steps: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatStep,] }],
                _icons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatStepperIcon,] }],
                animationDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatHorizontalStepper = /** @class */ (function (_super) {
                __extends(MatHorizontalStepper, _super);
                function MatHorizontalStepper() {
                    var _this = _super.apply(this, arguments) || this;
                    /**
                     * Whether the label should display in bottom or end position.
                     */
                    _this.labelPosition = 'end';
                    return _this;
                }
                return MatHorizontalStepper;
            }(MatStepper));
            MatHorizontalStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-horizontal-stepper',
                            exportAs: 'matHorizontalStepper',
                            template: "<div class=\"mat-horizontal-stepper-header-container\"><ng-container *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-horizontal-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() === i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\" [disableRipple]=\"disableRipple\"></mat-step-header><div *ngIf=\"!isLast\" class=\"mat-stepper-horizontal-line\"></div></ng-container></div><div class=\"mat-horizontal-content-container\"><div *ngFor=\"let step of steps; let i = index\" [attr.tabindex]=\"selectedIndex === i ? 0 : null\" class=\"mat-horizontal-stepper-content\" role=\"tabpanel\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div>",
                            styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                            inputs: ['selectedIndex'],
                            host: {
                                'class': 'mat-stepper-horizontal',
                                '[class.mat-stepper-label-position-end]': 'labelPosition == "end"',
                                '[class.mat-stepper-label-position-bottom]': 'labelPosition == "bottom"',
                                'aria-orientation': 'horizontal',
                                'role': 'tablist',
                            },
                            animations: [matStepperAnimations.horizontalStepTransition],
                            providers: [
                                { provide: MatStepper, useExisting: MatHorizontalStepper },
                                { provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatHorizontalStepper }
                            ],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            MatHorizontalStepper.propDecorators = {
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatVerticalStepper = /** @class */ (function (_super) {
                __extends(MatVerticalStepper, _super);
                /**
                 * @param {?} dir
                 * @param {?} changeDetectorRef
                 * @param {?=} elementRef
                 * @param {?=} _document
                 */
                function MatVerticalStepper(dir, changeDetectorRef, 
                // @breaking-change 8.0.0 `elementRef` and `_document` parameters to become required.
                elementRef, _document) {
                    var _this = _super.call(this, dir, changeDetectorRef, elementRef, _document) || this;
                    _this._orientation = 'vertical';
                    return _this;
                }
                return MatVerticalStepper;
            }(MatStepper));
            MatVerticalStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-vertical-stepper',
                            exportAs: 'matVerticalStepper',
                            template: "<div class=\"mat-step\" *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-vertical-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() == i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex === i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\" [disableRipple]=\"disableRipple\"></mat-step-header><div class=\"mat-vertical-content-container\" [class.mat-stepper-vertical-line]=\"!isLast\"><div class=\"mat-vertical-stepper-content\" role=\"tabpanel\" [attr.tabindex]=\"selectedIndex === i ? 0 : null\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><div class=\"mat-vertical-content\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div></div></div>",
                            styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                            inputs: ['selectedIndex'],
                            host: {
                                'class': 'mat-stepper-vertical',
                                'aria-orientation': 'vertical',
                                'role': 'tablist',
                            },
                            animations: [matStepperAnimations.verticalStepTransition],
                            providers: [
                                { provide: MatStepper, useExisting: MatVerticalStepper },
                                { provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatVerticalStepper }
                            ],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatVerticalStepper.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Button that moves to the next step in a stepper workflow.
             */
            var MatStepperNext = /** @class */ (function (_super) {
                __extends(MatStepperNext, _super);
                function MatStepperNext() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepperNext;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperNext"]));
            MatStepperNext.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[matStepperNext]',
                            host: {
                                '[type]': 'type',
                            },
                            inputs: ['type']
                        },] },
            ];
            /**
             * Button that moves to the previous step in a stepper workflow.
             */
            var MatStepperPrevious = /** @class */ (function (_super) {
                __extends(MatStepperPrevious, _super);
                function MatStepperPrevious() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepperPrevious;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperPrevious"]));
            MatStepperPrevious.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[matStepperPrevious]',
                            host: {
                                '[type]': 'type',
                            },
                            inputs: ['type']
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepperModule = /** @class */ (function () {
                function MatStepperModule() {
                }
                return MatStepperModule;
            }());
            MatStepperModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_9__["PortalModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButtonModule"],
                                _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperModule"],
                                _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__["MatIconModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatRippleModule"],
                            ],
                            exports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                                MatHorizontalStepper,
                                MatVerticalStepper,
                                MatStep,
                                MatStepLabel,
                                MatStepper,
                                MatStepperNext,
                                MatStepperPrevious,
                                MatStepHeader,
                                MatStepperIcon,
                            ],
                            declarations: [
                                MatHorizontalStepper,
                                MatVerticalStepper,
                                MatStep,
                                MatStepLabel,
                                MatStepper,
                                MatStepperNext,
                                MatStepperPrevious,
                                MatStepHeader,
                                MatStepperIcon,
                            ],
                            providers: [MAT_STEPPER_INTL_PROVIDER, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"]],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=stepper.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/table.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/table.js ***!
          \*********************************************************/
        /*! exports provided: MatTableModule, MatCellDef, MatHeaderCellDef, MatFooterCellDef, MatColumnDef, MatHeaderCell, MatFooterCell, MatCell, MatTable, MatHeaderRowDef, MatFooterRowDef, MatRowDef, MatHeaderRow, MatFooterRow, MatRow, MatTableDataSource, MatTextColumn */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTableModule", function () { return MatTableModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCellDef", function () { return MatCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderCellDef", function () { return MatHeaderCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterCellDef", function () { return MatFooterCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatColumnDef", function () { return MatColumnDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderCell", function () { return MatHeaderCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterCell", function () { return MatFooterCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCell", function () { return MatCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTable", function () { return MatTable; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderRowDef", function () { return MatHeaderRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterRowDef", function () { return MatFooterRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRowDef", function () { return MatRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderRow", function () { return MatHeaderRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterRow", function () { return MatFooterRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRow", function () { return MatRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTableDataSource", function () { return MatTableDataSource; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTextColumn", function () { return MatTextColumn; });
            /* harmony import */ var _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/table */ "./node_modules/@angular/cdk/esm2015/table.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Wrapper for the CdkTable with Material design styles.
             * @template T
             */
            var MatTable = /** @class */ (function (_super) {
                __extends(MatTable, _super);
                function MatTable() {
                    var _this = _super.apply(this, arguments) || this;
                    /**
                     * Overrides the sticky CSS class set by the `CdkTable`.
                     */
                    _this.stickyCssClass = 'mat-table-sticky';
                    return _this;
                }
                return MatTable;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTable"]));
            MatTable.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-table, table[mat-table]',
                            exportAs: 'matTable',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_TABLE_TEMPLATE"],
                            styles: ["mat-table{display:block}mat-header-row{min-height:56px}mat-footer-row,mat-row{min-height:48px}mat-footer-row,mat-header-row,mat-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-footer-row::after,mat-header-row::after,mat-row::after{display:inline-block;min-height:inherit;content:''}mat-cell:first-of-type,mat-footer-cell:first-of-type,mat-header-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type,[dir=rtl] mat-footer-cell:first-of-type,[dir=rtl] mat-header-cell:first-of-type{padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-footer-cell:last-of-type,mat-header-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type,[dir=rtl] mat-footer-cell:last-of-type,[dir=rtl] mat-header-cell:last-of-type{padding-right:0;padding-left:24px}mat-cell,mat-footer-cell,mat-header-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-footer-row,tr.mat-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}td.mat-cell,td.mat-footer-cell,th.mat-header-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type,th.mat-header-cell:first-of-type{padding-left:24px}[dir=rtl] td.mat-cell:first-of-type,[dir=rtl] td.mat-footer-cell:first-of-type,[dir=rtl] th.mat-header-cell:first-of-type{padding-left:0;padding-right:24px}td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type,th.mat-header-cell:last-of-type{padding-right:24px}[dir=rtl] td.mat-cell:last-of-type,[dir=rtl] td.mat-footer-cell:last-of-type,[dir=rtl] th.mat-header-cell:last-of-type{padding-right:0;padding-left:24px}"],
                            host: {
                                'class': 'mat-table',
                            },
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTable"], useExisting: MatTable }],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Cell definition for the mat-table.
             * Captures the template of a column's data row cell as well as cell-specific properties.
             */
            var MatCellDef = /** @class */ (function (_super) {
                __extends(MatCellDef, _super);
                function MatCellDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatCellDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkCellDef"]));
            MatCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matCellDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkCellDef"], useExisting: MatCellDef }]
                        },] },
            ];
            /**
             * Header cell definition for the mat-table.
             * Captures the template of a column's header cell and as well as cell-specific properties.
             */
            var MatHeaderCellDef = /** @class */ (function (_super) {
                __extends(MatHeaderCellDef, _super);
                function MatHeaderCellDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatHeaderCellDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderCellDef"]));
            MatHeaderCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matHeaderCellDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderCellDef"], useExisting: MatHeaderCellDef }]
                        },] },
            ];
            /**
             * Footer cell definition for the mat-table.
             * Captures the template of a column's footer cell and as well as cell-specific properties.
             */
            var MatFooterCellDef = /** @class */ (function (_super) {
                __extends(MatFooterCellDef, _super);
                function MatFooterCellDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatFooterCellDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterCellDef"]));
            MatFooterCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matFooterCellDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterCellDef"], useExisting: MatFooterCellDef }]
                        },] },
            ];
            /**
             * Column definition for the mat-table.
             * Defines a set of cells available for a table column.
             */
            var MatColumnDef = /** @class */ (function (_super) {
                __extends(MatColumnDef, _super);
                function MatColumnDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatColumnDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"]));
            MatColumnDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matColumnDef]',
                            providers: [
                                { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"], useExisting: MatColumnDef },
                                { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: MatColumnDef }
                            ],
                        },] },
            ];
            MatColumnDef.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matColumnDef',] }],
                sticky: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                stickyEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * Header cell template container that adds the right classes and role.
             */
            var MatHeaderCell = /** @class */ (function (_super) {
                __extends(MatHeaderCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function MatHeaderCell(columnDef, elementRef) {
                    var _this = _super.call(this, columnDef, elementRef) || this;
                    elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
                    return _this;
                }
                return MatHeaderCell;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderCell"]));
            MatHeaderCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-header-cell, th[mat-header-cell]',
                            host: {
                                'class': 'mat-header-cell',
                                'role': 'columnheader',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatHeaderCell.ctorParameters = function () { return [
                { type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Footer cell template container that adds the right classes and role.
             */
            var MatFooterCell = /** @class */ (function (_super) {
                __extends(MatFooterCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function MatFooterCell(columnDef, elementRef) {
                    var _this = _super.call(this, columnDef, elementRef) || this;
                    elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
                    return _this;
                }
                return MatFooterCell;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterCell"]));
            MatFooterCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-footer-cell, td[mat-footer-cell]',
                            host: {
                                'class': 'mat-footer-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatFooterCell.ctorParameters = function () { return [
                { type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Cell template container that adds the right classes and role.
             */
            var MatCell = /** @class */ (function (_super) {
                __extends(MatCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function MatCell(columnDef, elementRef) {
                    var _this = _super.call(this, columnDef, elementRef) || this;
                    elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
                    return _this;
                }
                return MatCell;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkCell"]));
            MatCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-cell, td[mat-cell]',
                            host: {
                                'class': 'mat-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatCell.ctorParameters = function () { return [
                { type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Header row definition for the mat-table.
             * Captures the header row's template and other header properties such as the columns to display.
             */
            var MatHeaderRowDef = /** @class */ (function (_super) {
                __extends(MatHeaderRowDef, _super);
                function MatHeaderRowDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatHeaderRowDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRowDef"]));
            MatHeaderRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matHeaderRowDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRowDef"], useExisting: MatHeaderRowDef }],
                            inputs: ['columns: matHeaderRowDef', 'sticky: matHeaderRowDefSticky'],
                        },] },
            ];
            /**
             * Footer row definition for the mat-table.
             * Captures the footer row's template and other footer properties such as the columns to display.
             */
            var MatFooterRowDef = /** @class */ (function (_super) {
                __extends(MatFooterRowDef, _super);
                function MatFooterRowDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatFooterRowDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRowDef"]));
            MatFooterRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matFooterRowDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRowDef"], useExisting: MatFooterRowDef }],
                            inputs: ['columns: matFooterRowDef', 'sticky: matFooterRowDefSticky'],
                        },] },
            ];
            /**
             * Data row definition for the mat-table.
             * Captures the data row's template and other properties such as the columns to display and
             * a when predicate that describes when this row should be used.
             * @template T
             */
            var MatRowDef = /** @class */ (function (_super) {
                __extends(MatRowDef, _super);
                function MatRowDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatRowDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRowDef"]));
            MatRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matRowDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRowDef"], useExisting: MatRowDef }],
                            inputs: ['columns: matRowDefColumns', 'when: matRowDefWhen'],
                        },] },
            ];
            /**
             * Footer template container that contains the cell outlet. Adds the right class and role.
             */
            var MatHeaderRow = /** @class */ (function (_super) {
                __extends(MatHeaderRow, _super);
                function MatHeaderRow() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatHeaderRow;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRow"]));
            MatHeaderRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-header-row, tr[mat-header-row]',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_ROW_TEMPLATE"],
                            host: {
                                'class': 'mat-header-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            exportAs: 'matHeaderRow',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRow"], useExisting: MatHeaderRow }],
                        },] },
            ];
            /**
             * Footer template container that contains the cell outlet. Adds the right class and role.
             */
            var MatFooterRow = /** @class */ (function (_super) {
                __extends(MatFooterRow, _super);
                function MatFooterRow() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatFooterRow;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRow"]));
            MatFooterRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-footer-row, tr[mat-footer-row]',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_ROW_TEMPLATE"],
                            host: {
                                'class': 'mat-footer-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            exportAs: 'matFooterRow',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRow"], useExisting: MatFooterRow }],
                        },] },
            ];
            /**
             * Data row template container that contains the cell outlet. Adds the right class and role.
             */
            var MatRow = /** @class */ (function (_super) {
                __extends(MatRow, _super);
                function MatRow() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatRow;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRow"]));
            MatRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-row, tr[mat-row]',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_ROW_TEMPLATE"],
                            host: {
                                'class': 'mat-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            exportAs: 'matRow',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRow"], useExisting: MatRow }],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Column that simply shows text content for the header and row cells. Assumes that the table
             * is using the native table implementation (`<table>`).
             *
             * By default, the name of this column will be the header text and data property accessor.
             * The header text can be overridden with the `headerText` input. Cell values can be overridden with
             * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
             * input.
             * @template T
             */
            var MatTextColumn = /** @class */ (function (_super) {
                __extends(MatTextColumn, _super);
                function MatTextColumn() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTextColumn;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTextColumn"]));
            MatTextColumn.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-text-column',
                            template: "\n    <ng-container matColumnDef>\n      <th mat-header-cell *matHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td mat-cell *matCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  ",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // Change detection is intentionally not set to OnPush. This component's template will be provided
                            // to the table to be inserted into its view. This is problematic when change detection runs since
                            // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
                            // mean's the template in the table's view will not have the updated value (and in fact will cause
                            // an ExpressionChangedAfterItHasBeenCheckedError).
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var EXPORTED_DECLARATIONS = [
                // Table
                MatTable,
                // Template defs
                MatHeaderCellDef,
                MatHeaderRowDef,
                MatColumnDef,
                MatCellDef,
                MatRowDef,
                MatFooterCellDef,
                MatFooterRowDef,
                // Cell directives
                MatHeaderCell,
                MatCell,
                MatFooterCell,
                // Row directives
                MatHeaderRow,
                MatRow,
                MatFooterRow,
                MatTextColumn,
            ];
            var MatTableModule = /** @class */ (function () {
                function MatTableModule() {
                }
                return MatTableModule;
            }());
            MatTableModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTableModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"],
                            ],
                            exports: EXPORTED_DECLARATIONS,
                            declarations: EXPORTED_DECLARATIONS,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to
             * flaky browser support and the value not being defined in Closure's typings.
             * @type {?}
             */
            var MAX_SAFE_INTEGER = 9007199254740991;
            /**
             * Data source that accepts a client-side data array and includes native support of filtering,
             * sorting (using MatSort), and pagination (using MatPaginator).
             *
             * Allows for sort customization by overriding sortingDataAccessor, which defines how data
             * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,
             * which defines how row data is converted to a string for filter matching.
             *
             * **Note:** This class is meant to be a simple data source to help you get started. As such
             * it isn't equipped to handle some more advanced cases like robust i18n support or server-side
             * interactions. If your app needs to support more advanced use cases, consider implementing your
             * own `DataSource`.
             * @template T
             */
            var MatTableDataSource = /** @class */ (function (_super) {
                __extends(MatTableDataSource, _super);
                /**
                 * @param {?=} initialData
                 */
                function MatTableDataSource(initialData) {
                    if (initialData === void 0) { initialData = []; }
                    var _this = _super.call(this) || this;
                    /**
                     * Stream emitting render data to the table (depends on ordered data changes).
                     */
                    _this._renderData = new rxjs__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"]([]);
                    /**
                     * Stream that emits when a new filter string is set on the data source.
                     */
                    _this._filter = new rxjs__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"]('');
                    /**
                     * Used to react to internal changes of the paginator that are made by the data source itself.
                     */
                    _this._internalPageChanges = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Subscription to the changes that should trigger an update to the table's rendered rows, such
                     * as filtering, sorting, pagination, or base data changes.
                     */
                    _this._renderChangesSubscription = rxjs__WEBPACK_IMPORTED_MODULE_5__["Subscription"].EMPTY;
                    /**
                     * Data accessor function that is used for accessing data properties for sorting through
                     * the default sortData function.
                     * This default function assumes that the sort header IDs (which defaults to the column name)
                     * matches the data's properties (e.g. column Xyz represents data['Xyz']).
                     * May be set to a custom function for different behavior.
                     * @param data Data object that is being accessed.
                     * @param sortHeaderId The name of the column that represents the data.
                     */
                    _this.sortingDataAccessor = ( /**
                     * @param {?} data
                     * @param {?} sortHeaderId
                     * @return {?}
                     */function (data, sortHeaderId) {
                        /** @type {?} */
                        var value = (( /** @type {?} */(data)))[sortHeaderId];
                        if (Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__["_isNumberValue"])(value)) {
                            /** @type {?} */
                            var numberValue = Number(value);
                            // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
                            // leave them as strings. For more info: https://goo.gl/y5vbSg
                            return numberValue < MAX_SAFE_INTEGER ? numberValue : value;
                        }
                        return value;
                    });
                    /**
                     * Gets a sorted copy of the data array based on the state of the MatSort. Called
                     * after changes are made to the filtered data or when sort changes are emitted from MatSort.
                     * By default, the function retrieves the active sort and its direction and compares data
                     * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation
                     * of data ordering.
                     * @param data The array of data that should be sorted.
                     * @param sort The connected MatSort that holds the current sort state.
                     */
                    _this.sortData = ( /**
                     * @param {?} data
                     * @param {?} sort
                     * @return {?}
                     */function (data, sort) {
                        /** @type {?} */
                        var active = sort.active;
                        /** @type {?} */
                        var direction = sort.direction;
                        if (!active || direction == '') {
                            return data;
                        }
                        return data.sort(( /**
                         * @param {?} a
                         * @param {?} b
                         * @return {?}
                         */function (a, b) {
                            /** @type {?} */
                            var valueA = _this.sortingDataAccessor(a, active);
                            /** @type {?} */
                            var valueB = _this.sortingDataAccessor(b, active);
                            // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if
                            // one value exists while the other doesn't. In this case, existing value should come last.
                            // This avoids inconsistent results when comparing values to undefined/null.
                            // If neither value exists, return 0 (equal).
                            /** @type {?} */
                            var comparatorResult = 0;
                            if (valueA != null && valueB != null) {
                                // Check if one value is greater than the other; if equal, comparatorResult should remain 0.
                                if (valueA > valueB) {
                                    comparatorResult = 1;
                                }
                                else if (valueA < valueB) {
                                    comparatorResult = -1;
                                }
                            }
                            else if (valueA != null) {
                                comparatorResult = 1;
                            }
                            else if (valueB != null) {
                                comparatorResult = -1;
                            }
                            return comparatorResult * (direction == 'asc' ? 1 : -1);
                        }));
                    });
                    /**
                     * Checks if a data object matches the data source's filter string. By default, each data object
                     * is converted to a string of its properties and returns true if the filter has
                     * at least one occurrence in that string. By default, the filter string has its whitespace
                     * trimmed and the match is case-insensitive. May be overridden for a custom implementation of
                     * filter matching.
                     * @param data Data object used to check against the filter.
                     * @param filter Filter string that has been set on the data source.
                     * @return Whether the filter matches against the data
                     */
                    _this.filterPredicate = ( /**
                     * @param {?} data
                     * @param {?} filter
                     * @return {?}
                     */function (data, filter) {
                        // Transform the data into a lowercase string of all property values.
                        /** @type {?} */
                        var dataStr = Object.keys(data).reduce(( /**
                         * @param {?} currentTerm
                         * @param {?} key
                         * @return {?}
                         */function (currentTerm, key) {
                            // Use an obscure Unicode character to delimit the words in the concatenated string.
                            // This avoids matches where the values of two columns combined will match the user's query
                            // (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something
                            // that has a very low chance of being typed in by somebody in a text field. This one in
                            // particular is "White up-pointing triangle with dot" from
                            // https://en.wikipedia.org/wiki/List_of_Unicode_characters
                            return currentTerm + (( /** @type {?} */(data)))[key] + '◬';
                        }), '').toLowerCase();
                        // Transform the filter by converting it to lowercase and removing whitespace.
                        /** @type {?} */
                        var transformedFilter = filter.trim().toLowerCase();
                        return dataStr.indexOf(transformedFilter) != -1;
                    });
                    _this._data = new rxjs__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"](initialData);
                    _this._updateChangeSubscription();
                    return _this;
                }
                Object.defineProperty(MatTableDataSource.prototype, "data", {
                    /**
                     * Array of data that should be rendered by the table, where each object represents one row.
                     * @return {?}
                     */
                    get: function () { return this._data.value; },
                    /**
                     * @param {?} data
                     * @return {?}
                     */
                    set: function (data) { this._data.next(data); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTableDataSource.prototype, "filter", {
                    /**
                     * Filter term that should be used to filter out objects from the data array. To override how
                     * data objects match to this filter string, provide a custom function for filterPredicate.
                     * @return {?}
                     */
                    get: function () { return this._filter.value; },
                    /**
                     * @param {?} filter
                     * @return {?}
                     */
                    set: function (filter) { this._filter.next(filter); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTableDataSource.prototype, "sort", {
                    /**
                     * Instance of the MatSort directive used by the table to control its sorting. Sort changes
                     * emitted by the MatSort will trigger an update to the table's rendered data.
                     * @return {?}
                     */
                    get: function () { return this._sort; },
                    /**
                     * @param {?} sort
                     * @return {?}
                     */
                    set: function (sort) {
                        this._sort = sort;
                        this._updateChangeSubscription();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTableDataSource.prototype, "paginator", {
                    /**
                     * Instance of the MatPaginator component used by the table to control what page of the data is
                     * displayed. Page changes emitted by the MatPaginator will trigger an update to the
                     * table's rendered data.
                     *
                     * Note that the data source uses the paginator's properties to calculate which page of data
                     * should be displayed. If the paginator receives its properties as template inputs,
                     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
                     * initialized before assigning it to this data source.
                     * @return {?}
                     */
                    get: function () { return this._paginator; },
                    /**
                     * @param {?} paginator
                     * @return {?}
                     */
                    set: function (paginator) {
                        this._paginator = paginator;
                        this._updateChangeSubscription();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Subscribe to changes that should trigger an update to the table's rendered rows. When the
                 * changes occur, process the current state of the filter, sort, and pagination along with
                 * the provided base data and send it to the table for rendering.
                 * @return {?}
                 */
                MatTableDataSource.prototype._updateChangeSubscription = function () {
                    var _this = this;
                    // Sorting and/or pagination should be watched if MatSort and/or MatPaginator are provided.
                    // The events should emit whenever the component emits a change or initializes, or if no
                    // component is provided, a stream with just a null event should be provided.
                    // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the
                    // pipeline can progress to the next step. Note that the value from these streams are not used,
                    // they purely act as a signal to progress in the pipeline.
                    /** @type {?} */
                    var sortChange = this._sort ?
                        ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"])(this._sort.sortChange, this._sort.initialized))) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["of"])(null);
                    /** @type {?} */
                    var pageChange = this._paginator ?
                        ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"])(this._paginator.page, this._internalPageChanges, this._paginator.initialized))) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["of"])(null);
                    /** @type {?} */
                    var dataStream = this._data;
                    // Watch for base data or filter changes to provide a filtered set of data.
                    /** @type {?} */
                    var filteredData = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["combineLatest"])([dataStream, this._filter])
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(( /**
                 * @param {?} __0
                 * @return {?}
                 */function (_a) {
                        var data = _a[0];
                        return _this._filterData(data);
                    })));
                    // Watch for filtered data or sort changes to provide an ordered set of data.
                    /** @type {?} */
                    var orderedData = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["combineLatest"])([filteredData, sortChange])
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(( /**
                 * @param {?} __0
                 * @return {?}
                 */function (_a) {
                        var data = _a[0];
                        return _this._orderData(data);
                    })));
                    // Watch for ordered data or page changes to provide a paged set of data.
                    /** @type {?} */
                    var paginatedData = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["combineLatest"])([orderedData, pageChange])
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(( /**
                 * @param {?} __0
                 * @return {?}
                 */function (_a) {
                        var data = _a[0];
                        return _this._pageData(data);
                    })));
                    // Watched for paged data changes and send the result to the table to render.
                    this._renderChangesSubscription.unsubscribe();
                    this._renderChangesSubscription = paginatedData.subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (/**
                     * @param {?} data
                     * @return {?}
                     */ data) { return _this._renderData.next(data); }));
                };
                /**
                 * Returns a filtered data array where each filter object contains the filter string within
                 * the result of the filterTermAccessor function. If no filter is set, returns the data array
                 * as provided.
                 * @param {?} data
                 * @return {?}
                 */
                MatTableDataSource.prototype._filterData = function (data) {
                    var _this = this;
                    // If there is a filter string, filter out data that does not contain it.
                    // Each data object is converted to a string using the function defined by filterTermAccessor.
                    // May be overridden for customization.
                    this.filteredData =
                        !this.filter ? data : data.filter(( /**
                         * @param {?} obj
                         * @return {?}
                         */function (/**
                         * @param {?} obj
                         * @return {?}
                         */ obj) { return _this.filterPredicate(obj, _this.filter); }));
                    if (this.paginator) {
                        this._updatePaginator(this.filteredData.length);
                    }
                    return this.filteredData;
                };
                /**
                 * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
                 * data array as provided. Uses the default data accessor for data lookup, unless a
                 * sortDataAccessor function is defined.
                 * @param {?} data
                 * @return {?}
                 */
                MatTableDataSource.prototype._orderData = function (data) {
                    // If there is no active sort or direction, return the data without trying to sort.
                    if (!this.sort) {
                        return data;
                    }
                    return this.sortData(data.slice(), this.sort);
                };
                /**
                 * Returns a paged slice of the provided data array according to the provided MatPaginator's page
                 * index and length. If there is no paginator provided, returns the data array as provided.
                 * @param {?} data
                 * @return {?}
                 */
                MatTableDataSource.prototype._pageData = function (data) {
                    if (!this.paginator) {
                        return data;
                    }
                    /** @type {?} */
                    var startIndex = this.paginator.pageIndex * this.paginator.pageSize;
                    return data.slice(startIndex, startIndex + this.paginator.pageSize);
                };
                /**
                 * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
                 * index does not exceed the paginator's last page. Values are changed in a resolved promise to
                 * guard against making property changes within a round of change detection.
                 * @param {?} filteredDataLength
                 * @return {?}
                 */
                MatTableDataSource.prototype._updatePaginator = function (filteredDataLength) {
                    var _this = this;
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var paginator = _this.paginator;
                        if (!paginator) {
                            return;
                        }
                        paginator.length = filteredDataLength;
                        // If the page index is set beyond the page, reduce it to the last page.
                        if (paginator.pageIndex > 0) {
                            /** @type {?} */
                            var lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;
                            /** @type {?} */
                            var newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);
                            if (newPageIndex !== paginator.pageIndex) {
                                paginator.pageIndex = newPageIndex;
                                // Since the paginator only emits after user-generated changes,
                                // we need our own stream so we know to should re-render the data.
                                _this._internalPageChanges.next();
                            }
                        }
                    }));
                };
                /**
                 * Used by the MatTable. Called when it connects to the data source.
                 * \@docs-private
                 * @return {?}
                 */
                MatTableDataSource.prototype.connect = function () { return this._renderData; };
                /**
                 * Used by the MatTable. Called when it is destroyed. No-op.
                 * \@docs-private
                 * @return {?}
                 */
                MatTableDataSource.prototype.disconnect = function () { };
                return MatTableDataSource;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["DataSource"]));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=table.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/tabs.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/tabs.js ***!
          \********************************************************/
        /*! exports provided: MatTabsModule, MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, _MatTabBodyBase, MatTabBodyPortal, MatTabHeader, _MatTabHeaderBase, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, _MatTabNavBase, _MatTabLinkBase, MatTabContent, MatTabChangeEvent, MAT_TABS_CONFIG, _MatTabGroupBase, MatTabGroup, matTabsAnimations, ɵa24, ɵb24 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabsModule", function () { return MatTabsModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatInkBar", function () { return MatInkBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MAT_INK_BAR_POSITIONER", function () { return _MAT_INK_BAR_POSITIONER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabBody", function () { return MatTabBody; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabBodyBase", function () { return _MatTabBodyBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabBodyPortal", function () { return MatTabBodyPortal; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabHeader", function () { return MatTabHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabHeaderBase", function () { return _MatTabHeaderBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabLabelWrapper", function () { return MatTabLabelWrapper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTab", function () { return MatTab; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabLabel", function () { return MatTabLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabNav", function () { return MatTabNav; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabLink", function () { return MatTabLink; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabNavBase", function () { return _MatTabNavBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabLinkBase", function () { return _MatTabLinkBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabContent", function () { return MatTabContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabChangeEvent", function () { return MatTabChangeEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TABS_CONFIG", function () { return MAT_TABS_CONFIG; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatTabGroupBase", function () { return _MatTabGroupBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTabGroup", function () { return MatTabGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matTabsAnimations", function () { return matTabsAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa24", function () { return _MAT_INK_BAR_POSITIONER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb24", function () { return MatPaginatedTabHeader; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token for the MatInkBar's Positioner.
             * @type {?}
             */
            var _MAT_INK_BAR_POSITIONER = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MatInkBarPositioner', {
                providedIn: 'root',
                factory: _MAT_INK_BAR_POSITIONER_FACTORY
            });
            /**
             * The default positioner function for the MatInkBar.
             * \@docs-private
             * @return {?}
             */
            function _MAT_INK_BAR_POSITIONER_FACTORY() {
                /** @type {?} */
                var method = ( /**
                 * @param {?} element
                 * @return {?}
                 */function (element) { return ({
                    left: element ? (element.offsetLeft || 0) + 'px' : '0',
                    width: element ? (element.offsetWidth || 0) + 'px' : '0',
                }); });
                return method;
            }
            /**
             * The ink-bar is used to display and animate the line underneath the current active tab label.
             * \@docs-private
             */
            var MatInkBar = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} _inkBarPositioner
                 * @param {?=} _animationMode
                 */
                function MatInkBar(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    this._inkBarPositioner = _inkBarPositioner;
                    this._animationMode = _animationMode;
                }
                /**
                 * Calculates the styles from the provided element in order to align the ink-bar to that element.
                 * Shows the ink bar if previously set as hidden.
                 * @param {?} element
                 * @return {?}
                 */
                MatInkBar.prototype.alignToElement = function (element) {
                    var _this = this;
                    this.show();
                    if (typeof requestAnimationFrame !== 'undefined') {
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () { return _this._setStyles(element); }));
                        }));
                    }
                    else {
                        this._setStyles(element);
                    }
                };
                /**
                 * Shows the ink bar.
                 * @return {?}
                 */
                MatInkBar.prototype.show = function () {
                    this._elementRef.nativeElement.style.visibility = 'visible';
                };
                /**
                 * Hides the ink bar.
                 * @return {?}
                 */
                MatInkBar.prototype.hide = function () {
                    this._elementRef.nativeElement.style.visibility = 'hidden';
                };
                /**
                 * Sets the proper styles to the ink bar element.
                 * @private
                 * @param {?} element
                 * @return {?}
                 */
                MatInkBar.prototype._setStyles = function (element) {
                    /** @type {?} */
                    var positions = this._inkBarPositioner(element);
                    /** @type {?} */
                    var inkBar = this._elementRef.nativeElement;
                    inkBar.style.left = positions.left;
                    inkBar.style.width = positions.width;
                };
                return MatInkBar;
            }());
            MatInkBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-ink-bar',
                            host: {
                                'class': 'mat-ink-bar',
                                '[class._mat-animation-noopable]': "_animationMode === 'NoopAnimations'",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatInkBar.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_MAT_INK_BAR_POSITIONER,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Decorates the `ng-template` tags and reads out the template from it.
             */
            var MatTabContent = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function MatTabContent(template) {
                    this.template = template;
                }
                return MatTabContent;
            }());
            MatTabContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: '[matTabContent]' },] },
            ];
            /** @nocollapse */
            MatTabContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to flag tab labels for use with the portal directive
             */
            var MatTabLabel = /** @class */ (function (_super) {
                __extends(MatTabLabel, _super);
                function MatTabLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTabLabel;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["CdkPortal"]));
            MatTabLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-tab-label], [matTabLabel]',
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatTab.
            /**
             * \@docs-private
             */
            var MatTabBase = /** @class */ (function () {
                function MatTabBase() {
                }
                return MatTabBase;
            }());
            /** @type {?} */
            var _MatTabMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatTabBase);
            var MatTab = /** @class */ (function (_super) {
                __extends(MatTab, _super);
                /**
                 * @param {?} _viewContainerRef
                 */
                function MatTab(_viewContainerRef) {
                    var _this = _super.call(this) || this;
                    _this._viewContainerRef = _viewContainerRef;
                    /**
                     * Plain text label for the tab, used when there is no template label.
                     */
                    _this.textLabel = '';
                    /**
                     * Portal that will be the hosted content of the tab
                     */
                    _this._contentPortal = null;
                    /**
                     * Emits whenever the internal state of the tab changes.
                     */
                    _this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * The relatively indexed position where 0 represents the center, negative is left, and positive
                     * represents the right.
                     */
                    _this.position = null;
                    /**
                     * The initial relatively index origin of the tab if it was created and selected after there
                     * was already a selected tab. Provides context of what position the tab should originate from.
                     */
                    _this.origin = null;
                    /**
                     * Whether the tab is currently active.
                     */
                    _this.isActive = false;
                    return _this;
                }
                Object.defineProperty(MatTab.prototype, "content", {
                    /**
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._contentPortal;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatTab.prototype.ngOnChanges = function (changes) {
                    if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {
                        this._stateChanges.next();
                    }
                };
                /**
                 * @return {?}
                 */
                MatTab.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                /**
                 * @return {?}
                 */
                MatTab.prototype.ngOnInit = function () {
                    this._contentPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["TemplatePortal"](this._explicitContent || this._implicitContent, this._viewContainerRef);
                };
                return MatTab;
            }(_MatTabMixinBase));
            MatTab.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab',
                            template: "<ng-template><ng-content></ng-content></ng-template>",
                            inputs: ['disabled'],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            exportAs: 'matTab',
                        },] },
            ];
            /** @nocollapse */
            MatTab.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] }
            ]; };
            MatTab.propDecorators = {
                templateLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatTabLabel, { static: false },] }],
                _explicitContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatTabContent, { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], static: true },] }],
                _implicitContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], { static: true },] }],
                textLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['label',] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material tabs.
             * \@docs-private
             * @type {?}
             */
            var matTabsAnimations = {
                /**
                 * Animation translates a tab along the X axis.
                 */
                translateTab: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["trigger"])('translateTab', [
                    // Note: transitions to `none` instead of 0, because some browsers might blur the content.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["state"])('center, void, left-origin-center, right-origin-center', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'none' })),
                    // If the tab is either on the left or right, we additionally add a `min-height` of 1px
                    // in order to ensure that the element has a height before its state changes. This is
                    // necessary because Chrome does seem to skip the transition in RTL mode if the element does
                    // not have a static height and is not rendered. See related issue: #9465
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["state"])('left', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["state"])('right', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])('* => left, * => right, left => center, right => center', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])('void => left-origin-center', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(-100%, 0, 0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
                    ]),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])('void => right-origin-center', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({ transform: 'translate3d(100%, 0, 0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
                    ])
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The portal host directive for the contents of the tab.
             * \@docs-private
             */
            var MatTabBodyPortal = /** @class */ (function (_super) {
                __extends(MatTabBodyPortal, _super);
                /**
                 * @param {?} componentFactoryResolver
                 * @param {?} viewContainerRef
                 * @param {?} _host
                 */
                function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {
                    var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;
                    _this._host = _host;
                    /**
                     * Subscription to events for when the tab body begins centering.
                     */
                    _this._centeringSub = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Subscription to events for when the tab body finishes leaving from center position.
                     */
                    _this._leavingSub = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    return _this;
                }
                /**
                 * Set initial visibility or set up subscription for changing visibility.
                 * @return {?}
                 */
                MatTabBodyPortal.prototype.ngOnInit = function () {
                    var _this = this;
                    _super.prototype.ngOnInit.call(this);
                    this._centeringSub = this._host._beforeCentering
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(this._host._isCenterPosition(this._host._position)))
                        .subscribe(( /**
                 * @param {?} isCentering
                 * @return {?}
                 */function (isCentering) {
                        if (isCentering && !_this.hasAttached()) {
                            _this.attach(_this._host._content);
                        }
                    }));
                    this._leavingSub = this._host._afterLeavingCenter.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this.detach();
                    }));
                };
                /**
                 * Clean up centering subscription.
                 * @return {?}
                 */
                MatTabBodyPortal.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._centeringSub.unsubscribe();
                    this._leavingSub.unsubscribe();
                };
                return MatTabBodyPortal;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["CdkPortalOutlet"]));
            MatTabBodyPortal.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matTabBodyHost]'
                        },] },
            ];
            /** @nocollapse */
            MatTabBodyPortal.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: MatTabBody, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatTabBody; })),] }] }
            ]; };
            /**
             * Base class with all of the `MatTabBody` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabBodyBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _dir
                 * @param {?} changeDetectorRef
                 */
                function _MatTabBodyBase(_elementRef, _dir, changeDetectorRef) {
                    var _this = this;
                    this._elementRef = _elementRef;
                    this._dir = _dir;
                    /**
                     * Subscription to the directionality change observable.
                     */
                    this._dirChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Emits when an animation on the tab is complete.
                     */
                    this._translateTabComplete = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Event emitted when the tab begins to animate towards the center as the active tab.
                     */
                    this._onCentering = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted before the centering of the tab begins.
                     */
                    this._beforeCentering = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted before the centering of the tab begins.
                     */
                    this._afterLeavingCenter = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the tab completes its animation towards the center.
                     */
                    this._onCentered = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](true);
                    // Note that the default value will always be overwritten by `MatTabBody`, but we need one
                    // anyway to prevent the animations module from throwing an error if the body is used on its own.
                    /**
                     * Duration for the tab's animation.
                     */
                    this.animationDuration = '500ms';
                    if (_dir) {
                        this._dirChangeSubscription = _dir.change.subscribe(( /**
                         * @param {?} dir
                         * @return {?}
                         */function (dir) {
                            _this._computePositionAnimationState(dir);
                            changeDetectorRef.markForCheck();
                        }));
                    }
                    // Ensure that we get unique animation events, because the `.done` callback can get
                    // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.
                    this._translateTabComplete.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) {
                        return x.fromState === y.fromState && x.toState === y.toState;
                    }))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        // If the transition to the center is complete, emit an event.
                        if (_this._isCenterPosition(event.toState) && _this._isCenterPosition(_this._position)) {
                            _this._onCentered.emit();
                        }
                        if (_this._isCenterPosition(event.fromState) && !_this._isCenterPosition(_this._position)) {
                            _this._afterLeavingCenter.emit();
                        }
                    }));
                }
                Object.defineProperty(_MatTabBodyBase.prototype, "position", {
                    /**
                     * The shifted index position of the tab body, where zero represents the active center tab.
                     * @param {?} position
                     * @return {?}
                     */
                    set: function (position) {
                        this._positionIndex = position;
                        this._computePositionAnimationState();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * After initialized, check if the content is centered and has an origin. If so, set the
                 * special position states that transition the tab from the left or right before centering.
                 * @return {?}
                 */
                _MatTabBodyBase.prototype.ngOnInit = function () {
                    if (this._position == 'center' && this.origin != null) {
                        this._position = this._computePositionFromOrigin();
                    }
                };
                /**
                 * @return {?}
                 */
                _MatTabBodyBase.prototype.ngOnDestroy = function () {
                    this._dirChangeSubscription.unsubscribe();
                    this._translateTabComplete.complete();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._onTranslateTabStarted = function (event) {
                    /** @type {?} */
                    var isCentering = this._isCenterPosition(event.toState);
                    this._beforeCentering.emit(isCentering);
                    if (isCentering) {
                        this._onCentering.emit(this._elementRef.nativeElement.clientHeight);
                    }
                };
                /**
                 * The text direction of the containing app.
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._getLayoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Whether the provided position state is considered center, regardless of origin.
                 * @param {?} position
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._isCenterPosition = function (position) {
                    return position == 'center' ||
                        position == 'left-origin-center' ||
                        position == 'right-origin-center';
                };
                /**
                 * Computes the position state that will be used for the tab-body animation trigger.
                 * @private
                 * @param {?=} dir
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._computePositionAnimationState = function (dir) {
                    if (dir === void 0) { dir = this._getLayoutDirection(); }
                    if (this._positionIndex < 0) {
                        this._position = dir == 'ltr' ? 'left' : 'right';
                    }
                    else if (this._positionIndex > 0) {
                        this._position = dir == 'ltr' ? 'right' : 'left';
                    }
                    else {
                        this._position = 'center';
                    }
                };
                /**
                 * Computes the position state based on the specified origin position. This is used if the
                 * tab is becoming visible immediately after creation.
                 * @private
                 * @return {?}
                 */
                _MatTabBodyBase.prototype._computePositionFromOrigin = function () {
                    /** @type {?} */
                    var dir = this._getLayoutDirection();
                    if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {
                        return 'left-origin-center';
                    }
                    return 'right-origin-center';
                };
                return _MatTabBodyBase;
            }());
            _MatTabBodyBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-body-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabBodyBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            _MatTabBodyBase.propDecorators = {
                _onCentering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _beforeCentering: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _afterLeavingCenter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _onCentered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['content',] }],
                origin: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                animationDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Wrapper for the contents of a tab.
             * \@docs-private
             */
            var MatTabBody = /** @class */ (function (_super) {
                __extends(MatTabBody, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} dir
                 * @param {?} changeDetectorRef
                 */
                function MatTabBody(elementRef, dir, changeDetectorRef) {
                    return _super.call(this, elementRef, dir, changeDetectorRef) || this;
                }
                return MatTabBody;
            }(_MatTabBodyBase));
            MatTabBody.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab-body',
                            template: "<div class=\"mat-tab-body-content\" #content [@translateTab]=\"{ value: _position, params: {animationDuration: animationDuration} }\" (@translateTab.start)=\"_onTranslateTabStarted($event)\" (@translateTab.done)=\"_translateTabComplete.next($event)\"><ng-template matTabBodyHost></ng-template></div>",
                            styles: [".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            animations: [matTabsAnimations.translateTab],
                            host: {
                                'class': 'mat-tab-body',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatTabBody.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatTabBody.propDecorators = {
                _portalHost: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["PortalHostDirective"], { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID's for each tab component
             * @type {?}
             */
            var nextId = 0;
            /**
             * A simple change event emitted on focus or selection changes.
             */
            var MatTabChangeEvent = /** @class */ (function () {
                function MatTabChangeEvent() {
                }
                return MatTabChangeEvent;
            }());
            /**
             * Injection token that can be used to provide the default options the tabs module.
             * @type {?}
             */
            var MAT_TABS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_TABS_CONFIG');
            // Boilerplate for applying mixins to MatTabGroup.
            /**
             * \@docs-private
             */
            var MatTabGroupMixinBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatTabGroupMixinBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatTabGroupMixinBase;
            }());
            /** @type {?} */
            var _MatTabGroupMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(MatTabGroupMixinBase), 'primary');
            /**
             * Base class with all of the `MatTabGroupBase` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabGroupBase = /** @class */ (function (_super) {
                __extends(_MatTabGroupBase, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?=} defaultConfig
                 * @param {?=} _animationMode
                 */
                function _MatTabGroupBase(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._animationMode = _animationMode;
                    /**
                     * The tab index that should be selected after the content has been checked.
                     */
                    _this._indexToSelect = 0;
                    /**
                     * Snapshot of the height of the tab body wrapper before another tab is activated.
                     */
                    _this._tabBodyWrapperHeight = 0;
                    /**
                     * Subscription to tabs being added/removed.
                     */
                    _this._tabsSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Subscription to changes in the tab labels.
                     */
                    _this._tabLabelSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    _this._dynamicHeight = false;
                    _this._selectedIndex = null;
                    /**
                     * Position of the tab header.
                     */
                    _this.headerPosition = 'above';
                    /**
                     * Output to enable support for two-way binding on `[(selectedIndex)]`
                     */
                    _this.selectedIndexChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when focus has changed within a tab group.
                     */
                    _this.focusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the body animation has completed
                     */
                    _this.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the tab selection has changed.
                     */
                    _this.selectedTabChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](true);
                    _this._groupId = nextId++;
                    _this.animationDuration = defaultConfig && defaultConfig.animationDuration ?
                        defaultConfig.animationDuration : '500ms';
                    return _this;
                }
                Object.defineProperty(_MatTabGroupBase.prototype, "dynamicHeight", {
                    /**
                     * Whether the tab group should grow to the size of the active tab.
                     * @return {?}
                     */
                    get: function () { return this._dynamicHeight; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._dynamicHeight = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabGroupBase.prototype, "selectedIndex", {
                    /**
                     * The index of the active tab.
                     * @return {?}
                     */
                    get: function () { return this._selectedIndex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._indexToSelect = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceNumberProperty"])(value, null);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabGroupBase.prototype, "animationDuration", {
                    /**
                     * Duration for the tab animation. Will be normalized to milliseconds if no units are set.
                     * @return {?}
                     */
                    get: function () { return this._animationDuration; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._animationDuration = /^\d+$/.test(value) ? value + 'ms' : value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabGroupBase.prototype, "backgroundColor", {
                    /**
                     * Background color of the tab group.
                     * @return {?}
                     */
                    get: function () { return this._backgroundColor; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var nativeElement = this._elementRef.nativeElement;
                        nativeElement.classList.remove("mat-background-" + this.backgroundColor);
                        if (value) {
                            nativeElement.classList.add("mat-background-" + value);
                        }
                        this._backgroundColor = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * After the content is checked, this component knows what tabs have been defined
                 * and what the selected index should be. This is where we can know exactly what position
                 * each tab should be in according to the new selected index, and additionally we know how
                 * a new selected tab should transition in (from the left or right).
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.ngAfterContentChecked = function () {
                    var _this = this;
                    // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
                    // the amount of tabs changes before the actual change detection runs.
                    /** @type {?} */
                    var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
                    // If there is a change in selected index, emit a change event. Should not trigger if
                    // the selected index has not yet been initialized.
                    if (this._selectedIndex != indexToSelect) {
                        /** @type {?} */
                        var isFirstRun_1 = this._selectedIndex == null;
                        if (!isFirstRun_1) {
                            this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
                        }
                        // Changing these values after change detection has run
                        // since the checked content may contain references to them.
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () {
                            _this._tabs.forEach(( /**
                             * @param {?} tab
                             * @param {?} index
                             * @return {?}
                             */function (tab, index) { return tab.isActive = index === indexToSelect; }));
                            if (!isFirstRun_1) {
                                _this.selectedIndexChange.emit(indexToSelect);
                            }
                        }));
                    }
                    // Setup the position for each tab and optionally setup an origin on the next selected tab.
                    this._tabs.forEach(( /**
                     * @param {?} tab
                     * @param {?} index
                     * @return {?}
                     */function (tab, index) {
                        tab.position = index - indexToSelect;
                        // If there is already a selected tab, then set up an origin for the next selected tab
                        // if it doesn't have one already.
                        if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {
                            tab.origin = indexToSelect - _this._selectedIndex;
                        }
                    }));
                    if (this._selectedIndex !== indexToSelect) {
                        this._selectedIndex = indexToSelect;
                        this._changeDetectorRef.markForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._subscribeToTabLabels();
                    // Subscribe to changes in the amount of tabs, in order to be
                    // able to re-render the content as new tabs are added or removed.
                    this._tabsSubscription = this._tabs.changes.subscribe(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
                        // Maintain the previously-selected tab if a new tab is added or removed and there is no
                        // explicit change that selects a different tab.
                        if (indexToSelect === _this._selectedIndex) {
                            /** @type {?} */
                            var tabs = _this._tabs.toArray();
                            for (var i = 0; i < tabs.length; i++) {
                                if (tabs[i].isActive) {
                                    // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                                    // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                                    // adding a tab within the `selectedIndexChange` event.
                                    _this._indexToSelect = _this._selectedIndex = i;
                                    break;
                                }
                            }
                        }
                        _this._subscribeToTabLabels();
                        _this._changeDetectorRef.markForCheck();
                    }));
                };
                /**
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.ngOnDestroy = function () {
                    this._tabsSubscription.unsubscribe();
                    this._tabLabelSubscription.unsubscribe();
                };
                /**
                 * Re-aligns the ink bar to the selected tab element.
                 * @return {?}
                 */
                _MatTabGroupBase.prototype.realignInkBar = function () {
                    if (this._tabHeader) {
                        this._tabHeader._alignInkBarToSelectedTab();
                    }
                };
                /**
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._focusChanged = function (index) {
                    this.focusChange.emit(this._createChangeEvent(index));
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._createChangeEvent = function (index) {
                    /** @type {?} */
                    var event = new MatTabChangeEvent;
                    event.index = index;
                    if (this._tabs && this._tabs.length) {
                        event.tab = this._tabs.toArray()[index];
                    }
                    return event;
                };
                /**
                 * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
                 * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
                 * binding to be updated, we need to subscribe to changes in it and trigger change detection
                 * manually.
                 * @private
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._subscribeToTabLabels = function () {
                    var _this = this;
                    if (this._tabLabelSubscription) {
                        this._tabLabelSubscription.unsubscribe();
                    }
                    this._tabLabelSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"]).apply(void 0, this._tabs.map(( /**
                     * @param {?} tab
                     * @return {?}
                     */function (/**
                     * @param {?} tab
                     * @return {?}
                     */ tab) { return tab._stateChanges; }))).subscribe(( /**
                 * @return {?}
                 */function () { return _this._changeDetectorRef.markForCheck(); }));
                };
                /**
                 * Clamps the given index to the bounds of 0 and the tabs length.
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._clampTabIndex = function (index) {
                    // Note the `|| 0`, which ensures that values like NaN can't get through
                    // and which would otherwise throw the component into an infinite loop
                    // (since Math.max(NaN, 0) === NaN).
                    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));
                };
                /**
                 * Returns a unique id for each tab label element
                 * @param {?} i
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._getTabLabelId = function (i) {
                    return "mat-tab-label-" + this._groupId + "-" + i;
                };
                /**
                 * Returns a unique id for each tab content element
                 * @param {?} i
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._getTabContentId = function (i) {
                    return "mat-tab-content-" + this._groupId + "-" + i;
                };
                /**
                 * Sets the height of the body wrapper to the height of the activating tab if dynamic
                 * height property is true.
                 * @param {?} tabHeight
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._setTabBodyWrapperHeight = function (tabHeight) {
                    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
                        return;
                    }
                    /** @type {?} */
                    var wrapper = this._tabBodyWrapper.nativeElement;
                    wrapper.style.height = this._tabBodyWrapperHeight + 'px';
                    // This conditional forces the browser to paint the height so that
                    // the animation to the new height can have an origin.
                    if (this._tabBodyWrapper.nativeElement.offsetHeight) {
                        wrapper.style.height = tabHeight + 'px';
                    }
                };
                /**
                 * Removes the height of the tab body wrapper.
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._removeTabBodyWrapperHeight = function () {
                    /** @type {?} */
                    var wrapper = this._tabBodyWrapper.nativeElement;
                    this._tabBodyWrapperHeight = wrapper.clientHeight;
                    wrapper.style.height = '';
                    this.animationDone.emit();
                };
                /**
                 * Handle click events, setting new selected index if appropriate.
                 * @param {?} tab
                 * @param {?} tabHeader
                 * @param {?} index
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._handleClick = function (tab, tabHeader, index) {
                    if (!tab.disabled) {
                        this.selectedIndex = tabHeader.focusIndex = index;
                    }
                };
                /**
                 * Retrieves the tabindex for the tab.
                 * @param {?} tab
                 * @param {?} idx
                 * @return {?}
                 */
                _MatTabGroupBase.prototype._getTabIndex = function (tab, idx) {
                    if (tab.disabled) {
                        return null;
                    }
                    return this.selectedIndex === idx ? 0 : -1;
                };
                return _MatTabGroupBase;
            }(_MatTabGroupMixinBase));
            _MatTabGroupBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-group-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabGroupBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_TABS_CONFIG,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabGroupBase.propDecorators = {
                dynamicHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                headerPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                animationDuration: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                backgroundColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndexChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                focusChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                animationDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                selectedTabChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * Material design tab-group component. Supports basic tab pairs (label + content) and includes
             * animated ink-bar, keyboard navigation, and screen reader.
             * See: https://material.io/design/components/tabs.html
             */
            var MatTabGroup = /** @class */ (function (_super) {
                __extends(MatTabGroup, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} changeDetectorRef
                 * @param {?=} defaultConfig
                 * @param {?=} animationMode
                 */
                function MatTabGroup(elementRef, changeDetectorRef, defaultConfig, animationMode) {
                    return _super.call(this, elementRef, changeDetectorRef, defaultConfig, animationMode) || this;
                }
                return MatTabGroup;
            }(_MatTabGroupBase));
            MatTabGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab-group',
                            exportAs: 'matTabGroup',
                            template: "<mat-tab-header #tabHeader [selectedIndex]=\"selectedIndex\" [disableRipple]=\"disableRipple\" (indexFocused)=\"_focusChanged($event)\" (selectFocusedIndex)=\"selectedIndex = $event\"><div class=\"mat-tab-label\" role=\"tab\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabLabelId(i)\" [attr.tabIndex]=\"_getTabIndex(tab, i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"_tabs.length\" [attr.aria-controls]=\"_getTabContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"tab.ariaLabel || null\" [attr.aria-labelledby]=\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\" [class.mat-tab-label-active]=\"selectedIndex == i\" [disabled]=\"tab.disabled\" [matRippleDisabled]=\"tab.disabled || disableRipple\" (click)=\"_handleClick(tab, tabHeader, i)\"><div class=\"mat-tab-label-content\"><ng-template [ngIf]=\"tab.templateLabel\"><ng-template [cdkPortalOutlet]=\"tab.templateLabel\"></ng-template></ng-template><ng-template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\"mat-tab-body-wrapper\" [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\" #tabBodyWrapper><mat-tab-body role=\"tabpanel\" *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabContentId(i)\" [attr.aria-labelledby]=\"_getTabLabelId(i)\" [class.mat-tab-body-active]=\"selectedIndex == i\" [content]=\"tab.content\" [position]=\"tab.position\" [origin]=\"tab.origin\" [animationDuration]=\"animationDuration\" (_onCentered)=\"_removeTabBodyWrapperHeight()\" (_onCentering)=\"_setTabBodyWrapperHeight($event)\"></mat-tab-body></div>",
                            styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['color', 'disableRipple'],
                            host: {
                                'class': 'mat-tab-group',
                                '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',
                                '[class.mat-tab-group-inverted-header]': 'headerPosition === "below"',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatTabGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_TABS_CONFIG,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatTabGroup.propDecorators = {
                _tabs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatTab,] }],
                _tabBodyWrapper: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabBodyWrapper', { static: false },] }],
                _tabHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabHeader', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatTabLabelWrapper.
            /**
             * \@docs-private
             */
            var MatTabLabelWrapperBase = /** @class */ (function () {
                function MatTabLabelWrapperBase() {
                }
                return MatTabLabelWrapperBase;
            }());
            /** @type {?} */
            var _MatTabLabelWrapperMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatTabLabelWrapperBase);
            /**
             * Used in the `mat-tab-group` view to display tab labels.
             * \@docs-private
             */
            var MatTabLabelWrapper = /** @class */ (function (_super) {
                __extends(MatTabLabelWrapper, _super);
                /**
                 * @param {?} elementRef
                 */
                function MatTabLabelWrapper(elementRef) {
                    var _this = _super.call(this) || this;
                    _this.elementRef = elementRef;
                    return _this;
                }
                /**
                 * Sets focus on the wrapper element
                 * @return {?}
                 */
                MatTabLabelWrapper.prototype.focus = function () {
                    this.elementRef.nativeElement.focus();
                };
                /**
                 * @return {?}
                 */
                MatTabLabelWrapper.prototype.getOffsetLeft = function () {
                    return this.elementRef.nativeElement.offsetLeft;
                };
                /**
                 * @return {?}
                 */
                MatTabLabelWrapper.prototype.getOffsetWidth = function () {
                    return this.elementRef.nativeElement.offsetWidth;
                };
                return MatTabLabelWrapper;
            }(_MatTabLabelWrapperMixinBase));
            MatTabLabelWrapper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matTabLabelWrapper]',
                            inputs: ['disabled'],
                            host: {
                                '[class.mat-tab-disabled]': 'disabled',
                                '[attr.aria-disabled]': '!!disabled',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatTabLabelWrapper.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Config used to bind passive event listeners
             * @type {?}
             */
            var passiveEventListenerOptions = ( /** @type {?} */(Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["normalizePassiveListenerOptions"])({ passive: true })));
            /**
             * The distance in pixels that will be overshot when scrolling a tab label into view. This helps
             * provide a small affordance to the label next to it.
             * @type {?}
             */
            var EXAGGERATED_OVERSCROLL = 60;
            /**
             * Amount of milliseconds to wait before starting to scroll the header automatically.
             * Set a little conservatively in order to handle fake events dispatched on touch devices.
             * @type {?}
             */
            var HEADER_SCROLL_DELAY = 650;
            /**
             * Interval in milliseconds at which to scroll the header
             * while the user is holding their pointer.
             * @type {?}
             */
            var HEADER_SCROLL_INTERVAL = 100;
            /**
             * Base class for a tab header that supported pagination.
             * \@docs-private
             * @abstract
             */
            var MatPaginatedTabHeader = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _viewportRuler
                 * @param {?} _dir
                 * @param {?} _ngZone
                 * @param {?=} _platform
                 * @param {?=} _animationMode
                 */
                function MatPaginatedTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {
                    var _this = this;
                    this._elementRef = _elementRef;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._viewportRuler = _viewportRuler;
                    this._dir = _dir;
                    this._ngZone = _ngZone;
                    this._platform = _platform;
                    this._animationMode = _animationMode;
                    /**
                     * The distance in pixels that the tab labels should be translated to the left.
                     */
                    this._scrollDistance = 0;
                    /**
                     * Whether the header should scroll to the selected index after the view has been checked.
                     */
                    this._selectedIndexChanged = false;
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Whether the controls for pagination should be displayed
                     */
                    this._showPaginationControls = false;
                    /**
                     * Whether the tab list can be scrolled more towards the end of the tab label list.
                     */
                    this._disableScrollAfter = true;
                    /**
                     * Whether the tab list can be scrolled more towards the beginning of the tab label list.
                     */
                    this._disableScrollBefore = true;
                    /**
                     * Stream that will stop the automated scrolling.
                     */
                    this._stopScrolling = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    this._selectedIndex = 0;
                    /**
                     * Event emitted when the option is selected.
                     */
                    this.selectFocusedIndex = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when a label is focused.
                     */
                    this.indexFocused = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.
                    _ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_elementRef.nativeElement, 'mouseleave')
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(_this._destroyed))
                            .subscribe(( /**
                     * @return {?}
                     */function () {
                            _this._stopInterval();
                        }));
                    }));
                }
                Object.defineProperty(MatPaginatedTabHeader.prototype, "selectedIndex", {
                    /**
                     * The index of the active tab.
                     * @return {?}
                     */
                    get: function () { return this._selectedIndex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceNumberProperty"])(value);
                        if (this._selectedIndex != value) {
                            this._selectedIndexChanged = true;
                            this._selectedIndex = value;
                            if (this._keyManager) {
                                this._keyManager.updateActiveItemIndex(value);
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    // We need to handle these events manually, because we want to bind passive event listeners.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._handlePaginatorPress('before');
                    }));
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._handlePaginatorPress('after');
                    }));
                };
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    /** @type {?} */
                    var dirChange = this._dir ? this._dir.change : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])(null);
                    /** @type {?} */
                    var resize = this._viewportRuler.change(150);
                    /** @type {?} */
                    var realign = ( /**
                     * @return {?}
                     */function () {
                        _this.updatePagination();
                        _this._alignInkBarToSelectedTab();
                    });
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusKeyManager"](this._items)
                        .withHorizontalOrientation(this._getLayoutDirection())
                        .withWrap();
                    this._keyManager.updateActiveItem(0);
                    // Defer the first call in order to allow for slower browsers to lay out the elements.
                    // This helps in cases where the user lands directly on a page with paginated tabs.
                    typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();
                    // On dir change or window resize, realign the ink bar and update the orientation of
                    // the key manager if the direction has changed.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(dirChange, resize, this._items.changes).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        realign();
                        _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());
                    }));
                    // If there is a change in the focus key manager we need to emit the `indexFocused`
                    // event in order to provide a public event that notifies about focus changes. Also we realign
                    // the tabs container by scrolling the new focused tab into the visible section.
                    this._keyManager.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} newFocusIndex
                     * @return {?}
                     */function (/**
                     * @param {?} newFocusIndex
                     * @return {?}
                     */ newFocusIndex) {
                        _this.indexFocused.emit(newFocusIndex);
                        _this._setTabFocus(newFocusIndex);
                    }));
                };
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngAfterContentChecked = function () {
                    // If the number of tab labels have changed, check if scrolling should be enabled
                    if (this._tabLabelCount != this._items.length) {
                        this.updatePagination();
                        this._tabLabelCount = this._items.length;
                        this._changeDetectorRef.markForCheck();
                    }
                    // If the selected index has changed, scroll to the label and check if the scrolling controls
                    // should be disabled.
                    if (this._selectedIndexChanged) {
                        this._scrollToLabel(this._selectedIndex);
                        this._checkScrollingControls();
                        this._alignInkBarToSelectedTab();
                        this._selectedIndexChanged = false;
                        this._changeDetectorRef.markForCheck();
                    }
                    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),
                    // then translate the header to reflect this.
                    if (this._scrollDistanceChanged) {
                        this._updateTabScrollPosition();
                        this._scrollDistanceChanged = false;
                        this._changeDetectorRef.markForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                    this._stopScrolling.complete();
                };
                /**
                 * Handles keyboard events on the header.
                 * @param {?} event
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._handleKeydown = function (event) {
                    // We don't handle any key bindings with a modifier key.
                    if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                        return;
                    }
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["HOME"]:
                            this._keyManager.setFirstItemActive();
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["END"]:
                            this._keyManager.setLastItemActive();
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["SPACE"]:
                            this.selectFocusedIndex.emit(this.focusIndex);
                            this._itemSelected(event);
                            break;
                        default:
                            this._keyManager.onKeydown(event);
                    }
                };
                /**
                 * Callback for when the MutationObserver detects that the content has changed.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._onContentChanges = function () {
                    var _this = this;
                    /** @type {?} */
                    var textContent = this._elementRef.nativeElement.textContent;
                    // We need to diff the text content of the header, because the MutationObserver callback
                    // will fire even if the text content didn't change which is inefficient and is prone
                    // to infinite loops if a poorly constructed expression is passed in (see #14249).
                    if (textContent !== this._currentTextContent) {
                        this._currentTextContent = textContent || '';
                        // The content observer runs outside the `NgZone` by default, which
                        // means that we need to bring the callback back in ourselves.
                        this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            _this.updatePagination();
                            _this._alignInkBarToSelectedTab();
                            _this._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * Updates the view whether pagination should be enabled or not.
                 *
                 * WARNING: Calling this method can be very costly in terms of performance. It should be called
                 * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
                 * page.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype.updatePagination = function () {
                    this._checkPaginationEnabled();
                    this._checkScrollingControls();
                    this._updateTabScrollPosition();
                };
                Object.defineProperty(MatPaginatedTabHeader.prototype, "focusIndex", {
                    /**
                     * Tracks which element has focus; used for keyboard navigation
                     * @return {?}
                     */
                    get: function () {
                        return this._keyManager ? ( /** @type {?} */(this._keyManager.activeItemIndex)) : 0;
                    },
                    /**
                     * When the focus index is set, we must manually send focus to the correct label
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                            return;
                        }
                        this._keyManager.setActiveItem(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
                 * providing a valid index and return true.
                 * @param {?} index
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._isValidIndex = function (index) {
                    if (!this._items) {
                        return true;
                    }
                    /** @type {?} */
                    var tab = this._items ? this._items.toArray()[index] : null;
                    return !!tab && !tab.disabled;
                };
                /**
                 * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
                 * scrolling is enabled.
                 * @param {?} tabIndex
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._setTabFocus = function (tabIndex) {
                    if (this._showPaginationControls) {
                        this._scrollToLabel(tabIndex);
                    }
                    if (this._items && this._items.length) {
                        this._items.toArray()[tabIndex].focus();
                        // Do not let the browser manage scrolling to focus the element, this will be handled
                        // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width
                        // should be the full width minus the offset width.
                        /** @type {?} */
                        var containerEl = this._tabListContainer.nativeElement;
                        /** @type {?} */
                        var dir = this._getLayoutDirection();
                        if (dir == 'ltr') {
                            containerEl.scrollLeft = 0;
                        }
                        else {
                            containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
                        }
                    }
                };
                /**
                 * The layout direction of the containing app.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._getLayoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Performs the CSS transformation on the tab list that will cause the list to scroll.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._updateTabScrollPosition = function () {
                    /** @type {?} */
                    var scrollDistance = this.scrollDistance;
                    /** @type {?} */
                    var platform = this._platform;
                    /** @type {?} */
                    var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;
                    // Don't use `translate3d` here because we don't want to create a new layer. A new layer
                    // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar
                    // and ripples will exceed the boundaries of the visible tab bar.
                    // See: https://github.com/angular/components/issues/10276
                    // We round the `transform` here, because transforms with sub-pixel precision cause some
                    // browsers to blur the content of the element.
                    this._tabList.nativeElement.style.transform = "translateX(" + Math.round(translateX) + "px)";
                    // Setting the `transform` on IE will change the scroll offset of the parent, causing the
                    // position to be thrown off in some cases. We have to reset it ourselves to ensure that
                    // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing
                    // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).
                    // @breaking-change 9.0.0 Remove null check for `platform` after it can no longer be undefined.
                    if (platform && (platform.TRIDENT || platform.EDGE)) {
                        this._tabListContainer.nativeElement.scrollLeft = 0;
                    }
                };
                Object.defineProperty(MatPaginatedTabHeader.prototype, "scrollDistance", {
                    /**
                     * Sets the distance in pixels that the tab header should be transformed in the X-axis.
                     * @return {?}
                     */
                    get: function () { return this._scrollDistance; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._scrollTo(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
                 * the end of the list, respectively). The distance to scroll is computed to be a third of the
                 * length of the tab list view window.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @param {?} direction
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._scrollHeader = function (direction) {
                    /** @type {?} */
                    var viewLength = this._tabListContainer.nativeElement.offsetWidth;
                    // Move the scroll distance one-third the length of the tab list's viewport.
                    /** @type {?} */
                    var scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;
                    return this._scrollTo(this._scrollDistance + scrollAmount);
                };
                /**
                 * Handles click events on the pagination arrows.
                 * @param {?} direction
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._handlePaginatorClick = function (direction) {
                    this._stopInterval();
                    this._scrollHeader(direction);
                };
                /**
                 * Moves the tab list such that the desired tab label (marked by index) is moved into view.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @param {?} labelIndex
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._scrollToLabel = function (labelIndex) {
                    /** @type {?} */
                    var selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;
                    if (!selectedLabel) {
                        return;
                    }
                    // The view length is the visible width of the tab labels.
                    /** @type {?} */
                    var viewLength = this._tabListContainer.nativeElement.offsetWidth;
                    var _a = selectedLabel.elementRef.nativeElement, offsetLeft = _a.offsetLeft, offsetWidth = _a.offsetWidth;
                    /** @type {?} */
                    var labelBeforePos;
                    /** @type {?} */
                    var labelAfterPos;
                    if (this._getLayoutDirection() == 'ltr') {
                        labelBeforePos = offsetLeft;
                        labelAfterPos = labelBeforePos + offsetWidth;
                    }
                    else {
                        labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;
                        labelBeforePos = labelAfterPos - offsetWidth;
                    }
                    /** @type {?} */
                    var beforeVisiblePos = this.scrollDistance;
                    /** @type {?} */
                    var afterVisiblePos = this.scrollDistance + viewLength;
                    if (labelBeforePos < beforeVisiblePos) {
                        // Scroll header to move label to the before direction
                        this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
                    }
                    else if (labelAfterPos > afterVisiblePos) {
                        // Scroll header to move label to the after direction
                        this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
                    }
                };
                /**
                 * Evaluate whether the pagination controls should be displayed. If the scroll width of the
                 * tab list is wider than the size of the header container, then the pagination controls should
                 * be shown.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._checkPaginationEnabled = function () {
                    /** @type {?} */
                    var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
                    if (!isEnabled) {
                        this.scrollDistance = 0;
                    }
                    if (isEnabled !== this._showPaginationControls) {
                        this._changeDetectorRef.markForCheck();
                    }
                    this._showPaginationControls = isEnabled;
                };
                /**
                 * Evaluate whether the before and after controls should be enabled or disabled.
                 * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
                 * before button. If the header is at the end of the list (scroll distance is equal to the
                 * maximum distance we can scroll), then disable the after button.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._checkScrollingControls = function () {
                    // Check if the pagination arrows should be activated.
                    this._disableScrollBefore = this.scrollDistance == 0;
                    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Determines what is the maximum length in pixels that can be set for the scroll distance. This
                 * is equal to the difference in width between the tab list container and tab header container.
                 *
                 * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
                 * should be called sparingly.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._getMaxScrollDistance = function () {
                    /** @type {?} */
                    var lengthOfTabList = this._tabList.nativeElement.scrollWidth;
                    /** @type {?} */
                    var viewLength = this._tabListContainer.nativeElement.offsetWidth;
                    return (lengthOfTabList - viewLength) || 0;
                };
                /**
                 * Tells the ink-bar to align itself to the current label wrapper
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._alignInkBarToSelectedTab = function () {
                    /** @type {?} */
                    var selectedItem = this._items && this._items.length ?
                        this._items.toArray()[this.selectedIndex] : null;
                    /** @type {?} */
                    var selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;
                    if (selectedLabelWrapper) {
                        this._inkBar.alignToElement(selectedLabelWrapper);
                    }
                    else {
                        this._inkBar.hide();
                    }
                };
                /**
                 * Stops the currently-running paginator interval.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._stopInterval = function () {
                    this._stopScrolling.next();
                };
                /**
                 * Handles the user pressing down on one of the paginators.
                 * Starts scrolling the header after a certain amount of time.
                 * @param {?} direction In which direction the paginator should be scrolled.
                 * @return {?}
                 */
                MatPaginatedTabHeader.prototype._handlePaginatorPress = function (direction) {
                    var _this = this;
                    // Avoid overlapping timers.
                    this._stopInterval();
                    // Start a timer after the delay and keep firing based on the interval.
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["timer"])(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)
                        // Keep the timer going until something tells it to stop or the component is destroyed.
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(this._stopScrolling, this._destroyed)))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        var _a = _this._scrollHeader(direction), maxScrollDistance = _a.maxScrollDistance, distance = _a.distance;
                        // Stop the timer if we've reached the start or the end.
                        if (distance === 0 || distance >= maxScrollDistance) {
                            _this._stopInterval();
                        }
                    }));
                };
                /**
                 * Scrolls the header to a given position.
                 * @private
                 * @param {?} position Position to which to scroll.
                 * @return {?} Information on the current scroll distance and the maximum.
                 */
                MatPaginatedTabHeader.prototype._scrollTo = function (position) {
                    /** @type {?} */
                    var maxScrollDistance = this._getMaxScrollDistance();
                    this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));
                    // Mark that the scroll distance has changed so that after the view is checked, the CSS
                    // transformation can move the header.
                    this._scrollDistanceChanged = true;
                    this._checkScrollingControls();
                    return { maxScrollDistance: maxScrollDistance, distance: this._scrollDistance };
                };
                return MatPaginatedTabHeader;
            }());
            MatPaginatedTabHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-paginated-tab-header'
                        },] },
            ];
            /** @nocollapse */
            MatPaginatedTabHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Base class with all of the `MatTabHeader` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabHeaderBase = /** @class */ (function (_super) {
                __extends(_MatTabHeaderBase, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} platform
                 * @param {?=} animationMode
                 */
                function _MatTabHeaderBase(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, 
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                animationMode) {
                    var _this = _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;
                    _this._disableRipple = false;
                    return _this;
                }
                Object.defineProperty(_MatTabHeaderBase.prototype, "disableRipple", {
                    /**
                     * Whether the ripple effect is disabled or not.
                     * @return {?}
                     */
                    get: function () { return this._disableRipple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disableRipple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @protected
                 * @param {?} event
                 * @return {?}
                 */
                _MatTabHeaderBase.prototype._itemSelected = function (event) {
                    event.preventDefault();
                };
                return _MatTabHeaderBase;
            }(MatPaginatedTabHeader));
            _MatTabHeaderBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-header-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabHeaderBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabHeaderBase.propDecorators = {
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * The header of the tab group which displays a list of all the tabs in the tab group. Includes
             * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the
             * width of the header container, then arrows will be displayed to allow the user to scroll
             * left and right across the header.
             * \@docs-private
             */
            var MatTabHeader = /** @class */ (function (_super) {
                __extends(MatTabHeader, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} platform
                 * @param {?=} animationMode
                 */
                function MatTabHeader(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, 
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                animationMode) {
                    return _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;
                }
                return MatTabHeader;
            }(_MatTabHeaderBase));
            MatTabHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-tab-header',
                            template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" #previousPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollBefore || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_handlePaginatorClick('before')\" (mousedown)=\"_handlePaginatorPress('before')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-label-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div #tabList class=\"mat-tab-list\" [class._mat-animation-noopable]=\"_animationMode === 'NoopAnimations'\" role=\"tablist\" (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-labels\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" #nextPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollAfter || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (mousedown)=\"_handlePaginatorPress('after')\" (click)=\"_handlePaginatorClick('after')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
                            styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}"],
                            inputs: ['selectedIndex'],
                            outputs: ['selectFocusedIndex', 'indexFocused'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-tab-header',
                                '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
                                '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatTabHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatTabHeader.propDecorators = {
                _items: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatTabLabelWrapper,] }],
                _inkBar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatInkBar, { static: true },] }],
                _tabListContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabListContainer', { static: true },] }],
                _tabList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabList', { static: true },] }],
                _nextPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['nextPaginator', { static: false },] }],
                _previousPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['previousPaginator', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Base class with all of the `MatTabNav` functionality.
             * \@docs-private
             * @abstract
             */
            // tslint:disable-next-line:class-name
            var _MatTabNavBase = /** @class */ (function (_super) {
                __extends(_MatTabNavBase, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?=} platform
                 * @param {?=} animationMode
                 */
                function _MatTabNavBase(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, 
                /**
                 * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
                 */
                platform, animationMode) {
                    var _this = _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;
                    _this._disableRipple = false;
                    /**
                     * Theme color of the nav bar.
                     */
                    _this.color = 'primary';
                    return _this;
                }
                Object.defineProperty(_MatTabNavBase.prototype, "backgroundColor", {
                    /**
                     * Background color of the tab nav.
                     * @return {?}
                     */
                    get: function () { return this._backgroundColor; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var classList = this._elementRef.nativeElement.classList;
                        classList.remove("mat-background-" + this.backgroundColor);
                        if (value) {
                            classList.add("mat-background-" + value);
                        }
                        this._backgroundColor = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabNavBase.prototype, "disableRipple", {
                    /**
                     * Whether the ripple effect is disabled or not.
                     * @return {?}
                     */
                    get: function () { return this._disableRipple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disableRipple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @protected
                 * @return {?}
                 */
                _MatTabNavBase.prototype._itemSelected = function () {
                    // noop
                };
                /**
                 * @return {?}
                 */
                _MatTabNavBase.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    // We need this to run before the `changes` subscription in parent to ensure that the
                    // selectedIndex is up-to-date by the time the super class starts looking for it.
                    this._items.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this.updateActiveLink();
                    }));
                    _super.prototype.ngAfterContentInit.call(this);
                };
                /**
                 * Notifies the component that the active link has been changed.
                 * \@breaking-change 8.0.0 `element` parameter to be removed.
                 * @param {?=} _element
                 * @return {?}
                 */
                _MatTabNavBase.prototype.updateActiveLink = function (_element) {
                    if (!this._items) {
                        return;
                    }
                    /** @type {?} */
                    var items = this._items.toArray();
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].active) {
                            this.selectedIndex = i;
                            this._changeDetectorRef.markForCheck();
                            return;
                        }
                    }
                    // The ink bar should hide itself if no items are active.
                    this.selectedIndex = -1;
                    this._inkBar.hide();
                };
                return _MatTabNavBase;
            }(MatPaginatedTabHeader));
            _MatTabNavBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-nav-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabNavBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabNavBase.propDecorators = {
                backgroundColor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Navigation component matching the styles of the tab group header.
             * Provides anchored navigation with animated ink bar.
             */
            var MatTabNav = /** @class */ (function (_super) {
                __extends(MatTabNav, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} dir
                 * @param {?} ngZone
                 * @param {?} changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?=} platform
                 * @param {?=} animationMode
                 */
                function MatTabNav(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, 
                /**
                 * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.
                 */
                platform, animationMode) {
                    return _super.call(this, elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) || this;
                }
                return MatTabNav;
            }(_MatTabNavBase));
            MatTabNav.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: '[mat-tab-nav-bar]',
                            exportAs: 'matTabNavBar, matTabNav',
                            inputs: ['color'],
                            template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" #previousPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollBefore || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_handlePaginatorClick('before')\" (mousedown)=\"_handlePaginatorPress('before')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-link-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div class=\"mat-tab-list\" #tabList (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-links\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" #nextPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollAfter || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (mousedown)=\"_handlePaginatorPress('after')\" (click)=\"_handlePaginatorClick('after')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
                            styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-links{display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}"],
                            host: {
                                'class': 'mat-tab-nav-bar mat-tab-header',
                                '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
                                '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
                                '[class.mat-primary]': 'color !== "warn" && color !== "accent"',
                                '[class.mat-accent]': 'color === "accent"',
                                '[class.mat-warn]': 'color === "warn"',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatTabNav.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatTabNav.propDecorators = {
                _items: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatTabLink; })), { descendants: true },] }],
                _inkBar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatInkBar, { static: true },] }],
                _tabListContainer: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabListContainer', { static: true },] }],
                _tabList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['tabList', { static: true },] }],
                _nextPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['nextPaginator', { static: false },] }],
                _previousPaginator: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['previousPaginator', { static: false },] }]
            };
            // Boilerplate for applying mixins to MatTabLink.
            var MatTabLinkMixinBase = /** @class */ (function () {
                function MatTabLinkMixinBase() {
                }
                return MatTabLinkMixinBase;
            }());
            /** @type {?} */
            var _MatTabLinkMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatTabLinkMixinBase)));
            /**
             * Base class with all of the `MatTabLink` functionality.
             */
            // tslint:disable-next-line:class-name
            var _MatTabLinkBase = /** @class */ (function (_super) {
                __extends(_MatTabLinkBase, _super);
                /**
                 * @param {?} _tabNavBar
                 * @param {?} elementRef
                 * @param {?} globalRippleOptions
                 * @param {?} tabIndex
                 * @param {?} _focusMonitor
                 * @param {?=} animationMode
                 */
                function _MatTabLinkBase(_tabNavBar, elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {
                    var _this = _super.call(this) || this;
                    _this._tabNavBar = _tabNavBar;
                    _this.elementRef = elementRef;
                    _this._focusMonitor = _focusMonitor;
                    /**
                     * Whether the tab link is active or not.
                     */
                    _this._isActive = false;
                    _this.rippleConfig = globalRippleOptions || {};
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    if (animationMode === 'NoopAnimations') {
                        _this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };
                    }
                    _focusMonitor.monitor(elementRef);
                    return _this;
                }
                Object.defineProperty(_MatTabLinkBase.prototype, "active", {
                    /**
                     * Whether the link is active.
                     * @return {?}
                     */
                    get: function () { return this._isActive; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this._isActive) {
                            this._isActive = value;
                            this._tabNavBar.updateActiveLink(this.elementRef);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatTabLinkBase.prototype, "rippleDisabled", {
                    /**
                     * Whether ripples are disabled on interaction.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||
                            !!this.rippleConfig.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                _MatTabLinkBase.prototype.focus = function () {
                    this.elementRef.nativeElement.focus();
                };
                /**
                 * @return {?}
                 */
                _MatTabLinkBase.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this.elementRef);
                };
                return _MatTabLinkBase;
            }(_MatTabLinkMixinBase));
            _MatTabLinkBase.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.
                            selector: 'do-not-use-abstract-mat-tab-link-base'
                        },] },
            ];
            /** @nocollapse */
            _MatTabLinkBase.ctorParameters = function () { return [
                { type: _MatTabNavBase },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            _MatTabLinkBase.propDecorators = {
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Link inside of a `mat-tab-nav-bar`.
             */
            var MatTabLink = /** @class */ (function (_super) {
                __extends(MatTabLink, _super);
                /**
                 * @param {?} tabNavBar
                 * @param {?} elementRef
                 * @param {?} ngZone
                 * @param {?} platform
                 * @param {?} globalRippleOptions
                 * @param {?} tabIndex
                 * @param {?} focusMonitor
                 * @param {?=} animationMode
                 */
                function MatTabLink(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {
                    var _this = _super.call(this, tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode) || this;
                    _this._tabLinkRipple = new _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["RippleRenderer"](_this, ngZone, elementRef, platform);
                    _this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatTabLink.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._tabLinkRipple._removeTriggerEvents();
                };
                return MatTabLink;
            }(_MatTabLinkBase));
            MatTabLink.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-tab-link], [matTabLink]',
                            exportAs: 'matTabLink',
                            inputs: ['disabled', 'disableRipple', 'tabIndex'],
                            host: {
                                'class': 'mat-tab-link',
                                '[attr.aria-current]': 'active ? "page" : null',
                                '[attr.aria-disabled]': 'disabled',
                                '[attr.tabIndex]': 'tabIndex',
                                '[class.mat-tab-disabled]': 'disabled',
                                '[class.mat-tab-label-active]': 'active',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatTabLink.ctorParameters = function () { return [
                { type: MatTabNav },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatTabsModule = /** @class */ (function () {
                function MatTabsModule() {
                }
                return MatTabsModule;
            }());
            MatTabsModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_14__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_2__["PortalModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatRippleModule"],
                                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_13__["ObserversModule"],
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["A11yModule"],
                            ],
                            // Don't export all components because some are only to be used internally.
                            exports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"],
                                MatTabGroup,
                                MatTabLabel,
                                MatTab,
                                MatTabNav,
                                MatTabLink,
                                MatTabContent,
                            ],
                            declarations: [
                                MatTabGroup,
                                MatTabLabel,
                                MatTab,
                                MatInkBar,
                                MatTabLabelWrapper,
                                MatTabNav,
                                MatTabLink,
                                MatTabBody,
                                MatTabBodyPortal,
                                MatTabHeader,
                                MatTabContent,
                                ( /** @type {?} */(
                                // TODO(crisbeto): these can be removed once they're turned into selector-less directives.
                                MatPaginatedTabHeader)),
                                ( /** @type {?} */(_MatTabGroupBase)),
                                ( /** @type {?} */(_MatTabNavBase)),
                                ( /** @type {?} */(_MatTabBodyBase)),
                                ( /** @type {?} */(_MatTabHeaderBase)),
                                ( /** @type {?} */(_MatTabLinkBase)),
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=tabs.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/tooltip.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/tooltip.js ***!
          \***********************************************************/
        /*! exports provided: MatTooltipModule, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTooltipModule", function () { return MatTooltipModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatTooltipInvalidPositionError", function () { return getMatTooltipInvalidPositionError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY", function () { return MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY", function () { return MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCROLL_THROTTLE_MS", function () { return SCROLL_THROTTLE_MS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_PANEL_CLASS", function () { return TOOLTIP_PANEL_CLASS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY", function () { return MAT_TOOLTIP_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_DEFAULT_OPTIONS", function () { return MAT_TOOLTIP_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTooltip", function () { return MatTooltip; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TooltipComponent", function () { return TooltipComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matTooltipAnimations", function () { return matTooltipAnimations; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by MatTooltip.
             * \@docs-private
             * @type {?}
             */
            var matTooltipAnimations = {
                /**
                 * Animation that transitions a tooltip in and out.
                 */
                tooltipState: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('state', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('initial, void, hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(0)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'scale(1)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('200ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(0)', offset: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 1, transform: 'scale(1)', offset: 1 })
                    ]))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }))),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Time in ms to throttle repositioning after scroll events.
             * @type {?}
             */
            var SCROLL_THROTTLE_MS = 20;
            /**
             * CSS class that will be attached to the overlay panel.
             * @type {?}
             */
            var TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';
            /**
             * Creates an error to be thrown if the user supplied an invalid tooltip position.
             * \@docs-private
             * @param {?} position
             * @return {?}
             */
            function getMatTooltipInvalidPositionError(position) {
                return Error("Tooltip position \"" + position + "\" is invalid.");
            }
            /**
             * Injection token that determines the scroll handling while a tooltip is visible.
             * @type {?}
             */
            var MAT_TOOLTIP_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_10__["InjectionToken"]('mat-tooltip-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_TOOLTIP_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]],
                useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Injection token to be used to override the default options for `matTooltip`.
             * @type {?}
             */
            var MAT_TOOLTIP_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_10__["InjectionToken"]('mat-tooltip-default-options', {
                providedIn: 'root',
                factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
                return {
                    showDelay: 0,
                    hideDelay: 0,
                    touchendHideDelay: 1500,
                };
            }
            /**
             * Directive that attaches a material design tooltip to the host element. Animates the showing and
             * hiding of a tooltip provided position (defaults to below the element).
             *
             * https://material.io/design/components/tooltips.html
             */
            var MatTooltip = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _elementRef
                 * @param {?} _scrollDispatcher
                 * @param {?} _viewContainerRef
                 * @param {?} _ngZone
                 * @param {?} platform
                 * @param {?} _ariaDescriber
                 * @param {?} _focusMonitor
                 * @param {?} scrollStrategy
                 * @param {?} _dir
                 * @param {?} _defaultOptions
                 * @param {?=} hammerLoader
                 */
                function MatTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, hammerLoader) {
                    var _this = this;
                    this._overlay = _overlay;
                    this._elementRef = _elementRef;
                    this._scrollDispatcher = _scrollDispatcher;
                    this._viewContainerRef = _viewContainerRef;
                    this._ngZone = _ngZone;
                    this._ariaDescriber = _ariaDescriber;
                    this._focusMonitor = _focusMonitor;
                    this._dir = _dir;
                    this._defaultOptions = _defaultOptions;
                    this._position = 'below';
                    this._disabled = false;
                    /**
                     * The default delay in ms before showing the tooltip after show is called
                     */
                    this.showDelay = this._defaultOptions.showDelay;
                    /**
                     * The default delay in ms before hiding the tooltip after hide is called
                     */
                    this.hideDelay = this._defaultOptions.hideDelay;
                    this._message = '';
                    this._manualListeners = new Map();
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_12__["Subject"]();
                    this._scrollStrategy = scrollStrategy;
                    /** @type {?} */
                    var element = _elementRef.nativeElement;
                    /** @type {?} */
                    var hasGestures = typeof window === 'undefined' || (( /** @type {?} */(window))).Hammer || hammerLoader;
                    // The mouse events shouldn't be bound on mobile devices, because they can prevent the
                    // first tap from firing its click event or can cause the tooltip to open for clicks.
                    if (!platform.IOS && !platform.ANDROID) {
                        this._manualListeners
                            .set('mouseenter', ( /**
                     * @return {?}
                     */function () { return _this.show(); }))
                            .set('mouseleave', ( /**
                     * @return {?}
                     */function () { return _this.hide(); }));
                    }
                    else if (!hasGestures) {
                        // If Hammerjs isn't loaded, fall back to showing on `touchstart`, otherwise
                        // there's no way for the user to trigger the tooltip on a touch device.
                        this._manualListeners.set('touchstart', ( /**
                         * @return {?}
                         */function () { return _this.show(); }));
                    }
                    this._manualListeners.forEach(( /**
                     * @param {?} listener
                     * @param {?} event
                     * @return {?}
                     */function (listener, event) { return element.addEventListener(event, listener); }));
                    _focusMonitor.monitor(_elementRef).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} origin
                     * @return {?}
                     */function (/**
                     * @param {?} origin
                     * @return {?}
                     */ origin) {
                        // Note that the focus monitor runs outside the Angular zone.
                        if (!origin) {
                            _ngZone.run(( /**
                             * @return {?}
                             */function () { return _this.hide(0); }));
                        }
                        else if (origin === 'keyboard') {
                            _ngZone.run(( /**
                             * @return {?}
                             */function () { return _this.show(); }));
                        }
                    }));
                    if (_defaultOptions && _defaultOptions.position) {
                        this.position = _defaultOptions.position;
                    }
                }
                Object.defineProperty(MatTooltip.prototype, "position", {
                    /**
                     * Allows the user to define the position of the tooltip relative to the parent element
                     * @return {?}
                     */
                    get: function () { return this._position; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this._position) {
                            this._position = value;
                            if (this._overlayRef) {
                                this._updatePosition();
                                if (this._tooltipInstance) {
                                    ( /** @type {?} */(this._tooltipInstance)).show(0);
                                }
                                this._overlayRef.updatePosition();
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTooltip.prototype, "disabled", {
                    /**
                     * Disables the display of the tooltip.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                        // If tooltip is disabled, hide immediately.
                        if (this._disabled) {
                            this.hide(0);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTooltip.prototype, "message", {
                    /**
                     * The message to be displayed in the tooltip
                     * @return {?}
                     */
                    get: function () { return this._message; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);
                        // If the message is not a string (e.g. number), convert it to a string and trim it.
                        this._message = value != null ? ("" + value).trim() : '';
                        if (!this._message && this._isTooltipVisible()) {
                            this.hide(0);
                        }
                        else {
                            this._updateTooltipMessage();
                            this._ngZone.runOutsideAngular(( /**
                             * @return {?}
                             */function () {
                                // The `AriaDescriber` has some functionality that avoids adding a description if it's the
                                // same as the `aria-label` of an element, however we can't know whether the tooltip trigger
                                // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the
                                // issue by deferring the description by a tick so Angular has time to set the `aria-label`.
                                Promise.resolve().then(( /**
                                 * @return {?}
                                 */function () {
                                    _this._ariaDescriber.describe(_this._elementRef.nativeElement, _this.message);
                                }));
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTooltip.prototype, "tooltipClass", {
                    /**
                     * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.
                     * @return {?}
                     */
                    get: function () { return this._tooltipClass; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._tooltipClass = value;
                        if (this._tooltipInstance) {
                            this._setTooltipClass(this._tooltipClass);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Setup styling-specific things
                 * @return {?}
                 */
                MatTooltip.prototype.ngOnInit = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var elementStyle = ( /** @type {?} */(element.style));
                    if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
                        // When we bind a gesture event on an element (in this case `longpress`), HammerJS
                        // will add some inline styles by default, including `user-select: none`. This is
                        // problematic on iOS and in Safari, because it will prevent users from typing in inputs.
                        // Since `user-select: none` is not needed for the `longpress` event and can cause unexpected
                        // behavior for text fields, we always clear the `user-select` to avoid such issues.
                        elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = '';
                    }
                    // Hammer applies `-webkit-user-drag: none` on all elements by default,
                    // which breaks the native drag&drop. If the consumer explicitly made
                    // the element draggable, clear the `-webkit-user-drag`.
                    if (element.draggable && elementStyle.webkitUserDrag === 'none') {
                        elementStyle.webkitUserDrag = '';
                    }
                };
                /**
                 * Dispose the tooltip when destroyed.
                 * @return {?}
                 */
                MatTooltip.prototype.ngOnDestroy = function () {
                    var _this = this;
                    if (this._overlayRef) {
                        this._overlayRef.dispose();
                        this._tooltipInstance = null;
                    }
                    // Clean up the event listeners set in the constructor
                    this._manualListeners.forEach(( /**
                     * @param {?} listener
                     * @param {?} event
                     * @return {?}
                     */function (listener, event) {
                        _this._elementRef.nativeElement.removeEventListener(event, listener);
                    }));
                    this._manualListeners.clear();
                    this._destroyed.next();
                    this._destroyed.complete();
                    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
                 * @param {?=} delay
                 * @return {?}
                 */
                MatTooltip.prototype.show = function (delay) {
                    var _this = this;
                    if (delay === void 0) { delay = this.showDelay; }
                    if (this.disabled || !this.message || (this._isTooltipVisible() &&
                        !( /** @type {?} */(this._tooltipInstance))._showTimeoutId && !( /** @type {?} */(this._tooltipInstance))._hideTimeoutId)) {
                        return;
                    }
                    /** @type {?} */
                    var overlayRef = this._createOverlay();
                    this._detach();
                    this._portal = this._portal || new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["ComponentPortal"](TooltipComponent, this._viewContainerRef);
                    this._tooltipInstance = overlayRef.attach(this._portal).instance;
                    this._tooltipInstance.afterHidden()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this._detach(); }));
                    this._setTooltipClass(this._tooltipClass);
                    this._updateTooltipMessage();
                    ( /** @type {?} */(this._tooltipInstance)).show(delay);
                };
                /**
                 * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
                 * @param {?=} delay
                 * @return {?}
                 */
                MatTooltip.prototype.hide = function (delay) {
                    if (delay === void 0) { delay = this.hideDelay; }
                    if (this._tooltipInstance) {
                        this._tooltipInstance.hide(delay);
                    }
                };
                /**
                 * Shows/hides the tooltip
                 * @return {?}
                 */
                MatTooltip.prototype.toggle = function () {
                    this._isTooltipVisible() ? this.hide() : this.show();
                };
                /**
                 * Returns true if the tooltip is currently visible to the user
                 * @return {?}
                 */
                MatTooltip.prototype._isTooltipVisible = function () {
                    return !!this._tooltipInstance && this._tooltipInstance.isVisible();
                };
                /**
                 * Handles the keydown events on the host element.
                 * @param {?} e
                 * @return {?}
                 */
                MatTooltip.prototype._handleKeydown = function (e) {
                    if (this._isTooltipVisible() && e.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ESCAPE"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["hasModifierKey"])(e)) {
                        e.preventDefault();
                        e.stopPropagation();
                        this.hide(0);
                    }
                };
                /**
                 * Handles the touchend events on the host element.
                 * @return {?}
                 */
                MatTooltip.prototype._handleTouchend = function () {
                    this.hide(this._defaultOptions.touchendHideDelay);
                };
                /**
                 * Create the overlay config and position strategy
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._createOverlay = function () {
                    var _this = this;
                    if (this._overlayRef) {
                        return this._overlayRef;
                    }
                    /** @type {?} */
                    var scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
                    // Create connected position strategy that listens for scroll events to reposition.
                    /** @type {?} */
                    var strategy = this._overlay.position()
                        .flexibleConnectedTo(this._elementRef)
                        .withTransformOriginOn('.mat-tooltip')
                        .withFlexibleDimensions(false)
                        .withViewportMargin(8)
                        .withScrollableContainers(scrollableAncestors);
                    strategy.positionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} change
                     * @return {?}
                     */function (/**
                     * @param {?} change
                     * @return {?}
                     */ change) {
                        if (_this._tooltipInstance) {
                            if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {
                                // After position changes occur and the overlay is clipped by
                                // a parent scrollable then close the tooltip.
                                _this._ngZone.run(( /**
                                 * @return {?}
                                 */function () { return _this.hide(0); }));
                            }
                        }
                    }));
                    this._overlayRef = this._overlay.create({
                        direction: this._dir,
                        positionStrategy: strategy,
                        panelClass: TOOLTIP_PANEL_CLASS,
                        scrollStrategy: this._scrollStrategy()
                    });
                    this._updatePosition();
                    this._overlayRef.detachments()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this._detach(); }));
                    return this._overlayRef;
                };
                /**
                 * Detaches the currently-attached tooltip.
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._detach = function () {
                    if (this._overlayRef && this._overlayRef.hasAttached()) {
                        this._overlayRef.detach();
                    }
                    this._tooltipInstance = null;
                };
                /**
                 * Updates the position of the current tooltip.
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._updatePosition = function () {
                    /** @type {?} */
                    var position = ( /** @type {?} */(( /** @type {?} */(this._overlayRef)).getConfig().positionStrategy));
                    /** @type {?} */
                    var origin = this._getOrigin();
                    /** @type {?} */
                    var overlay = this._getOverlayPosition();
                    position.withPositions([
                        Object.assign({}, origin.main, overlay.main),
                        Object.assign({}, origin.fallback, overlay.fallback)
                    ]);
                };
                /**
                 * Returns the origin position and a fallback position based on the user's position preference.
                 * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
                 * @return {?}
                 */
                MatTooltip.prototype._getOrigin = function () {
                    /** @type {?} */
                    var isLtr = !this._dir || this._dir.value == 'ltr';
                    /** @type {?} */
                    var position = this.position;
                    /** @type {?} */
                    var originPosition;
                    if (position == 'above' || position == 'below') {
                        originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };
                    }
                    else if (position == 'before' ||
                        (position == 'left' && isLtr) ||
                        (position == 'right' && !isLtr)) {
                        originPosition = { originX: 'start', originY: 'center' };
                    }
                    else if (position == 'after' ||
                        (position == 'right' && isLtr) ||
                        (position == 'left' && !isLtr)) {
                        originPosition = { originX: 'end', originY: 'center' };
                    }
                    else {
                        throw getMatTooltipInvalidPositionError(position);
                    }
                    var _a = this._invertPosition(originPosition.originX, originPosition.originY), x = _a.x, y = _a.y;
                    return {
                        main: originPosition,
                        fallback: { originX: x, originY: y }
                    };
                };
                /**
                 * Returns the overlay position and a fallback position based on the user's preference
                 * @return {?}
                 */
                MatTooltip.prototype._getOverlayPosition = function () {
                    /** @type {?} */
                    var isLtr = !this._dir || this._dir.value == 'ltr';
                    /** @type {?} */
                    var position = this.position;
                    /** @type {?} */
                    var overlayPosition;
                    if (position == 'above') {
                        overlayPosition = { overlayX: 'center', overlayY: 'bottom' };
                    }
                    else if (position == 'below') {
                        overlayPosition = { overlayX: 'center', overlayY: 'top' };
                    }
                    else if (position == 'before' ||
                        (position == 'left' && isLtr) ||
                        (position == 'right' && !isLtr)) {
                        overlayPosition = { overlayX: 'end', overlayY: 'center' };
                    }
                    else if (position == 'after' ||
                        (position == 'right' && isLtr) ||
                        (position == 'left' && !isLtr)) {
                        overlayPosition = { overlayX: 'start', overlayY: 'center' };
                    }
                    else {
                        throw getMatTooltipInvalidPositionError(position);
                    }
                    var _a = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY), x = _a.x, y = _a.y;
                    return {
                        main: overlayPosition,
                        fallback: { overlayX: x, overlayY: y }
                    };
                };
                /**
                 * Updates the tooltip message and repositions the overlay according to the new message length
                 * @private
                 * @return {?}
                 */
                MatTooltip.prototype._updateTooltipMessage = function () {
                    var _this = this;
                    // Must wait for the message to be painted to the tooltip so that the overlay can properly
                    // calculate the correct positioning based on the size of the text.
                    if (this._tooltipInstance) {
                        this._tooltipInstance.message = this.message;
                        this._tooltipInstance._markForCheck();
                        this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__["takeUntil"])(this._destroyed)).subscribe(( /**
                         * @return {?}
                         */function () {
                            if (_this._tooltipInstance) {
                                ( /** @type {?} */(_this._overlayRef)).updatePosition();
                            }
                        }));
                    }
                };
                /**
                 * Updates the tooltip class
                 * @private
                 * @param {?} tooltipClass
                 * @return {?}
                 */
                MatTooltip.prototype._setTooltipClass = function (tooltipClass) {
                    if (this._tooltipInstance) {
                        this._tooltipInstance.tooltipClass = tooltipClass;
                        this._tooltipInstance._markForCheck();
                    }
                };
                /**
                 * Inverts an overlay position.
                 * @private
                 * @param {?} x
                 * @param {?} y
                 * @return {?}
                 */
                MatTooltip.prototype._invertPosition = function (x, y) {
                    if (this.position === 'above' || this.position === 'below') {
                        if (y === 'top') {
                            y = 'bottom';
                        }
                        else if (y === 'bottom') {
                            y = 'top';
                        }
                    }
                    else {
                        if (x === 'end') {
                            x = 'start';
                        }
                        else if (x === 'start') {
                            x = 'end';
                        }
                    }
                    return { x: x, y: y };
                };
                return MatTooltip;
            }());
            MatTooltip.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Directive"], args: [{
                            selector: '[matTooltip]',
                            exportAs: 'matTooltip',
                            host: {
                                '(longpress)': 'show()',
                                '(keydown)': '_handleKeydown($event)',
                                '(touchend)': '_handleTouchend()',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatTooltip.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ElementRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ScrollDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__["Platform"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["AriaDescriber"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Inject"], args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Inject"], args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Inject"], args: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_11__["HAMMER_LOADER"],] }] }
            ]; };
            MatTooltip.propDecorators = {
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipPosition',] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipDisabled',] }],
                showDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipShowDelay',] }],
                hideDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipHideDelay',] }],
                message: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltip',] }],
                tooltipClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Input"], args: ['matTooltipClass',] }]
            };
            /**
             * Internal component that wraps the tooltip's content.
             * \@docs-private
             */
            var TooltipComponent = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _breakpointObserver
                 */
                function TooltipComponent(_changeDetectorRef, _breakpointObserver) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._breakpointObserver = _breakpointObserver;
                    /**
                     * Property watched by the animation framework to show or hide the tooltip
                     */
                    this._visibility = 'initial';
                    /**
                     * Whether interactions on the page should close the tooltip
                     */
                    this._closeOnInteraction = false;
                    /**
                     * Subject for notifying that the tooltip has been hidden from the view
                     */
                    this._onHide = new rxjs__WEBPACK_IMPORTED_MODULE_12__["Subject"]();
                    /**
                     * Stream that emits whether the user has a handset-sized display.
                     */
                    this._isHandset = this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_5__["Breakpoints"].Handset);
                }
                /**
                 * Shows the tooltip with an animation originating from the provided origin
                 * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
                 * @return {?}
                 */
                TooltipComponent.prototype.show = function (delay) {
                    var _this = this;
                    // Cancel the delayed hide if it is scheduled
                    if (this._hideTimeoutId) {
                        clearTimeout(this._hideTimeoutId);
                        this._hideTimeoutId = null;
                    }
                    // Body interactions should cancel the tooltip if there is a delay in showing.
                    this._closeOnInteraction = true;
                    this._showTimeoutId = setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this._visibility = 'visible';
                        _this._showTimeoutId = null;
                        // Mark for check so if any parent component has set the
                        // ChangeDetectionStrategy to OnPush it will be checked anyways
                        _this._markForCheck();
                    }), delay);
                };
                /**
                 * Begins the animation to hide the tooltip after the provided delay in ms.
                 * @param {?} delay Amount of milliseconds to delay showing the tooltip.
                 * @return {?}
                 */
                TooltipComponent.prototype.hide = function (delay) {
                    var _this = this;
                    // Cancel the delayed show if it is scheduled
                    if (this._showTimeoutId) {
                        clearTimeout(this._showTimeoutId);
                        this._showTimeoutId = null;
                    }
                    this._hideTimeoutId = setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this._visibility = 'hidden';
                        _this._hideTimeoutId = null;
                        // Mark for check so if any parent component has set the
                        // ChangeDetectionStrategy to OnPush it will be checked anyways
                        _this._markForCheck();
                    }), delay);
                };
                /**
                 * Returns an observable that notifies when the tooltip has been hidden from view.
                 * @return {?}
                 */
                TooltipComponent.prototype.afterHidden = function () {
                    return this._onHide.asObservable();
                };
                /**
                 * Whether the tooltip is being displayed.
                 * @return {?}
                 */
                TooltipComponent.prototype.isVisible = function () {
                    return this._visibility === 'visible';
                };
                /**
                 * @return {?}
                 */
                TooltipComponent.prototype.ngOnDestroy = function () {
                    this._onHide.complete();
                };
                /**
                 * @return {?}
                 */
                TooltipComponent.prototype._animationStart = function () {
                    this._closeOnInteraction = false;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                TooltipComponent.prototype._animationDone = function (event) {
                    /** @type {?} */
                    var toState = ( /** @type {?} */(event.toState));
                    if (toState === 'hidden' && !this.isVisible()) {
                        this._onHide.next();
                    }
                    if (toState === 'visible' || toState === 'hidden') {
                        this._closeOnInteraction = true;
                    }
                };
                /**
                 * Interactions on the HTML body should close the tooltip immediately as defined in the
                 * material design spec.
                 * https://material.io/design/components/tooltips.html#behavior
                 * @return {?}
                 */
                TooltipComponent.prototype._handleBodyInteraction = function () {
                    if (this._closeOnInteraction) {
                        this.hide(0);
                    }
                };
                /**
                 * Marks that the tooltip needs to be checked in the next change detection run.
                 * Mainly used for rendering the initial text before positioning a tooltip, which
                 * can be problematic in components with OnPush change detection.
                 * @return {?}
                 */
                TooltipComponent.prototype._markForCheck = function () {
                    this._changeDetectorRef.markForCheck();
                };
                return TooltipComponent;
            }());
            TooltipComponent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["Component"], args: [{ selector: 'mat-tooltip-component',
                            template: "<div class=\"mat-tooltip\" [ngClass]=\"tooltipClass\" [class.mat-tooltip-handset]=\"(_isHandset | async)?.matches\" [@state]=\"_visibility\" (@state.start)=\"_animationStart()\" (@state.done)=\"_animationDone($event)\">{{message}}</div>",
                            styles: [".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ChangeDetectionStrategy"].OnPush,
                            animations: [matTooltipAnimations.tooltipState],
                            host: {
                                // Forces the element to have a layout in IE and Edge. This fixes issues where the element
                                // won't be rendered if the animations are disabled or there is no web animations polyfill.
                                '[style.zoom]': '_visibility === "visible" ? 1 : null',
                                '(body:click)': 'this._handleBodyInteraction()',
                                'aria-hidden': 'true',
                            }
                        },] },
            ];
            /** @nocollapse */
            TooltipComponent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["ChangeDetectorRef"] },
                { type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_5__["BreakpointObserver"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatTooltipModule = /** @class */ (function () {
                function MatTooltipModule() {
                }
                return MatTooltipModule;
            }());
            MatTooltipModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_10__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["A11yModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_14__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_15__["MatCommonModule"],
                            ],
                            exports: [MatTooltip, TooltipComponent, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__["MatCommonModule"]],
                            declarations: [MatTooltip, TooltipComponent],
                            entryComponents: [TooltipComponent],
                            providers: [
                                MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,
                                { provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_11__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_15__["GestureConfig"] },
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=tooltip.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/snack-bar/typings/index.ngfactory.js": 
        /*!*****************************************************************************!*\
          !*** ./node_modules/@angular/material/snack-bar/typings/index.ngfactory.js ***!
          \*****************************************************************************/
        /*! exports provided: MatSnackBarModuleNgFactory, RenderType_MatSnackBarContainer, View_MatSnackBarContainer_0, View_MatSnackBarContainer_Host_0, MatSnackBarContainerNgFactory, RenderType_SimpleSnackBar, View_SimpleSnackBar_0, View_SimpleSnackBar_Host_0, SimpleSnackBarNgFactory */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarModuleNgFactory", function () { return MatSnackBarModuleNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_MatSnackBarContainer", function () { return RenderType_MatSnackBarContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatSnackBarContainer_0", function () { return View_MatSnackBarContainer_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_MatSnackBarContainer_Host_0", function () { return View_MatSnackBarContainer_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarContainerNgFactory", function () { return MatSnackBarContainerNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_SimpleSnackBar", function () { return RenderType_SimpleSnackBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_SimpleSnackBar_0", function () { return View_SimpleSnackBar_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_SimpleSnackBar_Host_0", function () { return View_SimpleSnackBar_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleSnackBarNgFactory", function () { return SimpleSnackBarNgFactory; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/snack-bar */ "./node_modules/@angular/material/esm2015/snack-bar.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../button/typings/index.ngfactory */ "./node_modules/@angular/material/button/typings/index.ngfactory.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /**
             * @fileoverview This file was generated by the Angular template compiler. Do not edit.
             *
             * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
             * tslint:disable
             */
            var MatSnackBarModuleNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcmf"](_angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarModule"], [], function (_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmod"]([_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](512, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵCodegenComponentFactoryResolver"], [[8, [MatSnackBarContainerNgFactory, SimpleSnackBarNgFactory]], [3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModuleRef"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["Overlay"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["Overlay"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["ScrollStrategyOptions"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["OverlayContainer"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["OverlayPositionBuilder"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["OverlayKeyboardDispatcher"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_3__["Location"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["ɵc"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["ɵd"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgLocalization"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgLocaleLocalization"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["LOCALE_ID"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_3__["ɵangular_packages_common_common_a"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["BidiModule"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["BidiModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["PlatformModule"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_6__["PlatformModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__["ScrollingModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_7__["ScrollingModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["OverlayModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_2__["OverlayModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"], [[2, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MATERIAL_SANITY_CHECKS"]], [2, _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_LOADER"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatRippleModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButtonModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButtonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarModule"], _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarModule"], [])]); });
            var styles_MatSnackBarContainer = [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}@media (-ms-high-contrast:active){.mat-snack-bar-container{border:solid 1px}}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}"];
            var RenderType_MatSnackBarContainer = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_MatSnackBarContainer, data: { "animation": [{ type: 7, name: "state", definitions: [{ type: 0, name: "void, hidden", styles: { type: 6, styles: { transform: "scale(0.8)", opacity: 0 }, offset: null }, options: undefined }, { type: 0, name: "visible", styles: { type: 6, styles: { transform: "scale(1)", opacity: 1 }, offset: null }, options: undefined }, { type: 1, expr: "* => visible", animation: { type: 4, styles: null, timings: "150ms cubic-bezier(0, 0, 0.2, 1)" }, options: null }, { type: 1, expr: "* => void, * => hidden", animation: { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: "75ms cubic-bezier(0.4, 0.0, 1, 1)" }, options: null }], options: {} }] } });
            function View_MatSnackBarContainer_1(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](0, null, null, 0))], null, null); }
            function View_MatSnackBarContainer_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵqud"](402653184, 1, { _portalOutlet: 0 }), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_MatSnackBarContainer_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 212992, [[1, 4]], 0, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["CdkPortalOutlet"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"]], { portal: [0, "portal"] }, null)], function (_ck, _v) { var currVal_0 = ""; _ck(_v, 2, 0, currVal_0); }, null); }
            function View_MatSnackBarContainer_Host_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "snack-bar-container", [["class", "mat-snack-bar-container"]], [[1, "role", 0], [40, "@state", 0]], [["component", "@state.done"]], function (_v, en, $event) {
                        var ad = true;
                        if (("component:@state.done" === en)) {
                            var pd_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1).onAnimationEnd($event) !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, View_MatSnackBarContainer_0, RenderType_MatSnackBarContainer)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 180224, null, 0, _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarContainer"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarConfig"]], null, null)], null, function (_ck, _v) { var currVal_0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._role; var currVal_1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._animationState; _ck(_v, 0, 0, currVal_0, currVal_1); });
            }
            var MatSnackBarContainerNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("snack-bar-container", _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarContainer"], View_MatSnackBarContainer_Host_0, {}, {}, []);
            var styles_SimpleSnackBar = [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}"];
            var RenderType_SimpleSnackBar = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_SimpleSnackBar, data: {} });
            function View_SimpleSnackBar_1(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 3, "div", [["class", "mat-simple-snackbar-action"]], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](1, 0, null, null, 2, "button", [["mat-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("click" === en)) {
                            var pd_0 = (_co.action() !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_11__["View_MatButton_0"], _button_typings_index_ngfactory__WEBPACK_IMPORTED_MODULE_11__["RenderType_MatButton"])), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 180224, null, 0, _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButton"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_12__["FocusMonitor"], [2, _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_13__["ANIMATION_MODULE_TYPE"]]], null, null), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](3, 0, ["", ""]))], null, function (_ck, _v) { var _co = _v.component; var currVal_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 2).disabled || null); var currVal_1 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 2)._animationMode === "NoopAnimations"); _ck(_v, 1, 0, currVal_0, currVal_1); var currVal_2 = _co.data.action; _ck(_v, 3, 0, currVal_2); });
            }
            function View_SimpleSnackBar_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "span", [], null, null, null, null, null)), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](1, null, ["", ""])), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵand"](16777216, null, null, 1, null, View_SimpleSnackBar_1)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](3, 16384, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgIf"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]], { ngIf: [0, "ngIf"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_1 = _co.hasAction; _ck(_v, 3, 0, currVal_1); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.data.message; _ck(_v, 1, 0, currVal_0); }); }
            function View_SimpleSnackBar_Host_0(_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "simple-snack-bar", [["class", "mat-simple-snackbar"]], null, null, null, View_SimpleSnackBar_0, RenderType_SimpleSnackBar)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 49152, null, 0, _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["SimpleSnackBar"], [_angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MatSnackBarRef"], _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["MAT_SNACK_BAR_DATA"]], null, null)], null, null); }
            var SimpleSnackBarNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("simple-snack-bar", _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_1__["SimpleSnackBar"], View_SimpleSnackBar_Host_0, {}, {}, []);
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/tooltip/typings/index.ngfactory.js": 
        /*!***************************************************************************!*\
          !*** ./node_modules/@angular/material/tooltip/typings/index.ngfactory.js ***!
          \***************************************************************************/
        /*! exports provided: MatTooltipModuleNgFactory, RenderType_TooltipComponent, View_TooltipComponent_0, View_TooltipComponent_Host_0, TooltipComponentNgFactory */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTooltipModuleNgFactory", function () { return MatTooltipModuleNgFactory; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType_TooltipComponent", function () { return RenderType_TooltipComponent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_TooltipComponent_0", function () { return View_TooltipComponent_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "View_TooltipComponent_Host_0", function () { return View_TooltipComponent_Host_0; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TooltipComponentNgFactory", function () { return TooltipComponentNgFactory; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm2015/tooltip.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /**
             * @fileoverview This file was generated by the Angular template compiler. Do not edit.
             *
             * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}
             * tslint:disable
             */
            var MatTooltipModuleNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcmf"](_angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["MatTooltipModule"], [], function (_l) { return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmod"]([_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](512, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵCodegenComponentFactoryResolver"], [[8, [TooltipComponentNgFactory]], [3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModuleRef"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgLocalization"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgLocaleLocalization"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["LOCALE_ID"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵangular_packages_common_common_a"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__["MutationObserverFactory"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__["MutationObserverFactory"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["ScrollStrategyOptions"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayContainer"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayPositionBuilder"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayKeyboardDispatcher"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], [2, _angular_common__WEBPACK_IMPORTED_MODULE_2__["Location"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["ɵc"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["ɵd"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](5120, _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["MAT_TOOLTIP_SCROLL_STRATEGY"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY"], [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["Overlay"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](4608, _angular_platform_browser__WEBPACK_IMPORTED_MODULE_6__["HAMMER_GESTURE_CONFIG"], _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["GestureConfig"], [[2, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MAT_HAMMER_OPTIONS"]], [2, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_8__["PlatformModule"], _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_8__["PlatformModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__["ObserversModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_3__["ObserversModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__["A11yModule"], _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__["A11yModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["BidiModule"], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["BidiModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__["PortalModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__["PortalModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_11__["ScrollingModule"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_11__["ScrollingModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_4__["OverlayModule"], []), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"], [[2, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MATERIAL_SANITY_CHECKS"]], [2, _angular_platform_browser__WEBPACK_IMPORTED_MODULE_6__["HAMMER_LOADER"]]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵmpd"](1073742336, _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["MatTooltipModule"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["MatTooltipModule"], [])]); });
            var styles_TooltipComponent = [".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}"];
            var RenderType_TooltipComponent = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵcrt"]({ encapsulation: 2, styles: styles_TooltipComponent, data: { "animation": [{ type: 7, name: "state", definitions: [{ type: 0, name: "initial, void, hidden", styles: { type: 6, styles: { opacity: 0, transform: "scale(0)" }, offset: null }, options: undefined }, { type: 0, name: "visible", styles: { type: 6, styles: { transform: "scale(1)" }, offset: null }, options: undefined }, { type: 1, expr: "* => visible", animation: { type: 4, styles: { type: 5, steps: [{ type: 6, styles: { opacity: 0, transform: "scale(0)", offset: 0 }, offset: null }, { type: 6, styles: { opacity: 0.5, transform: "scale(0.99)", offset: 0.5 }, offset: null }, { type: 6, styles: { opacity: 1, transform: "scale(1)", offset: 1 }, offset: null }] }, timings: "200ms cubic-bezier(0, 0, 0.2, 1)" }, options: null }, { type: 1, expr: "* => hidden", animation: { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: "100ms cubic-bezier(0, 0, 0.2, 1)" }, options: null }], options: {} }] } });
            function View_TooltipComponent_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](2, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 4, "div", [["class", "mat-tooltip"]], [[2, "mat-tooltip-handset", null], [24, "@state", 0]], [[null, "@state.start"], [null, "@state.done"]], function (_v, en, $event) {
                        var ad = true;
                        var _co = _v.component;
                        if (("@state.start" === en)) {
                            var pd_0 = (_co._animationStart() !== false);
                            ad = (pd_0 && ad);
                        }
                        if (("@state.done" === en)) {
                            var pd_1 = (_co._animationDone($event) !== false);
                            ad = (pd_1 && ad);
                        }
                        return ad;
                    }, null, null)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵprd"](512, null, _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵNgClassImpl"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵNgClassR2Impl"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["IterableDiffers"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["KeyValueDiffers"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Renderer2"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](2, 278528, null, 0, _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgClass"], [_angular_common__WEBPACK_IMPORTED_MODULE_2__["ɵNgClassImpl"]], { klass: [0, "klass"], ngClass: [1, "ngClass"] }, null), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵpid"](131072, _angular_common__WEBPACK_IMPORTED_MODULE_2__["AsyncPipe"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]]), (_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵted"](4, null, ["", ""]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = "mat-tooltip"; var currVal_3 = _co.tooltipClass; _ck(_v, 2, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var tmp_0_0 = null; var currVal_0 = (((tmp_0_0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵunv"](_v, 0, 0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 3).transform(_co._isHandset))) == null) ? null : tmp_0_0.matches); var currVal_1 = _co._visibility; _ck(_v, 0, 0, currVal_0, currVal_1); var currVal_4 = _co.message; _ck(_v, 4, 0, currVal_4); });
            }
            function View_TooltipComponent_Host_0(_l) {
                return _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵvid"](0, [(_l()(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵeld"](0, 0, null, null, 1, "mat-tooltip-component", [["aria-hidden", "true"]], [[4, "zoom", null]], [["body", "click"]], function (_v, en, $event) {
                        var ad = true;
                        if (("body:click" === en)) {
                            var pd_0 = (_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._handleBodyInteraction() !== false);
                            ad = (pd_0 && ad);
                        }
                        return ad;
                    }, View_TooltipComponent_0, RenderType_TooltipComponent)), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵdid"](1, 180224, null, 0, _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["TooltipComponent"], [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"], _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_12__["BreakpointObserver"]], null, null)], null, function (_ck, _v) { var currVal_0 = ((_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵnov"](_v, 1)._visibility === "visible") ? 1 : null); _ck(_v, 0, 0, currVal_0); });
            }
            var TooltipComponentNgFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵccf"]("mat-tooltip-component", _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_1__["TooltipComponent"], View_TooltipComponent_Host_0, {}, {}, []);
            /***/ 
        })
    }]);
//# sourceMappingURL=default~components-components-module-ngfactory~downloads-downloads-module-ngfactory-es2015.js.map
//# sourceMappingURL=default~components-components-module-ngfactory~downloads-downloads-module-ngfactory-es5.js.map
//# sourceMappingURL=default~components-components-module-ngfactory~downloads-downloads-module-ngfactory-es5.js.map